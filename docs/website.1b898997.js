// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles
parcelRequire = (function (modules, cache, entry, globalName) {
  // Save the require from previous bundle to this closure if any
  var previousRequire = typeof parcelRequire === 'function' && parcelRequire;
  var nodeRequire = typeof require === 'function' && require;

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire = typeof parcelRequire === 'function' && parcelRequire;
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error('Cannot find module \'' + name + '\'');
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = cache[name] = new newRequire.Module(name);

      modules[name][0].call(module.exports, localRequire, module, module.exports, this);
    }

    return cache[name].exports;

    function localRequire(x){
      return newRequire(localRequire.resolve(x));
    }

    function resolve(x){
      return modules[name][1][x] || x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [function (require, module) {
      module.exports = exports;
    }, {}];
  };

  var error;
  for (var i = 0; i < entry.length; i++) {
    try {
      newRequire(entry[i]);
    } catch (e) {
      // Save first error but execute all entries
      if (!error) {
        error = e;
      }
    }
  }

  if (entry.length) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(entry[entry.length - 1]);

    // CommonJS
    if (typeof exports === "object" && typeof module !== "undefined") {
      module.exports = mainExports;

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
     define(function () {
       return mainExports;
     });

    // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }

  // Override the current require with this new one
  parcelRequire = newRequire;

  if (error) {
    // throw error from earlier, _after updating parcelRequire_
    throw error;
  }

  return newRequire;
})({"W2ED":[function(require,module,exports) {
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
'use strict';
/* eslint-disable no-unused-vars */

var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
  if (val === null || val === undefined) {
    throw new TypeError('Object.assign cannot be called with null or undefined');
  }

  return Object(val);
}

function shouldUseNative() {
  try {
    if (!Object.assign) {
      return false;
    } // Detect buggy property enumeration order in older V8 versions.
    // https://bugs.chromium.org/p/v8/issues/detail?id=4118


    var test1 = new String('abc'); // eslint-disable-line no-new-wrappers

    test1[5] = 'de';

    if (Object.getOwnPropertyNames(test1)[0] === '5') {
      return false;
    } // https://bugs.chromium.org/p/v8/issues/detail?id=3056


    var test2 = {};

    for (var i = 0; i < 10; i++) {
      test2['_' + String.fromCharCode(i)] = i;
    }

    var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
      return test2[n];
    });

    if (order2.join('') !== '0123456789') {
      return false;
    } // https://bugs.chromium.org/p/v8/issues/detail?id=3056


    var test3 = {};
    'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
      test3[letter] = letter;
    });

    if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
      return false;
    }

    return true;
  } catch (err) {
    // We don't expect any of the above to throw, but better to be safe.
    return false;
  }
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
  var from;
  var to = toObject(target);
  var symbols;

  for (var s = 1; s < arguments.length; s++) {
    from = Object(arguments[s]);

    for (var key in from) {
      if (hasOwnProperty.call(from, key)) {
        to[key] = from[key];
      }
    }

    if (getOwnPropertySymbols) {
      symbols = getOwnPropertySymbols(from);

      for (var i = 0; i < symbols.length; i++) {
        if (propIsEnumerable.call(from, symbols[i])) {
          to[symbols[i]] = from[symbols[i]];
        }
      }
    }
  }

  return to;
};
},{}],"Xy56":[function(require,module,exports) {
/** @license React v17.0.1
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';

var l = require("object-assign"),
    n = 60103,
    p = 60106;

exports.Fragment = 60107;
exports.StrictMode = 60108;
exports.Profiler = 60114;
var q = 60109,
    r = 60110,
    t = 60112;
exports.Suspense = 60113;
var u = 60115,
    v = 60116;

if ("function" === typeof Symbol && Symbol.for) {
  var w = Symbol.for;
  n = w("react.element");
  p = w("react.portal");
  exports.Fragment = w("react.fragment");
  exports.StrictMode = w("react.strict_mode");
  exports.Profiler = w("react.profiler");
  q = w("react.provider");
  r = w("react.context");
  t = w("react.forward_ref");
  exports.Suspense = w("react.suspense");
  u = w("react.memo");
  v = w("react.lazy");
}

var x = "function" === typeof Symbol && Symbol.iterator;

function y(a) {
  if (null === a || "object" !== typeof a) return null;
  a = x && a[x] || a["@@iterator"];
  return "function" === typeof a ? a : null;
}

function z(a) {
  for (var b = "https://reactjs.org/docs/error-decoder.html?invariant=" + a, c = 1; c < arguments.length; c++) b += "&args[]=" + encodeURIComponent(arguments[c]);

  return "Minified React error #" + a + "; visit " + b + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}

var A = {
  isMounted: function () {
    return !1;
  },
  enqueueForceUpdate: function () {},
  enqueueReplaceState: function () {},
  enqueueSetState: function () {}
},
    B = {};

function C(a, b, c) {
  this.props = a;
  this.context = b;
  this.refs = B;
  this.updater = c || A;
}

C.prototype.isReactComponent = {};

C.prototype.setState = function (a, b) {
  if ("object" !== typeof a && "function" !== typeof a && null != a) throw Error(z(85));
  this.updater.enqueueSetState(this, a, b, "setState");
};

C.prototype.forceUpdate = function (a) {
  this.updater.enqueueForceUpdate(this, a, "forceUpdate");
};

function D() {}

D.prototype = C.prototype;

function E(a, b, c) {
  this.props = a;
  this.context = b;
  this.refs = B;
  this.updater = c || A;
}

var F = E.prototype = new D();
F.constructor = E;
l(F, C.prototype);
F.isPureReactComponent = !0;
var G = {
  current: null
},
    H = Object.prototype.hasOwnProperty,
    I = {
  key: !0,
  ref: !0,
  __self: !0,
  __source: !0
};

function J(a, b, c) {
  var e,
      d = {},
      k = null,
      h = null;
  if (null != b) for (e in void 0 !== b.ref && (h = b.ref), void 0 !== b.key && (k = "" + b.key), b) H.call(b, e) && !I.hasOwnProperty(e) && (d[e] = b[e]);
  var g = arguments.length - 2;
  if (1 === g) d.children = c;else if (1 < g) {
    for (var f = Array(g), m = 0; m < g; m++) f[m] = arguments[m + 2];

    d.children = f;
  }
  if (a && a.defaultProps) for (e in g = a.defaultProps, g) void 0 === d[e] && (d[e] = g[e]);
  return {
    $$typeof: n,
    type: a,
    key: k,
    ref: h,
    props: d,
    _owner: G.current
  };
}

function K(a, b) {
  return {
    $$typeof: n,
    type: a.type,
    key: b,
    ref: a.ref,
    props: a.props,
    _owner: a._owner
  };
}

function L(a) {
  return "object" === typeof a && null !== a && a.$$typeof === n;
}

function escape(a) {
  var b = {
    "=": "=0",
    ":": "=2"
  };
  return "$" + a.replace(/[=:]/g, function (a) {
    return b[a];
  });
}

var M = /\/+/g;

function N(a, b) {
  return "object" === typeof a && null !== a && null != a.key ? escape("" + a.key) : b.toString(36);
}

function O(a, b, c, e, d) {
  var k = typeof a;
  if ("undefined" === k || "boolean" === k) a = null;
  var h = !1;
  if (null === a) h = !0;else switch (k) {
    case "string":
    case "number":
      h = !0;
      break;

    case "object":
      switch (a.$$typeof) {
        case n:
        case p:
          h = !0;
      }

  }
  if (h) return h = a, d = d(h), a = "" === e ? "." + N(h, 0) : e, Array.isArray(d) ? (c = "", null != a && (c = a.replace(M, "$&/") + "/"), O(d, b, c, "", function (a) {
    return a;
  })) : null != d && (L(d) && (d = K(d, c + (!d.key || h && h.key === d.key ? "" : ("" + d.key).replace(M, "$&/") + "/") + a)), b.push(d)), 1;
  h = 0;
  e = "" === e ? "." : e + ":";
  if (Array.isArray(a)) for (var g = 0; g < a.length; g++) {
    k = a[g];
    var f = e + N(k, g);
    h += O(k, b, c, f, d);
  } else if (f = y(a), "function" === typeof f) for (a = f.call(a), g = 0; !(k = a.next()).done;) k = k.value, f = e + N(k, g++), h += O(k, b, c, f, d);else if ("object" === k) throw b = "" + a, Error(z(31, "[object Object]" === b ? "object with keys {" + Object.keys(a).join(", ") + "}" : b));
  return h;
}

function P(a, b, c) {
  if (null == a) return a;
  var e = [],
      d = 0;
  O(a, e, "", "", function (a) {
    return b.call(c, a, d++);
  });
  return e;
}

function Q(a) {
  if (-1 === a._status) {
    var b = a._result;
    b = b();
    a._status = 0;
    a._result = b;
    b.then(function (b) {
      0 === a._status && (b = b.default, a._status = 1, a._result = b);
    }, function (b) {
      0 === a._status && (a._status = 2, a._result = b);
    });
  }

  if (1 === a._status) return a._result;
  throw a._result;
}

var R = {
  current: null
};

function S() {
  var a = R.current;
  if (null === a) throw Error(z(321));
  return a;
}

var T = {
  ReactCurrentDispatcher: R,
  ReactCurrentBatchConfig: {
    transition: 0
  },
  ReactCurrentOwner: G,
  IsSomeRendererActing: {
    current: !1
  },
  assign: l
};
exports.Children = {
  map: P,
  forEach: function (a, b, c) {
    P(a, function () {
      b.apply(this, arguments);
    }, c);
  },
  count: function (a) {
    var b = 0;
    P(a, function () {
      b++;
    });
    return b;
  },
  toArray: function (a) {
    return P(a, function (a) {
      return a;
    }) || [];
  },
  only: function (a) {
    if (!L(a)) throw Error(z(143));
    return a;
  }
};
exports.Component = C;
exports.PureComponent = E;
exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = T;

exports.cloneElement = function (a, b, c) {
  if (null === a || void 0 === a) throw Error(z(267, a));
  var e = l({}, a.props),
      d = a.key,
      k = a.ref,
      h = a._owner;

  if (null != b) {
    void 0 !== b.ref && (k = b.ref, h = G.current);
    void 0 !== b.key && (d = "" + b.key);
    if (a.type && a.type.defaultProps) var g = a.type.defaultProps;

    for (f in b) H.call(b, f) && !I.hasOwnProperty(f) && (e[f] = void 0 === b[f] && void 0 !== g ? g[f] : b[f]);
  }

  var f = arguments.length - 2;
  if (1 === f) e.children = c;else if (1 < f) {
    g = Array(f);

    for (var m = 0; m < f; m++) g[m] = arguments[m + 2];

    e.children = g;
  }
  return {
    $$typeof: n,
    type: a.type,
    key: d,
    ref: k,
    props: e,
    _owner: h
  };
};

exports.createContext = function (a, b) {
  void 0 === b && (b = null);
  a = {
    $$typeof: r,
    _calculateChangedBits: b,
    _currentValue: a,
    _currentValue2: a,
    _threadCount: 0,
    Provider: null,
    Consumer: null
  };
  a.Provider = {
    $$typeof: q,
    _context: a
  };
  return a.Consumer = a;
};

exports.createElement = J;

exports.createFactory = function (a) {
  var b = J.bind(null, a);
  b.type = a;
  return b;
};

exports.createRef = function () {
  return {
    current: null
  };
};

exports.forwardRef = function (a) {
  return {
    $$typeof: t,
    render: a
  };
};

exports.isValidElement = L;

exports.lazy = function (a) {
  return {
    $$typeof: v,
    _payload: {
      _status: -1,
      _result: a
    },
    _init: Q
  };
};

exports.memo = function (a, b) {
  return {
    $$typeof: u,
    type: a,
    compare: void 0 === b ? null : b
  };
};

exports.useCallback = function (a, b) {
  return S().useCallback(a, b);
};

exports.useContext = function (a, b) {
  return S().useContext(a, b);
};

exports.useDebugValue = function () {};

exports.useEffect = function (a, b) {
  return S().useEffect(a, b);
};

exports.useImperativeHandle = function (a, b, c) {
  return S().useImperativeHandle(a, b, c);
};

exports.useLayoutEffect = function (a, b) {
  return S().useLayoutEffect(a, b);
};

exports.useMemo = function (a, b) {
  return S().useMemo(a, b);
};

exports.useReducer = function (a, b, c) {
  return S().useReducer(a, b, c);
};

exports.useRef = function (a) {
  return S().useRef(a);
};

exports.useState = function (a) {
  return S().useState(a);
};

exports.version = "17.0.1";
},{"object-assign":"W2ED"}],"ccIB":[function(require,module,exports) {
'use strict';

if ("production" === 'production') {
  module.exports = require('./cjs/react.production.min.js');
} else {
  module.exports = require('./cjs/react.development.js');
}
},{"./cjs/react.production.min.js":"Xy56"}],"VqLu":[function(require,module,exports) {
/** @license React v0.20.1
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
'use strict';var f,g,h,k;if("object"===typeof performance&&"function"===typeof performance.now){var l=performance;exports.unstable_now=function(){return l.now()}}else{var p=Date,q=p.now();exports.unstable_now=function(){return p.now()-q}}
if("undefined"===typeof window||"function"!==typeof MessageChannel){var t=null,u=null,w=function(){if(null!==t)try{var a=exports.unstable_now();t(!0,a);t=null}catch(b){throw setTimeout(w,0),b;}};f=function(a){null!==t?setTimeout(f,0,a):(t=a,setTimeout(w,0))};g=function(a,b){u=setTimeout(a,b)};h=function(){clearTimeout(u)};exports.unstable_shouldYield=function(){return!1};k=exports.unstable_forceFrameRate=function(){}}else{var x=window.setTimeout,y=window.clearTimeout;if("undefined"!==typeof console){var z=
window.cancelAnimationFrame;"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills");"function"!==typeof z&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills")}var A=!1,B=null,C=-1,D=5,E=0;exports.unstable_shouldYield=function(){return exports.unstable_now()>=
E};k=function(){};exports.unstable_forceFrameRate=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):D=0<a?Math.floor(1E3/a):5};var F=new MessageChannel,G=F.port2;F.port1.onmessage=function(){if(null!==B){var a=exports.unstable_now();E=a+D;try{B(!0,a)?G.postMessage(null):(A=!1,B=null)}catch(b){throw G.postMessage(null),b;}}else A=!1};f=function(a){B=a;A||(A=!0,G.postMessage(null))};g=function(a,b){C=
x(function(){a(exports.unstable_now())},b)};h=function(){y(C);C=-1}}function H(a,b){var c=a.length;a.push(b);a:for(;;){var d=c-1>>>1,e=a[d];if(void 0!==e&&0<I(e,b))a[d]=b,a[c]=e,c=d;else break a}}function J(a){a=a[0];return void 0===a?null:a}
function K(a){var b=a[0];if(void 0!==b){var c=a.pop();if(c!==b){a[0]=c;a:for(var d=0,e=a.length;d<e;){var m=2*(d+1)-1,n=a[m],v=m+1,r=a[v];if(void 0!==n&&0>I(n,c))void 0!==r&&0>I(r,n)?(a[d]=r,a[v]=c,d=v):(a[d]=n,a[m]=c,d=m);else if(void 0!==r&&0>I(r,c))a[d]=r,a[v]=c,d=v;else break a}}return b}return null}function I(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}var L=[],M=[],N=1,O=null,P=3,Q=!1,R=!1,S=!1;
function T(a){for(var b=J(M);null!==b;){if(null===b.callback)K(M);else if(b.startTime<=a)K(M),b.sortIndex=b.expirationTime,H(L,b);else break;b=J(M)}}function U(a){S=!1;T(a);if(!R)if(null!==J(L))R=!0,f(V);else{var b=J(M);null!==b&&g(U,b.startTime-a)}}
function V(a,b){R=!1;S&&(S=!1,h());Q=!0;var c=P;try{T(b);for(O=J(L);null!==O&&(!(O.expirationTime>b)||a&&!exports.unstable_shouldYield());){var d=O.callback;if("function"===typeof d){O.callback=null;P=O.priorityLevel;var e=d(O.expirationTime<=b);b=exports.unstable_now();"function"===typeof e?O.callback=e:O===J(L)&&K(L);T(b)}else K(L);O=J(L)}if(null!==O)var m=!0;else{var n=J(M);null!==n&&g(U,n.startTime-b);m=!1}return m}finally{O=null,P=c,Q=!1}}var W=k;exports.unstable_IdlePriority=5;
exports.unstable_ImmediatePriority=1;exports.unstable_LowPriority=4;exports.unstable_NormalPriority=3;exports.unstable_Profiling=null;exports.unstable_UserBlockingPriority=2;exports.unstable_cancelCallback=function(a){a.callback=null};exports.unstable_continueExecution=function(){R||Q||(R=!0,f(V))};exports.unstable_getCurrentPriorityLevel=function(){return P};exports.unstable_getFirstCallbackNode=function(){return J(L)};
exports.unstable_next=function(a){switch(P){case 1:case 2:case 3:var b=3;break;default:b=P}var c=P;P=b;try{return a()}finally{P=c}};exports.unstable_pauseExecution=function(){};exports.unstable_requestPaint=W;exports.unstable_runWithPriority=function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=P;P=a;try{return b()}finally{P=c}};
exports.unstable_scheduleCallback=function(a,b,c){var d=exports.unstable_now();"object"===typeof c&&null!==c?(c=c.delay,c="number"===typeof c&&0<c?d+c:d):c=d;switch(a){case 1:var e=-1;break;case 2:e=250;break;case 5:e=1073741823;break;case 4:e=1E4;break;default:e=5E3}e=c+e;a={id:N++,callback:b,priorityLevel:a,startTime:c,expirationTime:e,sortIndex:-1};c>d?(a.sortIndex=c,H(M,a),null===J(L)&&a===J(M)&&(S?h():S=!0,g(U,c-d))):(a.sortIndex=e,H(L,a),R||Q||(R=!0,f(V)));return a};
exports.unstable_wrapCallback=function(a){var b=P;return function(){var c=P;P=b;try{return a.apply(this,arguments)}finally{P=c}}};

},{}],"dH6z":[function(require,module,exports) {
'use strict';

if ("production" === 'production') {
  module.exports = require('./cjs/scheduler.production.min.js');
} else {
  module.exports = require('./cjs/scheduler.development.js');
}
},{"./cjs/scheduler.production.min.js":"VqLu"}],"MtQn":[function(require,module,exports) {
/** @license React v17.0.1
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/
'use strict';var aa=require("react"),m=require("object-assign"),r=require("scheduler");function y(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return"Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}if(!aa)throw Error(y(227));var ba=new Set,ca={};function da(a,b){ea(a,b);ea(a+"Capture",b)}
function ea(a,b){ca[a]=b;for(a=0;a<b.length;a++)ba.add(b[a])}
var fa=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),ha=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,ia=Object.prototype.hasOwnProperty,
ja={},ka={};function la(a){if(ia.call(ka,a))return!0;if(ia.call(ja,a))return!1;if(ha.test(a))return ka[a]=!0;ja[a]=!0;return!1}function ma(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case "function":case "symbol":return!0;case "boolean":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return"data-"!==a&&"aria-"!==a;default:return!1}}
function na(a,b,c,d){if(null===b||"undefined"===typeof b||ma(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function B(a,b,c,d,e,f,g){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f;this.removeEmptyString=g}var D={};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){D[a]=new B(a,0,!1,a,null,!1,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];D[b]=new B(b,1,!1,a[1],null,!1,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(a){D[a]=new B(a,2,!1,a.toLowerCase(),null,!1,!1)});
["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){D[a]=new B(a,2,!1,a,null,!1,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){D[a]=new B(a,3,!1,a.toLowerCase(),null,!1,!1)});
["checked","multiple","muted","selected"].forEach(function(a){D[a]=new B(a,3,!0,a,null,!1,!1)});["capture","download"].forEach(function(a){D[a]=new B(a,4,!1,a,null,!1,!1)});["cols","rows","size","span"].forEach(function(a){D[a]=new B(a,6,!1,a,null,!1,!1)});["rowSpan","start"].forEach(function(a){D[a]=new B(a,5,!1,a.toLowerCase(),null,!1,!1)});var oa=/[\-:]([a-z])/g;function pa(a){return a[1].toUpperCase()}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=a.replace(oa,
pa);D[b]=new B(b,1,!1,a,null,!1,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(oa,pa);D[b]=new B(b,1,!1,a,"http://www.w3.org/1999/xlink",!1,!1)});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(oa,pa);D[b]=new B(b,1,!1,a,"http://www.w3.org/XML/1998/namespace",!1,!1)});["tabIndex","crossOrigin"].forEach(function(a){D[a]=new B(a,1,!1,a.toLowerCase(),null,!1,!1)});
D.xlinkHref=new B("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1);["src","href","action","formAction"].forEach(function(a){D[a]=new B(a,1,!1,a.toLowerCase(),null,!0,!0)});
function qa(a,b,c,d){var e=D.hasOwnProperty(b)?D[b]:null;var f=null!==e?0===e.type:d?!1:!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1]?!1:!0;f||(na(b,c,e,d)&&(c=null),d||null===e?la(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:"":c:(b=e.attributeName,d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c))))}
var ra=aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,sa=60103,ta=60106,ua=60107,wa=60108,xa=60114,ya=60109,za=60110,Aa=60112,Ba=60113,Ca=60120,Da=60115,Ea=60116,Fa=60121,Ga=60128,Ha=60129,Ia=60130,Ja=60131;
if("function"===typeof Symbol&&Symbol.for){var E=Symbol.for;sa=E("react.element");ta=E("react.portal");ua=E("react.fragment");wa=E("react.strict_mode");xa=E("react.profiler");ya=E("react.provider");za=E("react.context");Aa=E("react.forward_ref");Ba=E("react.suspense");Ca=E("react.suspense_list");Da=E("react.memo");Ea=E("react.lazy");Fa=E("react.block");E("react.scope");Ga=E("react.opaque.id");Ha=E("react.debug_trace_mode");Ia=E("react.offscreen");Ja=E("react.legacy_hidden")}
var Ka="function"===typeof Symbol&&Symbol.iterator;function La(a){if(null===a||"object"!==typeof a)return null;a=Ka&&a[Ka]||a["@@iterator"];return"function"===typeof a?a:null}var Ma;function Na(a){if(void 0===Ma)try{throw Error();}catch(c){var b=c.stack.trim().match(/\n( *(at )?)/);Ma=b&&b[1]||""}return"\n"+Ma+a}var Oa=!1;
function Pa(a,b){if(!a||Oa)return"";Oa=!0;var c=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(b)if(b=function(){throw Error();},Object.defineProperty(b.prototype,"props",{set:function(){throw Error();}}),"object"===typeof Reflect&&Reflect.construct){try{Reflect.construct(b,[])}catch(k){var d=k}Reflect.construct(a,[],b)}else{try{b.call()}catch(k){d=k}a.call(b.prototype)}else{try{throw Error();}catch(k){d=k}a()}}catch(k){if(k&&d&&"string"===typeof k.stack){for(var e=k.stack.split("\n"),
f=d.stack.split("\n"),g=e.length-1,h=f.length-1;1<=g&&0<=h&&e[g]!==f[h];)h--;for(;1<=g&&0<=h;g--,h--)if(e[g]!==f[h]){if(1!==g||1!==h){do if(g--,h--,0>h||e[g]!==f[h])return"\n"+e[g].replace(" at new "," at ");while(1<=g&&0<=h)}break}}}finally{Oa=!1,Error.prepareStackTrace=c}return(a=a?a.displayName||a.name:"")?Na(a):""}
function Qa(a){switch(a.tag){case 5:return Na(a.type);case 16:return Na("Lazy");case 13:return Na("Suspense");case 19:return Na("SuspenseList");case 0:case 2:case 15:return a=Pa(a.type,!1),a;case 11:return a=Pa(a.type.render,!1),a;case 22:return a=Pa(a.type._render,!1),a;case 1:return a=Pa(a.type,!0),a;default:return""}}
function Ra(a){if(null==a)return null;if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case ua:return"Fragment";case ta:return"Portal";case xa:return"Profiler";case wa:return"StrictMode";case Ba:return"Suspense";case Ca:return"SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case za:return(a.displayName||"Context")+".Consumer";case ya:return(a._context.displayName||"Context")+".Provider";case Aa:var b=a.render;b=b.displayName||b.name||"";
return a.displayName||(""!==b?"ForwardRef("+b+")":"ForwardRef");case Da:return Ra(a.type);case Fa:return Ra(a._render);case Ea:b=a._payload;a=a._init;try{return Ra(a(b))}catch(c){}}return null}function Sa(a){switch(typeof a){case "boolean":case "number":case "object":case "string":case "undefined":return a;default:return""}}function Ta(a){var b=a.type;return(a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}
function Ua(a){var b=Ta(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a)}});Object.defineProperty(a,b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=""+a},stopTracking:function(){a._valueTracker=
null;delete a[b]}}}}function Va(a){a._valueTracker||(a._valueTracker=Ua(a))}function Wa(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d="";a&&(d=Ta(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Xa(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}
function Ya(a,b){var c=b.checked;return m({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=c?c:a._wrapperState.initialChecked})}function Za(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=Sa(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value}}function $a(a,b){b=b.checked;null!=b&&qa(a,"checked",b,!1)}
function ab(a,b){$a(a,b);var c=Sa(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c}else a.value!==""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?bb(a,b.type,c):b.hasOwnProperty("defaultValue")&&bb(a,b.type,Sa(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}
function cb(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=b);a.defaultValue=b}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c)}
function bb(a,b,c){if("number"!==b||Xa(a.ownerDocument)!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c)}function db(a){var b="";aa.Children.forEach(a,function(a){null!=a&&(b+=a)});return b}function eb(a,b){a=m({children:void 0},b);if(b=db(b.children))a.children=b;return a}
function fb(a,b,c,d){a=a.options;if(b){b={};for(var e=0;e<c.length;e++)b["$"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=""+Sa(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}
function gb(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(y(91));return m({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}function hb(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(y(92));if(Array.isArray(c)){if(!(1>=c.length))throw Error(y(93));c=c[0]}b=c}null==b&&(b="");c=b}a._wrapperState={initialValue:Sa(c)}}
function ib(a,b){var c=Sa(b.value),d=Sa(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d)}function jb(a){var b=a.textContent;b===a._wrapperState.initialValue&&""!==b&&null!==b&&(a.value=b)}var kb={html:"http://www.w3.org/1999/xhtml",mathml:"http://www.w3.org/1998/Math/MathML",svg:"http://www.w3.org/2000/svg"};
function lb(a){switch(a){case "svg":return"http://www.w3.org/2000/svg";case "math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function mb(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?lb(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}
var nb,ob=function(a){return"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if(a.namespaceURI!==kb.svg||"innerHTML"in a)a.innerHTML=b;else{nb=nb||document.createElement("div");nb.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=nb.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}});
function pb(a,b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b}
var qb={animationIterationCount:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,
floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},rb=["Webkit","ms","Moz","O"];Object.keys(qb).forEach(function(a){rb.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);qb[b]=qb[a]})});function sb(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||qb.hasOwnProperty(a)&&qb[a]?(""+b).trim():b+"px"}
function tb(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=sb(c,b[c],d);"float"===c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e}}var ub=m({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});
function vb(a,b){if(b){if(ub[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(y(137,a));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(y(60));if(!("object"===typeof b.dangerouslySetInnerHTML&&"__html"in b.dangerouslySetInnerHTML))throw Error(y(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(y(62));}}
function wb(a,b){if(-1===a.indexOf("-"))return"string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return!1;default:return!0}}function xb(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:a}var yb=null,zb=null,Ab=null;
function Bb(a){if(a=Cb(a)){if("function"!==typeof yb)throw Error(y(280));var b=a.stateNode;b&&(b=Db(b),yb(a.stateNode,a.type,b))}}function Eb(a){zb?Ab?Ab.push(a):Ab=[a]:zb=a}function Fb(){if(zb){var a=zb,b=Ab;Ab=zb=null;Bb(a);if(b)for(a=0;a<b.length;a++)Bb(b[a])}}function Gb(a,b){return a(b)}function Hb(a,b,c,d,e){return a(b,c,d,e)}function Ib(){}var Jb=Gb,Kb=!1,Lb=!1;function Mb(){if(null!==zb||null!==Ab)Ib(),Fb()}
function Nb(a,b,c){if(Lb)return a(b,c);Lb=!0;try{return Jb(a,b,c)}finally{Lb=!1,Mb()}}
function Ob(a,b){var c=a.stateNode;if(null===c)return null;var d=Db(c);if(null===d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&"function"!==
typeof c)throw Error(y(231,b,typeof c));return c}var Pb=!1;if(fa)try{var Qb={};Object.defineProperty(Qb,"passive",{get:function(){Pb=!0}});window.addEventListener("test",Qb,Qb);window.removeEventListener("test",Qb,Qb)}catch(a){Pb=!1}function Rb(a,b,c,d,e,f,g,h,k){var l=Array.prototype.slice.call(arguments,3);try{b.apply(c,l)}catch(n){this.onError(n)}}var Sb=!1,Tb=null,Ub=!1,Vb=null,Wb={onError:function(a){Sb=!0;Tb=a}};function Xb(a,b,c,d,e,f,g,h,k){Sb=!1;Tb=null;Rb.apply(Wb,arguments)}
function Yb(a,b,c,d,e,f,g,h,k){Xb.apply(this,arguments);if(Sb){if(Sb){var l=Tb;Sb=!1;Tb=null}else throw Error(y(198));Ub||(Ub=!0,Vb=l)}}function Zb(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.flags&1026)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function $b(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function ac(a){if(Zb(a)!==a)throw Error(y(188));}
function bc(a){var b=a.alternate;if(!b){b=Zb(a);if(null===b)throw Error(y(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return ac(e),a;if(f===d)return ac(e),b;f=f.sibling}throw Error(y(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=f.child;h;){if(h===
c){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(y(189));}}if(c.alternate!==d)throw Error(y(190));}if(3!==c.tag)throw Error(y(188));return c.stateNode.current===c?a:b}function cc(a){a=bc(a);if(!a)return null;for(var b=a;;){if(5===b.tag||6===b.tag)return b;if(b.child)b.child.return=b,b=b.child;else{if(b===a)break;for(;!b.sibling;){if(!b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}}return null}
function dc(a,b){for(var c=a.alternate;null!==b;){if(b===a||b===c)return!0;b=b.return}return!1}var ec,fc,gc,hc,ic=!1,jc=[],kc=null,lc=null,mc=null,nc=new Map,oc=new Map,pc=[],qc="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function rc(a,b,c,d,e){return{blockedOn:a,domEventName:b,eventSystemFlags:c|16,nativeEvent:e,targetContainers:[d]}}function sc(a,b){switch(a){case "focusin":case "focusout":kc=null;break;case "dragenter":case "dragleave":lc=null;break;case "mouseover":case "mouseout":mc=null;break;case "pointerover":case "pointerout":nc.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":oc.delete(b.pointerId)}}
function tc(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a=rc(b,c,d,e,f),null!==b&&(b=Cb(b),null!==b&&fc(b)),a;a.eventSystemFlags|=d;b=a.targetContainers;null!==e&&-1===b.indexOf(e)&&b.push(e);return a}
function uc(a,b,c,d,e){switch(b){case "focusin":return kc=tc(kc,a,b,c,d,e),!0;case "dragenter":return lc=tc(lc,a,b,c,d,e),!0;case "mouseover":return mc=tc(mc,a,b,c,d,e),!0;case "pointerover":var f=e.pointerId;nc.set(f,tc(nc.get(f)||null,a,b,c,d,e));return!0;case "gotpointercapture":return f=e.pointerId,oc.set(f,tc(oc.get(f)||null,a,b,c,d,e)),!0}return!1}
function vc(a){var b=wc(a.target);if(null!==b){var c=Zb(b);if(null!==c)if(b=c.tag,13===b){if(b=$b(c),null!==b){a.blockedOn=b;hc(a.lanePriority,function(){r.unstable_runWithPriority(a.priority,function(){gc(c)})});return}}else if(3===b&&c.stateNode.hydrate){a.blockedOn=3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}
function xc(a){if(null!==a.blockedOn)return!1;for(var b=a.targetContainers;0<b.length;){var c=yc(a.domEventName,a.eventSystemFlags,b[0],a.nativeEvent);if(null!==c)return b=Cb(c),null!==b&&fc(b),a.blockedOn=c,!1;b.shift()}return!0}function zc(a,b,c){xc(a)&&c.delete(b)}
function Ac(){for(ic=!1;0<jc.length;){var a=jc[0];if(null!==a.blockedOn){a=Cb(a.blockedOn);null!==a&&ec(a);break}for(var b=a.targetContainers;0<b.length;){var c=yc(a.domEventName,a.eventSystemFlags,b[0],a.nativeEvent);if(null!==c){a.blockedOn=c;break}b.shift()}null===a.blockedOn&&jc.shift()}null!==kc&&xc(kc)&&(kc=null);null!==lc&&xc(lc)&&(lc=null);null!==mc&&xc(mc)&&(mc=null);nc.forEach(zc);oc.forEach(zc)}
function Bc(a,b){a.blockedOn===b&&(a.blockedOn=null,ic||(ic=!0,r.unstable_scheduleCallback(r.unstable_NormalPriority,Ac)))}
function Cc(a){function b(b){return Bc(b,a)}if(0<jc.length){Bc(jc[0],a);for(var c=1;c<jc.length;c++){var d=jc[c];d.blockedOn===a&&(d.blockedOn=null)}}null!==kc&&Bc(kc,a);null!==lc&&Bc(lc,a);null!==mc&&Bc(mc,a);nc.forEach(b);oc.forEach(b);for(c=0;c<pc.length;c++)d=pc[c],d.blockedOn===a&&(d.blockedOn=null);for(;0<pc.length&&(c=pc[0],null===c.blockedOn);)vc(c),null===c.blockedOn&&pc.shift()}
function Dc(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}var Ec={animationend:Dc("Animation","AnimationEnd"),animationiteration:Dc("Animation","AnimationIteration"),animationstart:Dc("Animation","AnimationStart"),transitionend:Dc("Transition","TransitionEnd")},Fc={},Gc={};
fa&&(Gc=document.createElement("div").style,"AnimationEvent"in window||(delete Ec.animationend.animation,delete Ec.animationiteration.animation,delete Ec.animationstart.animation),"TransitionEvent"in window||delete Ec.transitionend.transition);function Hc(a){if(Fc[a])return Fc[a];if(!Ec[a])return a;var b=Ec[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Gc)return Fc[a]=b[c];return a}
var Ic=Hc("animationend"),Jc=Hc("animationiteration"),Kc=Hc("animationstart"),Lc=Hc("transitionend"),Mc=new Map,Nc=new Map,Oc=["abort","abort",Ic,"animationEnd",Jc,"animationIteration",Kc,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata","loadstart","loadStart",
"lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",Lc,"transitionEnd","waiting","waiting"];function Pc(a,b){for(var c=0;c<a.length;c+=2){var d=a[c],e=a[c+1];e="on"+(e[0].toUpperCase()+e.slice(1));Nc.set(d,b);Mc.set(d,e);da(e,[d])}}var Qc=r.unstable_now;Qc();var F=8;
function Rc(a){if(0!==(1&a))return F=15,1;if(0!==(2&a))return F=14,2;if(0!==(4&a))return F=13,4;var b=24&a;if(0!==b)return F=12,b;if(0!==(a&32))return F=11,32;b=192&a;if(0!==b)return F=10,b;if(0!==(a&256))return F=9,256;b=3584&a;if(0!==b)return F=8,b;if(0!==(a&4096))return F=7,4096;b=4186112&a;if(0!==b)return F=6,b;b=62914560&a;if(0!==b)return F=5,b;if(a&67108864)return F=4,67108864;if(0!==(a&134217728))return F=3,134217728;b=805306368&a;if(0!==b)return F=2,b;if(0!==(1073741824&a))return F=1,1073741824;
F=8;return a}function Sc(a){switch(a){case 99:return 15;case 98:return 10;case 97:case 96:return 8;case 95:return 2;default:return 0}}function Tc(a){switch(a){case 15:case 14:return 99;case 13:case 12:case 11:case 10:return 98;case 9:case 8:case 7:case 6:case 4:case 5:return 97;case 3:case 2:case 1:return 95;case 0:return 90;default:throw Error(y(358,a));}}
function Uc(a,b){var c=a.pendingLanes;if(0===c)return F=0;var d=0,e=0,f=a.expiredLanes,g=a.suspendedLanes,h=a.pingedLanes;if(0!==f)d=f,e=F=15;else if(f=c&134217727,0!==f){var k=f&~g;0!==k?(d=Rc(k),e=F):(h&=f,0!==h&&(d=Rc(h),e=F))}else f=c&~g,0!==f?(d=Rc(f),e=F):0!==h&&(d=Rc(h),e=F);if(0===d)return 0;d=31-Vc(d);d=c&((0>d?0:1<<d)<<1)-1;if(0!==b&&b!==d&&0===(b&g)){Rc(b);if(e<=F)return b;F=e}b=a.entangledLanes;if(0!==b)for(a=a.entanglements,b&=d;0<b;)c=31-Vc(b),e=1<<c,d|=a[c],b&=~e;return d}
function Wc(a){a=a.pendingLanes&-1073741825;return 0!==a?a:a&1073741824?1073741824:0}function Xc(a,b){switch(a){case 15:return 1;case 14:return 2;case 12:return a=Yc(24&~b),0===a?Xc(10,b):a;case 10:return a=Yc(192&~b),0===a?Xc(8,b):a;case 8:return a=Yc(3584&~b),0===a&&(a=Yc(4186112&~b),0===a&&(a=512)),a;case 2:return b=Yc(805306368&~b),0===b&&(b=268435456),b}throw Error(y(358,a));}function Yc(a){return a&-a}function Zc(a){for(var b=[],c=0;31>c;c++)b.push(a);return b}
function $c(a,b,c){a.pendingLanes|=b;var d=b-1;a.suspendedLanes&=d;a.pingedLanes&=d;a=a.eventTimes;b=31-Vc(b);a[b]=c}var Vc=Math.clz32?Math.clz32:ad,bd=Math.log,cd=Math.LN2;function ad(a){return 0===a?32:31-(bd(a)/cd|0)|0}var dd=r.unstable_UserBlockingPriority,ed=r.unstable_runWithPriority,fd=!0;function gd(a,b,c,d){Kb||Ib();var e=hd,f=Kb;Kb=!0;try{Hb(e,a,b,c,d)}finally{(Kb=f)||Mb()}}function id(a,b,c,d){ed(dd,hd.bind(null,a,b,c,d))}
function hd(a,b,c,d){if(fd){var e;if((e=0===(b&4))&&0<jc.length&&-1<qc.indexOf(a))a=rc(null,a,b,c,d),jc.push(a);else{var f=yc(a,b,c,d);if(null===f)e&&sc(a,d);else{if(e){if(-1<qc.indexOf(a)){a=rc(f,a,b,c,d);jc.push(a);return}if(uc(f,a,b,c,d))return;sc(a,d)}jd(a,b,d,null,c)}}}}
function yc(a,b,c,d){var e=xb(d);e=wc(e);if(null!==e){var f=Zb(e);if(null===f)e=null;else{var g=f.tag;if(13===g){e=$b(f);if(null!==e)return e;e=null}else if(3===g){if(f.stateNode.hydrate)return 3===f.tag?f.stateNode.containerInfo:null;e=null}else f!==e&&(e=null)}}jd(a,b,d,e,c);return null}var kd=null,ld=null,md=null;
function nd(){if(md)return md;var a,b=ld,c=b.length,d,e="value"in kd?kd.value:kd.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return md=e.slice(a,1<d?1-d:void 0)}function od(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function pd(){return!0}function qd(){return!1}
function rd(a){function b(b,d,e,f,g){this._reactName=b;this._targetInst=e;this.type=d;this.nativeEvent=f;this.target=g;this.currentTarget=null;for(var c in a)a.hasOwnProperty(c)&&(b=a[c],this[c]=b?b(f):f[c]);this.isDefaultPrevented=(null!=f.defaultPrevented?f.defaultPrevented:!1===f.returnValue)?pd:qd;this.isPropagationStopped=qd;return this}m(b.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&
(a.returnValue=!1),this.isDefaultPrevented=pd)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=pd)},persist:function(){},isPersistent:pd});return b}
var sd={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(a){return a.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},td=rd(sd),ud=m({},sd,{view:0,detail:0}),vd=rd(ud),wd,xd,yd,Ad=m({},ud,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:zd,button:0,buttons:0,relatedTarget:function(a){return void 0===a.relatedTarget?a.fromElement===a.srcElement?a.toElement:a.fromElement:a.relatedTarget},movementX:function(a){if("movementX"in
a)return a.movementX;a!==yd&&(yd&&"mousemove"===a.type?(wd=a.screenX-yd.screenX,xd=a.screenY-yd.screenY):xd=wd=0,yd=a);return wd},movementY:function(a){return"movementY"in a?a.movementY:xd}}),Bd=rd(Ad),Cd=m({},Ad,{dataTransfer:0}),Dd=rd(Cd),Ed=m({},ud,{relatedTarget:0}),Fd=rd(Ed),Gd=m({},sd,{animationName:0,elapsedTime:0,pseudoElement:0}),Hd=rd(Gd),Id=m({},sd,{clipboardData:function(a){return"clipboardData"in a?a.clipboardData:window.clipboardData}}),Jd=rd(Id),Kd=m({},sd,{data:0}),Ld=rd(Kd),Md={Esc:"Escape",
Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},Nd={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",
119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},Od={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function Pd(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Od[a])?!!b[a]:!1}function zd(){return Pd}
var Qd=m({},ud,{key:function(a){if(a.key){var b=Md[a.key]||a.key;if("Unidentified"!==b)return b}return"keypress"===a.type?(a=od(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?Nd[a.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:zd,charCode:function(a){return"keypress"===a.type?od(a):0},keyCode:function(a){return"keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return"keypress"===
a.type?od(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),Rd=rd(Qd),Sd=m({},Ad,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),Td=rd(Sd),Ud=m({},ud,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:zd}),Vd=rd(Ud),Wd=m({},sd,{propertyName:0,elapsedTime:0,pseudoElement:0}),Xd=rd(Wd),Yd=m({},Ad,{deltaX:function(a){return"deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},
deltaY:function(a){return"deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?-a.wheelDelta:0},deltaZ:0,deltaMode:0}),Zd=rd(Yd),$d=[9,13,27,32],ae=fa&&"CompositionEvent"in window,be=null;fa&&"documentMode"in document&&(be=document.documentMode);var ce=fa&&"TextEvent"in window&&!be,de=fa&&(!ae||be&&8<be&&11>=be),ee=String.fromCharCode(32),fe=!1;
function ge(a,b){switch(a){case "keyup":return-1!==$d.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "focusout":return!0;default:return!1}}function he(a){a=a.detail;return"object"===typeof a&&"data"in a?a.data:null}var ie=!1;function je(a,b){switch(a){case "compositionend":return he(b);case "keypress":if(32!==b.which)return null;fe=!0;return ee;case "textInput":return a=b.data,a===ee&&fe?null:a;default:return null}}
function ke(a,b){if(ie)return"compositionend"===a||!ae&&ge(a,b)?(a=nd(),md=ld=kd=null,ie=!1,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;case "compositionend":return de&&"ko"!==b.locale?null:b.data;default:return null}}
var le={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function me(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return"input"===b?!!le[a.type]:"textarea"===b?!0:!1}function ne(a,b,c,d){Eb(d);b=oe(b,"onChange");0<b.length&&(c=new td("onChange","change",null,c,d),a.push({event:c,listeners:b}))}var pe=null,qe=null;function re(a){se(a,0)}function te(a){var b=ue(a);if(Wa(b))return a}
function ve(a,b){if("change"===a)return b}var we=!1;if(fa){var xe;if(fa){var ye="oninput"in document;if(!ye){var ze=document.createElement("div");ze.setAttribute("oninput","return;");ye="function"===typeof ze.oninput}xe=ye}else xe=!1;we=xe&&(!document.documentMode||9<document.documentMode)}function Ae(){pe&&(pe.detachEvent("onpropertychange",Be),qe=pe=null)}function Be(a){if("value"===a.propertyName&&te(qe)){var b=[];ne(b,qe,a,xb(a));a=re;if(Kb)a(b);else{Kb=!0;try{Gb(a,b)}finally{Kb=!1,Mb()}}}}
function Ce(a,b,c){"focusin"===a?(Ae(),pe=b,qe=c,pe.attachEvent("onpropertychange",Be)):"focusout"===a&&Ae()}function De(a){if("selectionchange"===a||"keyup"===a||"keydown"===a)return te(qe)}function Ee(a,b){if("click"===a)return te(b)}function Fe(a,b){if("input"===a||"change"===a)return te(b)}function Ge(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}var He="function"===typeof Object.is?Object.is:Ge,Ie=Object.prototype.hasOwnProperty;
function Je(a,b){if(He(a,b))return!0;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++)if(!Ie.call(b,c[d])||!He(a[c[d]],b[c[d]]))return!1;return!0}function Ke(a){for(;a&&a.firstChild;)a=a.firstChild;return a}
function Le(a,b){var c=Ke(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=Ke(c)}}function Me(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?Me(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}
function Ne(){for(var a=window,b=Xa();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Xa(a.document)}return b}function Oe(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}
var Pe=fa&&"documentMode"in document&&11>=document.documentMode,Qe=null,Re=null,Se=null,Te=!1;
function Ue(a,b,c){var d=c.window===c?c.document:9===c.nodeType?c:c.ownerDocument;Te||null==Qe||Qe!==Xa(d)||(d=Qe,"selectionStart"in d&&Oe(d)?d={start:d.selectionStart,end:d.selectionEnd}:(d=(d.ownerDocument&&d.ownerDocument.defaultView||window).getSelection(),d={anchorNode:d.anchorNode,anchorOffset:d.anchorOffset,focusNode:d.focusNode,focusOffset:d.focusOffset}),Se&&Je(Se,d)||(Se=d,d=oe(Re,"onSelect"),0<d.length&&(b=new td("onSelect","select",null,b,c),a.push({event:b,listeners:d}),b.target=Qe)))}
Pc("cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focusin focus focusout blur input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),
0);Pc("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1);Pc(Oc,2);for(var Ve="change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),We=0;We<Ve.length;We++)Nc.set(Ve[We],0);ea("onMouseEnter",["mouseout","mouseover"]);
ea("onMouseLeave",["mouseout","mouseover"]);ea("onPointerEnter",["pointerout","pointerover"]);ea("onPointerLeave",["pointerout","pointerover"]);da("onChange","change click focusin focusout input keydown keyup selectionchange".split(" "));da("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));da("onBeforeInput",["compositionend","keypress","textInput","paste"]);da("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" "));
da("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" "));da("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var Xe="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),Ye=new Set("cancel close invalid load scroll toggle".split(" ").concat(Xe));
function Ze(a,b,c){var d=a.type||"unknown-event";a.currentTarget=c;Yb(d,b,void 0,a);a.currentTarget=null}
function se(a,b){b=0!==(b&4);for(var c=0;c<a.length;c++){var d=a[c],e=d.event;d=d.listeners;a:{var f=void 0;if(b)for(var g=d.length-1;0<=g;g--){var h=d[g],k=h.instance,l=h.currentTarget;h=h.listener;if(k!==f&&e.isPropagationStopped())break a;Ze(e,h,l);f=k}else for(g=0;g<d.length;g++){h=d[g];k=h.instance;l=h.currentTarget;h=h.listener;if(k!==f&&e.isPropagationStopped())break a;Ze(e,h,l);f=k}}}if(Ub)throw a=Vb,Ub=!1,Vb=null,a;}
function G(a,b){var c=$e(b),d=a+"__bubble";c.has(d)||(af(b,a,2,!1),c.add(d))}var bf="_reactListening"+Math.random().toString(36).slice(2);function cf(a){a[bf]||(a[bf]=!0,ba.forEach(function(b){Ye.has(b)||df(b,!1,a,null);df(b,!0,a,null)}))}
function df(a,b,c,d){var e=4<arguments.length&&void 0!==arguments[4]?arguments[4]:0,f=c;"selectionchange"===a&&9!==c.nodeType&&(f=c.ownerDocument);if(null!==d&&!b&&Ye.has(a)){if("scroll"!==a)return;e|=2;f=d}var g=$e(f),h=a+"__"+(b?"capture":"bubble");g.has(h)||(b&&(e|=4),af(f,a,e,b),g.add(h))}
function af(a,b,c,d){var e=Nc.get(b);switch(void 0===e?2:e){case 0:e=gd;break;case 1:e=id;break;default:e=hd}c=e.bind(null,b,c,a);e=void 0;!Pb||"touchstart"!==b&&"touchmove"!==b&&"wheel"!==b||(e=!0);d?void 0!==e?a.addEventListener(b,c,{capture:!0,passive:e}):a.addEventListener(b,c,!0):void 0!==e?a.addEventListener(b,c,{passive:e}):a.addEventListener(b,c,!1)}
function jd(a,b,c,d,e){var f=d;if(0===(b&1)&&0===(b&2)&&null!==d)a:for(;;){if(null===d)return;var g=d.tag;if(3===g||4===g){var h=d.stateNode.containerInfo;if(h===e||8===h.nodeType&&h.parentNode===e)break;if(4===g)for(g=d.return;null!==g;){var k=g.tag;if(3===k||4===k)if(k=g.stateNode.containerInfo,k===e||8===k.nodeType&&k.parentNode===e)return;g=g.return}for(;null!==h;){g=wc(h);if(null===g)return;k=g.tag;if(5===k||6===k){d=f=g;continue a}h=h.parentNode}}d=d.return}Nb(function(){var d=f,e=xb(c),g=[];
a:{var h=Mc.get(a);if(void 0!==h){var k=td,x=a;switch(a){case "keypress":if(0===od(c))break a;case "keydown":case "keyup":k=Rd;break;case "focusin":x="focus";k=Fd;break;case "focusout":x="blur";k=Fd;break;case "beforeblur":case "afterblur":k=Fd;break;case "click":if(2===c.button)break a;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":k=Bd;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":k=
Dd;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":k=Vd;break;case Ic:case Jc:case Kc:k=Hd;break;case Lc:k=Xd;break;case "scroll":k=vd;break;case "wheel":k=Zd;break;case "copy":case "cut":case "paste":k=Jd;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":k=Td}var w=0!==(b&4),z=!w&&"scroll"===a,u=w?null!==h?h+"Capture":null:h;w=[];for(var t=d,q;null!==
t;){q=t;var v=q.stateNode;5===q.tag&&null!==v&&(q=v,null!==u&&(v=Ob(t,u),null!=v&&w.push(ef(t,v,q))));if(z)break;t=t.return}0<w.length&&(h=new k(h,x,null,c,e),g.push({event:h,listeners:w}))}}if(0===(b&7)){a:{h="mouseover"===a||"pointerover"===a;k="mouseout"===a||"pointerout"===a;if(h&&0===(b&16)&&(x=c.relatedTarget||c.fromElement)&&(wc(x)||x[ff]))break a;if(k||h){h=e.window===e?e:(h=e.ownerDocument)?h.defaultView||h.parentWindow:window;if(k){if(x=c.relatedTarget||c.toElement,k=d,x=x?wc(x):null,null!==
x&&(z=Zb(x),x!==z||5!==x.tag&&6!==x.tag))x=null}else k=null,x=d;if(k!==x){w=Bd;v="onMouseLeave";u="onMouseEnter";t="mouse";if("pointerout"===a||"pointerover"===a)w=Td,v="onPointerLeave",u="onPointerEnter",t="pointer";z=null==k?h:ue(k);q=null==x?h:ue(x);h=new w(v,t+"leave",k,c,e);h.target=z;h.relatedTarget=q;v=null;wc(e)===d&&(w=new w(u,t+"enter",x,c,e),w.target=q,w.relatedTarget=z,v=w);z=v;if(k&&x)b:{w=k;u=x;t=0;for(q=w;q;q=gf(q))t++;q=0;for(v=u;v;v=gf(v))q++;for(;0<t-q;)w=gf(w),t--;for(;0<q-t;)u=
gf(u),q--;for(;t--;){if(w===u||null!==u&&w===u.alternate)break b;w=gf(w);u=gf(u)}w=null}else w=null;null!==k&&hf(g,h,k,w,!1);null!==x&&null!==z&&hf(g,z,x,w,!0)}}}a:{h=d?ue(d):window;k=h.nodeName&&h.nodeName.toLowerCase();if("select"===k||"input"===k&&"file"===h.type)var J=ve;else if(me(h))if(we)J=Fe;else{J=De;var K=Ce}else(k=h.nodeName)&&"input"===k.toLowerCase()&&("checkbox"===h.type||"radio"===h.type)&&(J=Ee);if(J&&(J=J(a,d))){ne(g,J,c,e);break a}K&&K(a,h,d);"focusout"===a&&(K=h._wrapperState)&&
K.controlled&&"number"===h.type&&bb(h,"number",h.value)}K=d?ue(d):window;switch(a){case "focusin":if(me(K)||"true"===K.contentEditable)Qe=K,Re=d,Se=null;break;case "focusout":Se=Re=Qe=null;break;case "mousedown":Te=!0;break;case "contextmenu":case "mouseup":case "dragend":Te=!1;Ue(g,c,e);break;case "selectionchange":if(Pe)break;case "keydown":case "keyup":Ue(g,c,e)}var Q;if(ae)b:{switch(a){case "compositionstart":var L="onCompositionStart";break b;case "compositionend":L="onCompositionEnd";break b;
case "compositionupdate":L="onCompositionUpdate";break b}L=void 0}else ie?ge(a,c)&&(L="onCompositionEnd"):"keydown"===a&&229===c.keyCode&&(L="onCompositionStart");L&&(de&&"ko"!==c.locale&&(ie||"onCompositionStart"!==L?"onCompositionEnd"===L&&ie&&(Q=nd()):(kd=e,ld="value"in kd?kd.value:kd.textContent,ie=!0)),K=oe(d,L),0<K.length&&(L=new Ld(L,a,null,c,e),g.push({event:L,listeners:K}),Q?L.data=Q:(Q=he(c),null!==Q&&(L.data=Q))));if(Q=ce?je(a,c):ke(a,c))d=oe(d,"onBeforeInput"),0<d.length&&(e=new Ld("onBeforeInput",
"beforeinput",null,c,e),g.push({event:e,listeners:d}),e.data=Q)}se(g,b)})}function ef(a,b,c){return{instance:a,listener:b,currentTarget:c}}function oe(a,b){for(var c=b+"Capture",d=[];null!==a;){var e=a,f=e.stateNode;5===e.tag&&null!==f&&(e=f,f=Ob(a,c),null!=f&&d.unshift(ef(a,f,e)),f=Ob(a,b),null!=f&&d.push(ef(a,f,e)));a=a.return}return d}function gf(a){if(null===a)return null;do a=a.return;while(a&&5!==a.tag);return a?a:null}
function hf(a,b,c,d,e){for(var f=b._reactName,g=[];null!==c&&c!==d;){var h=c,k=h.alternate,l=h.stateNode;if(null!==k&&k===d)break;5===h.tag&&null!==l&&(h=l,e?(k=Ob(c,f),null!=k&&g.unshift(ef(c,k,h))):e||(k=Ob(c,f),null!=k&&g.push(ef(c,k,h))));c=c.return}0!==g.length&&a.push({event:b,listeners:g})}function jf(){}var kf=null,lf=null;function mf(a,b){switch(a){case "button":case "input":case "select":case "textarea":return!!b.autoFocus}return!1}
function nf(a,b){return"textarea"===a||"option"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}var of="function"===typeof setTimeout?setTimeout:void 0,pf="function"===typeof clearTimeout?clearTimeout:void 0;function qf(a){1===a.nodeType?a.textContent="":9===a.nodeType&&(a=a.body,null!=a&&(a.textContent=""))}
function rf(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break}return a}function sf(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if("$"===c||"$!"===c||"$?"===c){if(0===b)return a;b--}else"/$"===c&&b++}a=a.previousSibling}return null}var tf=0;function uf(a){return{$$typeof:Ga,toString:a,valueOf:a}}var vf=Math.random().toString(36).slice(2),wf="__reactFiber$"+vf,xf="__reactProps$"+vf,ff="__reactContainer$"+vf,yf="__reactEvents$"+vf;
function wc(a){var b=a[wf];if(b)return b;for(var c=a.parentNode;c;){if(b=c[ff]||c[wf]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=sf(a);null!==a;){if(c=a[wf])return c;a=sf(a)}return b}a=c;c=a.parentNode}return null}function Cb(a){a=a[wf]||a[ff];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function ue(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(y(33));}function Db(a){return a[xf]||null}
function $e(a){var b=a[yf];void 0===b&&(b=a[yf]=new Set);return b}var zf=[],Af=-1;function Bf(a){return{current:a}}function H(a){0>Af||(a.current=zf[Af],zf[Af]=null,Af--)}function I(a,b){Af++;zf[Af]=a.current;a.current=b}var Cf={},M=Bf(Cf),N=Bf(!1),Df=Cf;
function Ef(a,b){var c=a.type.contextTypes;if(!c)return Cf;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}function Ff(a){a=a.childContextTypes;return null!==a&&void 0!==a}function Gf(){H(N);H(M)}function Hf(a,b,c){if(M.current!==Cf)throw Error(y(168));I(M,b);I(N,c)}
function If(a,b,c){var d=a.stateNode;a=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in a))throw Error(y(108,Ra(b)||"Unknown",e));return m({},c,d)}function Jf(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Cf;Df=M.current;I(M,a);I(N,N.current);return!0}function Kf(a,b,c){var d=a.stateNode;if(!d)throw Error(y(169));c?(a=If(a,b,Df),d.__reactInternalMemoizedMergedChildContext=a,H(N),H(M),I(M,a)):H(N);I(N,c)}
var Lf=null,Mf=null,Nf=r.unstable_runWithPriority,Of=r.unstable_scheduleCallback,Pf=r.unstable_cancelCallback,Qf=r.unstable_shouldYield,Rf=r.unstable_requestPaint,Sf=r.unstable_now,Tf=r.unstable_getCurrentPriorityLevel,Uf=r.unstable_ImmediatePriority,Vf=r.unstable_UserBlockingPriority,Wf=r.unstable_NormalPriority,Xf=r.unstable_LowPriority,Yf=r.unstable_IdlePriority,Zf={},$f=void 0!==Rf?Rf:function(){},ag=null,bg=null,cg=!1,dg=Sf(),O=1E4>dg?Sf:function(){return Sf()-dg};
function eg(){switch(Tf()){case Uf:return 99;case Vf:return 98;case Wf:return 97;case Xf:return 96;case Yf:return 95;default:throw Error(y(332));}}function fg(a){switch(a){case 99:return Uf;case 98:return Vf;case 97:return Wf;case 96:return Xf;case 95:return Yf;default:throw Error(y(332));}}function gg(a,b){a=fg(a);return Nf(a,b)}function hg(a,b,c){a=fg(a);return Of(a,b,c)}function ig(){if(null!==bg){var a=bg;bg=null;Pf(a)}jg()}
function jg(){if(!cg&&null!==ag){cg=!0;var a=0;try{var b=ag;gg(99,function(){for(;a<b.length;a++){var c=b[a];do c=c(!0);while(null!==c)}});ag=null}catch(c){throw null!==ag&&(ag=ag.slice(a+1)),Of(Uf,ig),c;}finally{cg=!1}}}var kg=ra.ReactCurrentBatchConfig;function lg(a,b){if(a&&a.defaultProps){b=m({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c]);return b}return b}var mg=Bf(null),ng=null,og=null,pg=null;function qg(){pg=og=ng=null}
function rg(a){var b=mg.current;H(mg);a.type._context._currentValue=b}function sg(a,b){for(;null!==a;){var c=a.alternate;if((a.childLanes&b)===b)if(null===c||(c.childLanes&b)===b)break;else c.childLanes|=b;else a.childLanes|=b,null!==c&&(c.childLanes|=b);a=a.return}}function tg(a,b){ng=a;pg=og=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(0!==(a.lanes&b)&&(ug=!0),a.firstContext=null)}
function vg(a,b){if(pg!==a&&!1!==b&&0!==b){if("number"!==typeof b||1073741823===b)pg=a,b=1073741823;b={context:a,observedBits:b,next:null};if(null===og){if(null===ng)throw Error(y(308));og=b;ng.dependencies={lanes:0,firstContext:b,responders:null}}else og=og.next=b}return a._currentValue}var wg=!1;function xg(a){a.updateQueue={baseState:a.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null},effects:null}}
function yg(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,firstBaseUpdate:a.firstBaseUpdate,lastBaseUpdate:a.lastBaseUpdate,shared:a.shared,effects:a.effects})}function zg(a,b){return{eventTime:a,lane:b,tag:0,payload:null,callback:null,next:null}}function Ag(a,b){a=a.updateQueue;if(null!==a){a=a.shared;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}}
function Bg(a,b){var c=a.updateQueue,d=a.alternate;if(null!==d&&(d=d.updateQueue,c===d)){var e=null,f=null;c=c.firstBaseUpdate;if(null!==c){do{var g={eventTime:c.eventTime,lane:c.lane,tag:c.tag,payload:c.payload,callback:c.callback,next:null};null===f?e=f=g:f=f.next=g;c=c.next}while(null!==c);null===f?e=f=b:f=f.next=b}else e=f=b;c={baseState:d.baseState,firstBaseUpdate:e,lastBaseUpdate:f,shared:d.shared,effects:d.effects};a.updateQueue=c;return}a=c.lastBaseUpdate;null===a?c.firstBaseUpdate=b:a.next=
b;c.lastBaseUpdate=b}
function Cg(a,b,c,d){var e=a.updateQueue;wg=!1;var f=e.firstBaseUpdate,g=e.lastBaseUpdate,h=e.shared.pending;if(null!==h){e.shared.pending=null;var k=h,l=k.next;k.next=null;null===g?f=l:g.next=l;g=k;var n=a.alternate;if(null!==n){n=n.updateQueue;var A=n.lastBaseUpdate;A!==g&&(null===A?n.firstBaseUpdate=l:A.next=l,n.lastBaseUpdate=k)}}if(null!==f){A=e.baseState;g=0;n=l=k=null;do{h=f.lane;var p=f.eventTime;if((d&h)===h){null!==n&&(n=n.next={eventTime:p,lane:0,tag:f.tag,payload:f.payload,callback:f.callback,
next:null});a:{var C=a,x=f;h=b;p=c;switch(x.tag){case 1:C=x.payload;if("function"===typeof C){A=C.call(p,A,h);break a}A=C;break a;case 3:C.flags=C.flags&-4097|64;case 0:C=x.payload;h="function"===typeof C?C.call(p,A,h):C;if(null===h||void 0===h)break a;A=m({},A,h);break a;case 2:wg=!0}}null!==f.callback&&(a.flags|=32,h=e.effects,null===h?e.effects=[f]:h.push(f))}else p={eventTime:p,lane:h,tag:f.tag,payload:f.payload,callback:f.callback,next:null},null===n?(l=n=p,k=A):n=n.next=p,g|=h;f=f.next;if(null===
f)if(h=e.shared.pending,null===h)break;else f=h.next,h.next=null,e.lastBaseUpdate=h,e.shared.pending=null}while(1);null===n&&(k=A);e.baseState=k;e.firstBaseUpdate=l;e.lastBaseUpdate=n;Dg|=g;a.lanes=g;a.memoizedState=A}}function Eg(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=c;if("function"!==typeof e)throw Error(y(191,e));e.call(d)}}}var Fg=(new aa.Component).refs;
function Gg(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:m({},b,c);a.memoizedState=c;0===a.lanes&&(a.updateQueue.baseState=c)}
var Kg={isMounted:function(a){return(a=a._reactInternals)?Zb(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternals;var d=Hg(),e=Ig(a),f=zg(d,e);f.payload=b;void 0!==c&&null!==c&&(f.callback=c);Ag(a,f);Jg(a,e,d)},enqueueReplaceState:function(a,b,c){a=a._reactInternals;var d=Hg(),e=Ig(a),f=zg(d,e);f.tag=1;f.payload=b;void 0!==c&&null!==c&&(f.callback=c);Ag(a,f);Jg(a,e,d)},enqueueForceUpdate:function(a,b){a=a._reactInternals;var c=Hg(),d=Ig(a),e=zg(c,d);e.tag=2;void 0!==b&&null!==b&&(e.callback=
b);Ag(a,e);Jg(a,d,c)}};function Lg(a,b,c,d,e,f,g){a=a.stateNode;return"function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,f,g):b.prototype&&b.prototype.isPureReactComponent?!Je(c,d)||!Je(e,f):!0}
function Mg(a,b,c){var d=!1,e=Cf;var f=b.contextType;"object"===typeof f&&null!==f?f=vg(f):(e=Ff(b)?Df:M.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?Ef(a,e):Cf);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Kg;a.stateNode=b;b._reactInternals=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}
function Ng(a,b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Kg.enqueueReplaceState(b,b.state,null)}
function Og(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=Fg;xg(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=vg(f):(f=Ff(b)?Df:M.current,e.context=Ef(a,f));Cg(a,c,e,d);e.state=a.memoizedState;f=b.getDerivedStateFromProps;"function"===typeof f&&(Gg(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||
(b=e.state,"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Kg.enqueueReplaceState(e,e.state,null),Cg(a,c,e,d),e.state=a.memoizedState);"function"===typeof e.componentDidMount&&(a.flags|=4)}var Pg=Array.isArray;
function Qg(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(y(309));var d=c.stateNode}if(!d)throw Error(y(147,a));var e=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===e)return b.ref;b=function(a){var b=d.refs;b===Fg&&(b=d.refs={});null===a?delete b[e]:b[e]=a};b._stringRef=e;return b}if("string"!==typeof a)throw Error(y(284));if(!c._owner)throw Error(y(290,a));}return a}
function Rg(a,b){if("textarea"!==a.type)throw Error(y(31,"[object Object]"===Object.prototype.toString.call(b)?"object with keys {"+Object.keys(b).join(", ")+"}":b));}
function Sg(a){function b(b,c){if(a){var d=b.lastEffect;null!==d?(d.nextEffect=c,b.lastEffect=c):b.firstEffect=b.lastEffect=c;c.nextEffect=null;c.flags=8}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,b),b=b.sibling;return a}function e(a,b){a=Tg(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.flags=2,
c):d;b.flags=2;return c}function g(b){a&&null===b.alternate&&(b.flags=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=Ug(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function k(a,b,c,d){if(null!==b&&b.elementType===c.type)return d=e(b,c.props),d.ref=Qg(a,b,c),d.return=a,d;d=Vg(c.type,c.key,c.props,null,a.mode,d);d.ref=Qg(a,b,c);d.return=a;return d}function l(a,b,c,d){if(null===b||4!==b.tag||b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=
Wg(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function n(a,b,c,d,f){if(null===b||7!==b.tag)return b=Xg(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function A(a,b,c){if("string"===typeof b||"number"===typeof b)return b=Ug(""+b,a.mode,c),b.return=a,b;if("object"===typeof b&&null!==b){switch(b.$$typeof){case sa:return c=Vg(b.type,b.key,b.props,null,a.mode,c),c.ref=Qg(a,null,b),c.return=a,c;case ta:return b=Wg(b,a.mode,c),b.return=a,b}if(Pg(b)||La(b))return b=Xg(b,
a.mode,c,null),b.return=a,b;Rg(a,b)}return null}function p(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case sa:return c.key===e?c.type===ua?n(a,b,c.props.children,d,e):k(a,b,c,d):null;case ta:return c.key===e?l(a,b,c,d):null}if(Pg(c)||La(c))return null!==e?null:n(a,b,c,d,null);Rg(a,c)}return null}function C(a,b,c,d,e){if("string"===typeof d||"number"===typeof d)return a=a.get(c)||
null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case sa:return a=a.get(null===d.key?c:d.key)||null,d.type===ua?n(b,a,d.props.children,e,d.key):k(b,a,d,e);case ta:return a=a.get(null===d.key?c:d.key)||null,l(b,a,d,e)}if(Pg(d)||La(d))return a=a.get(c)||null,n(b,a,d,e,null);Rg(b,d)}return null}function x(e,g,h,k){for(var l=null,t=null,u=g,z=g=0,q=null;null!==u&&z<h.length;z++){u.index>z?(q=u,u=null):q=u.sibling;var n=p(e,u,h[z],k);if(null===n){null===u&&(u=q);break}a&&u&&null===
n.alternate&&b(e,u);g=f(n,g,z);null===t?l=n:t.sibling=n;t=n;u=q}if(z===h.length)return c(e,u),l;if(null===u){for(;z<h.length;z++)u=A(e,h[z],k),null!==u&&(g=f(u,g,z),null===t?l=u:t.sibling=u,t=u);return l}for(u=d(e,u);z<h.length;z++)q=C(u,e,z,h[z],k),null!==q&&(a&&null!==q.alternate&&u.delete(null===q.key?z:q.key),g=f(q,g,z),null===t?l=q:t.sibling=q,t=q);a&&u.forEach(function(a){return b(e,a)});return l}function w(e,g,h,k){var l=La(h);if("function"!==typeof l)throw Error(y(150));h=l.call(h);if(null==
h)throw Error(y(151));for(var t=l=null,u=g,z=g=0,q=null,n=h.next();null!==u&&!n.done;z++,n=h.next()){u.index>z?(q=u,u=null):q=u.sibling;var w=p(e,u,n.value,k);if(null===w){null===u&&(u=q);break}a&&u&&null===w.alternate&&b(e,u);g=f(w,g,z);null===t?l=w:t.sibling=w;t=w;u=q}if(n.done)return c(e,u),l;if(null===u){for(;!n.done;z++,n=h.next())n=A(e,n.value,k),null!==n&&(g=f(n,g,z),null===t?l=n:t.sibling=n,t=n);return l}for(u=d(e,u);!n.done;z++,n=h.next())n=C(u,e,z,n.value,k),null!==n&&(a&&null!==n.alternate&&
u.delete(null===n.key?z:n.key),g=f(n,g,z),null===t?l=n:t.sibling=n,t=n);a&&u.forEach(function(a){return b(e,a)});return l}return function(a,d,f,h){var k="object"===typeof f&&null!==f&&f.type===ua&&null===f.key;k&&(f=f.props.children);var l="object"===typeof f&&null!==f;if(l)switch(f.$$typeof){case sa:a:{l=f.key;for(k=d;null!==k;){if(k.key===l){switch(k.tag){case 7:if(f.type===ua){c(a,k.sibling);d=e(k,f.props.children);d.return=a;a=d;break a}break;default:if(k.elementType===f.type){c(a,k.sibling);
d=e(k,f.props);d.ref=Qg(a,k,f);d.return=a;a=d;break a}}c(a,k);break}else b(a,k);k=k.sibling}f.type===ua?(d=Xg(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Vg(f.type,f.key,f.props,null,a.mode,h),h.ref=Qg(a,d,f),h.return=a,a=h)}return g(a);case ta:a:{for(k=f.key;null!==d;){if(d.key===k)if(4===d.tag&&d.stateNode.containerInfo===f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=
Wg(f,a.mode,h);d.return=a;a=d}return g(a)}if("string"===typeof f||"number"===typeof f)return f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):(c(a,d),d=Ug(f,a.mode,h),d.return=a,a=d),g(a);if(Pg(f))return x(a,d,f,h);if(La(f))return w(a,d,f,h);l&&Rg(a,f);if("undefined"===typeof f&&!k)switch(a.tag){case 1:case 22:case 0:case 11:case 15:throw Error(y(152,Ra(a.type)||"Component"));}return c(a,d)}}var Yg=Sg(!0),Zg=Sg(!1),$g={},ah=Bf($g),bh=Bf($g),ch=Bf($g);
function dh(a){if(a===$g)throw Error(y(174));return a}function eh(a,b){I(ch,b);I(bh,a);I(ah,$g);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:mb(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=mb(b,a)}H(ah);I(ah,b)}function fh(){H(ah);H(bh);H(ch)}function gh(a){dh(ch.current);var b=dh(ah.current);var c=mb(b,a.type);b!==c&&(I(bh,a),I(ah,c))}function hh(a){bh.current===a&&(H(ah),H(bh))}var P=Bf(0);
function ih(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||"$?"===c.data||"$!"===c.data))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.flags&64))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}var jh=null,kh=null,lh=!1;
function mh(a,b){var c=nh(5,null,null,0);c.elementType="DELETED";c.type="DELETED";c.stateNode=b;c.return=a;c.flags=8;null!==a.lastEffect?(a.lastEffect.nextEffect=c,a.lastEffect=c):a.firstEffect=a.lastEffect=c}function oh(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,!0):!1;case 6:return b=""===a.pendingProps||3!==b.nodeType?null:b,null!==b?(a.stateNode=b,!0):!1;case 13:return!1;default:return!1}}
function ph(a){if(lh){var b=kh;if(b){var c=b;if(!oh(a,b)){b=rf(c.nextSibling);if(!b||!oh(a,b)){a.flags=a.flags&-1025|2;lh=!1;jh=a;return}mh(jh,c)}jh=a;kh=rf(b.firstChild)}else a.flags=a.flags&-1025|2,lh=!1,jh=a}}function qh(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;jh=a}
function rh(a){if(a!==jh)return!1;if(!lh)return qh(a),lh=!0,!1;var b=a.type;if(5!==a.tag||"head"!==b&&"body"!==b&&!nf(b,a.memoizedProps))for(b=kh;b;)mh(a,b),b=rf(b.nextSibling);qh(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(y(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if("/$"===c){if(0===b){kh=rf(a.nextSibling);break a}b--}else"$"!==c&&"$!"!==c&&"$?"!==c||b++}a=a.nextSibling}kh=null}}else kh=jh?rf(a.stateNode.nextSibling):null;return!0}
function sh(){kh=jh=null;lh=!1}var th=[];function uh(){for(var a=0;a<th.length;a++)th[a]._workInProgressVersionPrimary=null;th.length=0}var vh=ra.ReactCurrentDispatcher,wh=ra.ReactCurrentBatchConfig,xh=0,R=null,S=null,T=null,yh=!1,zh=!1;function Ah(){throw Error(y(321));}function Bh(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!He(a[c],b[c]))return!1;return!0}
function Ch(a,b,c,d,e,f){xh=f;R=b;b.memoizedState=null;b.updateQueue=null;b.lanes=0;vh.current=null===a||null===a.memoizedState?Dh:Eh;a=c(d,e);if(zh){f=0;do{zh=!1;if(!(25>f))throw Error(y(301));f+=1;T=S=null;b.updateQueue=null;vh.current=Fh;a=c(d,e)}while(zh)}vh.current=Gh;b=null!==S&&null!==S.next;xh=0;T=S=R=null;yh=!1;if(b)throw Error(y(300));return a}function Hh(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===T?R.memoizedState=T=a:T=T.next=a;return T}
function Ih(){if(null===S){var a=R.alternate;a=null!==a?a.memoizedState:null}else a=S.next;var b=null===T?R.memoizedState:T.next;if(null!==b)T=b,S=a;else{if(null===a)throw Error(y(310));S=a;a={memoizedState:S.memoizedState,baseState:S.baseState,baseQueue:S.baseQueue,queue:S.queue,next:null};null===T?R.memoizedState=T=a:T=T.next=a}return T}function Jh(a,b){return"function"===typeof b?b(a):b}
function Kh(a){var b=Ih(),c=b.queue;if(null===c)throw Error(y(311));c.lastRenderedReducer=a;var d=S,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){e=e.next;d=d.baseState;var h=g=f=null,k=e;do{var l=k.lane;if((xh&l)===l)null!==h&&(h=h.next={lane:0,action:k.action,eagerReducer:k.eagerReducer,eagerState:k.eagerState,next:null}),d=k.eagerReducer===a?k.eagerState:a(d,k.action);else{var n={lane:l,action:k.action,eagerReducer:k.eagerReducer,
eagerState:k.eagerState,next:null};null===h?(g=h=n,f=d):h=h.next=n;R.lanes|=l;Dg|=l}k=k.next}while(null!==k&&k!==e);null===h?f=d:h.next=g;He(d,b.memoizedState)||(ug=!0);b.memoizedState=d;b.baseState=f;b.baseQueue=h;c.lastRenderedState=d}return[b.memoizedState,c.dispatch]}
function Lh(a){var b=Ih(),c=b.queue;if(null===c)throw Error(y(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);He(f,b.memoizedState)||(ug=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}
function Mh(a,b,c){var d=b._getVersion;d=d(b._source);var e=b._workInProgressVersionPrimary;if(null!==e)a=e===d;else if(a=a.mutableReadLanes,a=(xh&a)===a)b._workInProgressVersionPrimary=d,th.push(b);if(a)return c(b._source);th.push(b);throw Error(y(350));}
function Nh(a,b,c,d){var e=U;if(null===e)throw Error(y(349));var f=b._getVersion,g=f(b._source),h=vh.current,k=h.useState(function(){return Mh(e,b,c)}),l=k[1],n=k[0];k=T;var A=a.memoizedState,p=A.refs,C=p.getSnapshot,x=A.source;A=A.subscribe;var w=R;a.memoizedState={refs:p,source:b,subscribe:d};h.useEffect(function(){p.getSnapshot=c;p.setSnapshot=l;var a=f(b._source);if(!He(g,a)){a=c(b._source);He(n,a)||(l(a),a=Ig(w),e.mutableReadLanes|=a&e.pendingLanes);a=e.mutableReadLanes;e.entangledLanes|=a;for(var d=
e.entanglements,h=a;0<h;){var k=31-Vc(h),v=1<<k;d[k]|=a;h&=~v}}},[c,b,d]);h.useEffect(function(){return d(b._source,function(){var a=p.getSnapshot,c=p.setSnapshot;try{c(a(b._source));var d=Ig(w);e.mutableReadLanes|=d&e.pendingLanes}catch(q){c(function(){throw q;})}})},[b,d]);He(C,c)&&He(x,b)&&He(A,d)||(a={pending:null,dispatch:null,lastRenderedReducer:Jh,lastRenderedState:n},a.dispatch=l=Oh.bind(null,R,a),k.queue=a,k.baseQueue=null,n=Mh(e,b,c),k.memoizedState=k.baseState=n);return n}
function Ph(a,b,c){var d=Ih();return Nh(d,a,b,c)}function Qh(a){var b=Hh();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a=b.queue={pending:null,dispatch:null,lastRenderedReducer:Jh,lastRenderedState:a};a=a.dispatch=Oh.bind(null,R,a);return[b.memoizedState,a]}
function Rh(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=R.updateQueue;null===b?(b={lastEffect:null},R.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function Sh(a){var b=Hh();a={current:a};return b.memoizedState=a}function Th(){return Ih().memoizedState}function Uh(a,b,c,d){var e=Hh();R.flags|=a;e.memoizedState=Rh(1|b,c,void 0,void 0===d?null:d)}
function Vh(a,b,c,d){var e=Ih();d=void 0===d?null:d;var f=void 0;if(null!==S){var g=S.memoizedState;f=g.destroy;if(null!==d&&Bh(d,g.deps)){Rh(b,c,f,d);return}}R.flags|=a;e.memoizedState=Rh(1|b,c,f,d)}function Wh(a,b){return Uh(516,4,a,b)}function Xh(a,b){return Vh(516,4,a,b)}function Yh(a,b){return Vh(4,2,a,b)}function Zh(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}
function $h(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return Vh(4,2,Zh.bind(null,b,a),c)}function ai(){}function bi(a,b){var c=Ih();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&Bh(b,d[1]))return d[0];c.memoizedState=[a,b];return a}function ci(a,b){var c=Ih();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&Bh(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}
function di(a,b){var c=eg();gg(98>c?98:c,function(){a(!0)});gg(97<c?97:c,function(){var c=wh.transition;wh.transition=1;try{a(!1),b()}finally{wh.transition=c}})}
function Oh(a,b,c){var d=Hg(),e=Ig(a),f={lane:e,action:c,eagerReducer:null,eagerState:null,next:null},g=b.pending;null===g?f.next=f:(f.next=g.next,g.next=f);b.pending=f;g=a.alternate;if(a===R||null!==g&&g===R)zh=yh=!0;else{if(0===a.lanes&&(null===g||0===g.lanes)&&(g=b.lastRenderedReducer,null!==g))try{var h=b.lastRenderedState,k=g(h,c);f.eagerReducer=g;f.eagerState=k;if(He(k,h))return}catch(l){}finally{}Jg(a,e,d)}}
var Gh={readContext:vg,useCallback:Ah,useContext:Ah,useEffect:Ah,useImperativeHandle:Ah,useLayoutEffect:Ah,useMemo:Ah,useReducer:Ah,useRef:Ah,useState:Ah,useDebugValue:Ah,useDeferredValue:Ah,useTransition:Ah,useMutableSource:Ah,useOpaqueIdentifier:Ah,unstable_isNewReconciler:!1},Dh={readContext:vg,useCallback:function(a,b){Hh().memoizedState=[a,void 0===b?null:b];return a},useContext:vg,useEffect:Wh,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return Uh(4,2,Zh.bind(null,
b,a),c)},useLayoutEffect:function(a,b){return Uh(4,2,a,b)},useMemo:function(a,b){var c=Hh();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=Hh();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a=d.queue={pending:null,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};a=a.dispatch=Oh.bind(null,R,a);return[d.memoizedState,a]},useRef:Sh,useState:Qh,useDebugValue:ai,useDeferredValue:function(a){var b=Qh(a),c=b[0],d=b[1];Wh(function(){var b=wh.transition;
wh.transition=1;try{d(a)}finally{wh.transition=b}},[a]);return c},useTransition:function(){var a=Qh(!1),b=a[0];a=di.bind(null,a[1]);Sh(a);return[a,b]},useMutableSource:function(a,b,c){var d=Hh();d.memoizedState={refs:{getSnapshot:b,setSnapshot:null},source:a,subscribe:c};return Nh(d,a,b,c)},useOpaqueIdentifier:function(){if(lh){var a=!1,b=uf(function(){a||(a=!0,c("r:"+(tf++).toString(36)));throw Error(y(355));}),c=Qh(b)[1];0===(R.mode&2)&&(R.flags|=516,Rh(5,function(){c("r:"+(tf++).toString(36))},
void 0,null));return b}b="r:"+(tf++).toString(36);Qh(b);return b},unstable_isNewReconciler:!1},Eh={readContext:vg,useCallback:bi,useContext:vg,useEffect:Xh,useImperativeHandle:$h,useLayoutEffect:Yh,useMemo:ci,useReducer:Kh,useRef:Th,useState:function(){return Kh(Jh)},useDebugValue:ai,useDeferredValue:function(a){var b=Kh(Jh),c=b[0],d=b[1];Xh(function(){var b=wh.transition;wh.transition=1;try{d(a)}finally{wh.transition=b}},[a]);return c},useTransition:function(){var a=Kh(Jh)[0];return[Th().current,
a]},useMutableSource:Ph,useOpaqueIdentifier:function(){return Kh(Jh)[0]},unstable_isNewReconciler:!1},Fh={readContext:vg,useCallback:bi,useContext:vg,useEffect:Xh,useImperativeHandle:$h,useLayoutEffect:Yh,useMemo:ci,useReducer:Lh,useRef:Th,useState:function(){return Lh(Jh)},useDebugValue:ai,useDeferredValue:function(a){var b=Lh(Jh),c=b[0],d=b[1];Xh(function(){var b=wh.transition;wh.transition=1;try{d(a)}finally{wh.transition=b}},[a]);return c},useTransition:function(){var a=Lh(Jh)[0];return[Th().current,
a]},useMutableSource:Ph,useOpaqueIdentifier:function(){return Lh(Jh)[0]},unstable_isNewReconciler:!1},ei=ra.ReactCurrentOwner,ug=!1;function fi(a,b,c,d){b.child=null===a?Zg(b,null,c,d):Yg(b,a.child,c,d)}function gi(a,b,c,d,e){c=c.render;var f=b.ref;tg(b,e);d=Ch(a,b,c,d,f,e);if(null!==a&&!ug)return b.updateQueue=a.updateQueue,b.flags&=-517,a.lanes&=~e,hi(a,b,e);b.flags|=1;fi(a,b,d,e);return b.child}
function ii(a,b,c,d,e,f){if(null===a){var g=c.type;if("function"===typeof g&&!ji(g)&&void 0===g.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=g,ki(a,b,g,d,e,f);a=Vg(c.type,null,d,b,b.mode,f);a.ref=b.ref;a.return=b;return b.child=a}g=a.child;if(0===(e&f)&&(e=g.memoizedProps,c=c.compare,c=null!==c?c:Je,c(e,d)&&a.ref===b.ref))return hi(a,b,f);b.flags|=1;a=Tg(g,d);a.ref=b.ref;a.return=b;return b.child=a}
function ki(a,b,c,d,e,f){if(null!==a&&Je(a.memoizedProps,d)&&a.ref===b.ref)if(ug=!1,0!==(f&e))0!==(a.flags&16384)&&(ug=!0);else return b.lanes=a.lanes,hi(a,b,f);return li(a,b,c,d,f)}
function mi(a,b,c){var d=b.pendingProps,e=d.children,f=null!==a?a.memoizedState:null;if("hidden"===d.mode||"unstable-defer-without-hiding"===d.mode)if(0===(b.mode&4))b.memoizedState={baseLanes:0},ni(b,c);else if(0!==(c&1073741824))b.memoizedState={baseLanes:0},ni(b,null!==f?f.baseLanes:c);else return a=null!==f?f.baseLanes|c:c,b.lanes=b.childLanes=1073741824,b.memoizedState={baseLanes:a},ni(b,a),null;else null!==f?(d=f.baseLanes|c,b.memoizedState=null):d=c,ni(b,d);fi(a,b,e,c);return b.child}
function oi(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.flags|=128}function li(a,b,c,d,e){var f=Ff(c)?Df:M.current;f=Ef(b,f);tg(b,e);c=Ch(a,b,c,d,f,e);if(null!==a&&!ug)return b.updateQueue=a.updateQueue,b.flags&=-517,a.lanes&=~e,hi(a,b,e);b.flags|=1;fi(a,b,c,e);return b.child}
function pi(a,b,c,d,e){if(Ff(c)){var f=!0;Jf(b)}else f=!1;tg(b,e);if(null===b.stateNode)null!==a&&(a.alternate=null,b.alternate=null,b.flags|=2),Mg(b,c,d),Og(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var k=g.context,l=c.contextType;"object"===typeof l&&null!==l?l=vg(l):(l=Ff(c)?Df:M.current,l=Ef(b,l));var n=c.getDerivedStateFromProps,A="function"===typeof n||"function"===typeof g.getSnapshotBeforeUpdate;A||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&
"function"!==typeof g.componentWillReceiveProps||(h!==d||k!==l)&&Ng(b,g,d,l);wg=!1;var p=b.memoizedState;g.state=p;Cg(b,d,g,e);k=b.memoizedState;h!==d||p!==k||N.current||wg?("function"===typeof n&&(Gg(b,c,n,d),k=b.memoizedState),(h=wg||Lg(b,c,h,d,p,k,l))?(A||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===
typeof g.componentDidMount&&(b.flags|=4)):("function"===typeof g.componentDidMount&&(b.flags|=4),b.memoizedProps=d,b.memoizedState=k),g.props=d,g.state=k,g.context=l,d=h):("function"===typeof g.componentDidMount&&(b.flags|=4),d=!1)}else{g=b.stateNode;yg(a,b);h=b.memoizedProps;l=b.type===b.elementType?h:lg(b.type,h);g.props=l;A=b.pendingProps;p=g.context;k=c.contextType;"object"===typeof k&&null!==k?k=vg(k):(k=Ff(c)?Df:M.current,k=Ef(b,k));var C=c.getDerivedStateFromProps;(n="function"===typeof C||
"function"===typeof g.getSnapshotBeforeUpdate)||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==A||p!==k)&&Ng(b,g,d,k);wg=!1;p=b.memoizedState;g.state=p;Cg(b,d,g,e);var x=b.memoizedState;h!==A||p!==x||N.current||wg?("function"===typeof C&&(Gg(b,c,C,d),x=b.memoizedState),(l=wg||Lg(b,c,l,d,p,x,k))?(n||"function"!==typeof g.UNSAFE_componentWillUpdate&&"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,
x,k),"function"===typeof g.UNSAFE_componentWillUpdate&&g.UNSAFE_componentWillUpdate(d,x,k)),"function"===typeof g.componentDidUpdate&&(b.flags|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.flags|=256)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&p===a.memoizedState||(b.flags|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&p===a.memoizedState||(b.flags|=256),b.memoizedProps=d,b.memoizedState=x),g.props=d,g.state=x,g.context=k,d=l):("function"!==typeof g.componentDidUpdate||
h===a.memoizedProps&&p===a.memoizedState||(b.flags|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&p===a.memoizedState||(b.flags|=256),d=!1)}return qi(a,b,c,d,f,e)}
function qi(a,b,c,d,e,f){oi(a,b);var g=0!==(b.flags&64);if(!d&&!g)return e&&Kf(b,c,!1),hi(a,b,f);d=b.stateNode;ei.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?null:d.render();b.flags|=1;null!==a&&g?(b.child=Yg(b,a.child,null,f),b.child=Yg(b,null,h,f)):fi(a,b,h,f);b.memoizedState=d.state;e&&Kf(b,c,!0);return b.child}function ri(a){var b=a.stateNode;b.pendingContext?Hf(a,b.pendingContext,b.pendingContext!==b.context):b.context&&Hf(a,b.context,!1);eh(a,b.containerInfo)}
var si={dehydrated:null,retryLane:0};
function ti(a,b,c){var d=b.pendingProps,e=P.current,f=!1,g;(g=0!==(b.flags&64))||(g=null!==a&&null===a.memoizedState?!1:0!==(e&2));g?(f=!0,b.flags&=-65):null!==a&&null===a.memoizedState||void 0===d.fallback||!0===d.unstable_avoidThisFallback||(e|=1);I(P,e&1);if(null===a){void 0!==d.fallback&&ph(b);a=d.children;e=d.fallback;if(f)return a=ui(b,a,e,c),b.child.memoizedState={baseLanes:c},b.memoizedState=si,a;if("number"===typeof d.unstable_expectedLoadTime)return a=ui(b,a,e,c),b.child.memoizedState={baseLanes:c},
b.memoizedState=si,b.lanes=33554432,a;c=vi({mode:"visible",children:a},b.mode,c,null);c.return=b;return b.child=c}if(null!==a.memoizedState){if(f)return d=wi(a,b,d.children,d.fallback,c),f=b.child,e=a.child.memoizedState,f.memoizedState=null===e?{baseLanes:c}:{baseLanes:e.baseLanes|c},f.childLanes=a.childLanes&~c,b.memoizedState=si,d;c=xi(a,b,d.children,c);b.memoizedState=null;return c}if(f)return d=wi(a,b,d.children,d.fallback,c),f=b.child,e=a.child.memoizedState,f.memoizedState=null===e?{baseLanes:c}:
{baseLanes:e.baseLanes|c},f.childLanes=a.childLanes&~c,b.memoizedState=si,d;c=xi(a,b,d.children,c);b.memoizedState=null;return c}function ui(a,b,c,d){var e=a.mode,f=a.child;b={mode:"hidden",children:b};0===(e&2)&&null!==f?(f.childLanes=0,f.pendingProps=b):f=vi(b,e,0,null);c=Xg(c,e,d,null);f.return=a;c.return=a;f.sibling=c;a.child=f;return c}
function xi(a,b,c,d){var e=a.child;a=e.sibling;c=Tg(e,{mode:"visible",children:c});0===(b.mode&2)&&(c.lanes=d);c.return=b;c.sibling=null;null!==a&&(a.nextEffect=null,a.flags=8,b.firstEffect=b.lastEffect=a);return b.child=c}
function wi(a,b,c,d,e){var f=b.mode,g=a.child;a=g.sibling;var h={mode:"hidden",children:c};0===(f&2)&&b.child!==g?(c=b.child,c.childLanes=0,c.pendingProps=h,g=c.lastEffect,null!==g?(b.firstEffect=c.firstEffect,b.lastEffect=g,g.nextEffect=null):b.firstEffect=b.lastEffect=null):c=Tg(g,h);null!==a?d=Tg(a,d):(d=Xg(d,f,e,null),d.flags|=2);d.return=b;c.return=b;c.sibling=d;b.child=c;return d}function yi(a,b){a.lanes|=b;var c=a.alternate;null!==c&&(c.lanes|=b);sg(a.return,b)}
function zi(a,b,c,d,e,f){var g=a.memoizedState;null===g?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailMode:e,lastEffect:f}:(g.isBackwards=b,g.rendering=null,g.renderingStartTime=0,g.last=d,g.tail=c,g.tailMode=e,g.lastEffect=f)}
function Ai(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;fi(a,b,d.children,c);d=P.current;if(0!==(d&2))d=d&1|2,b.flags|=64;else{if(null!==a&&0!==(a.flags&64))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&yi(a,c);else if(19===a.tag)yi(a,c);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}I(P,d);if(0===(b.mode&2))b.memoizedState=
null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===ih(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);zi(b,!1,e,c,f,b.lastEffect);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===ih(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}zi(b,!0,c,null,f,b.lastEffect);break;case "together":zi(b,!1,null,null,void 0,b.lastEffect);break;default:b.memoizedState=null}return b.child}
function hi(a,b,c){null!==a&&(b.dependencies=a.dependencies);Dg|=b.lanes;if(0!==(c&b.childLanes)){if(null!==a&&b.child!==a.child)throw Error(y(153));if(null!==b.child){a=b.child;c=Tg(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Tg(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}return null}var Bi,Ci,Di,Ei;
Bi=function(a,b){for(var c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};Ci=function(){};
Di=function(a,b,c,d){var e=a.memoizedProps;if(e!==d){a=b.stateNode;dh(ah.current);var f=null;switch(c){case "input":e=Ya(a,e);d=Ya(a,d);f=[];break;case "option":e=eb(a,e);d=eb(a,d);f=[];break;case "select":e=m({},e,{value:void 0});d=m({},d,{value:void 0});f=[];break;case "textarea":e=gb(a,e);d=gb(a,d);f=[];break;default:"function"!==typeof e.onClick&&"function"===typeof d.onClick&&(a.onclick=jf)}vb(c,d);var g;c=null;for(l in e)if(!d.hasOwnProperty(l)&&e.hasOwnProperty(l)&&null!=e[l])if("style"===
l){var h=e[l];for(g in h)h.hasOwnProperty(g)&&(c||(c={}),c[g]="")}else"dangerouslySetInnerHTML"!==l&&"children"!==l&&"suppressContentEditableWarning"!==l&&"suppressHydrationWarning"!==l&&"autoFocus"!==l&&(ca.hasOwnProperty(l)?f||(f=[]):(f=f||[]).push(l,null));for(l in d){var k=d[l];h=null!=e?e[l]:void 0;if(d.hasOwnProperty(l)&&k!==h&&(null!=k||null!=h))if("style"===l)if(h){for(g in h)!h.hasOwnProperty(g)||k&&k.hasOwnProperty(g)||(c||(c={}),c[g]="");for(g in k)k.hasOwnProperty(g)&&h[g]!==k[g]&&(c||
(c={}),c[g]=k[g])}else c||(f||(f=[]),f.push(l,c)),c=k;else"dangerouslySetInnerHTML"===l?(k=k?k.__html:void 0,h=h?h.__html:void 0,null!=k&&h!==k&&(f=f||[]).push(l,k)):"children"===l?"string"!==typeof k&&"number"!==typeof k||(f=f||[]).push(l,""+k):"suppressContentEditableWarning"!==l&&"suppressHydrationWarning"!==l&&(ca.hasOwnProperty(l)?(null!=k&&"onScroll"===l&&G("scroll",a),f||h===k||(f=[])):"object"===typeof k&&null!==k&&k.$$typeof===Ga?k.toString():(f=f||[]).push(l,k))}c&&(f=f||[]).push("style",
c);var l=f;if(b.updateQueue=l)b.flags|=4}};Ei=function(a,b,c,d){c!==d&&(b.flags|=4)};function Fi(a,b){if(!lh)switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}
function Gi(a,b,c){var d=b.pendingProps;switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:return Ff(b.type)&&Gf(),null;case 3:fh();H(N);H(M);uh();d=b.stateNode;d.pendingContext&&(d.context=d.pendingContext,d.pendingContext=null);if(null===a||null===a.child)rh(b)?b.flags|=4:d.hydrate||(b.flags|=256);Ci(b);return null;case 5:hh(b);var e=dh(ch.current);c=b.type;if(null!==a&&null!=b.stateNode)Di(a,b,c,d,e),a.ref!==b.ref&&(b.flags|=128);else{if(!d){if(null===
b.stateNode)throw Error(y(166));return null}a=dh(ah.current);if(rh(b)){d=b.stateNode;c=b.type;var f=b.memoizedProps;d[wf]=b;d[xf]=f;switch(c){case "dialog":G("cancel",d);G("close",d);break;case "iframe":case "object":case "embed":G("load",d);break;case "video":case "audio":for(a=0;a<Xe.length;a++)G(Xe[a],d);break;case "source":G("error",d);break;case "img":case "image":case "link":G("error",d);G("load",d);break;case "details":G("toggle",d);break;case "input":Za(d,f);G("invalid",d);break;case "select":d._wrapperState=
{wasMultiple:!!f.multiple};G("invalid",d);break;case "textarea":hb(d,f),G("invalid",d)}vb(c,f);a=null;for(var g in f)f.hasOwnProperty(g)&&(e=f[g],"children"===g?"string"===typeof e?d.textContent!==e&&(a=["children",e]):"number"===typeof e&&d.textContent!==""+e&&(a=["children",""+e]):ca.hasOwnProperty(g)&&null!=e&&"onScroll"===g&&G("scroll",d));switch(c){case "input":Va(d);cb(d,f,!0);break;case "textarea":Va(d);jb(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=
jf)}d=a;b.updateQueue=d;null!==d&&(b.flags|=4)}else{g=9===e.nodeType?e:e.ownerDocument;a===kb.html&&(a=lb(c));a===kb.html?"script"===c?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):"string"===typeof d.is?a=g.createElement(c,{is:d.is}):(a=g.createElement(c),"select"===c&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,c);a[wf]=b;a[xf]=d;Bi(a,b,!1,!1);b.stateNode=a;g=wb(c,d);switch(c){case "dialog":G("cancel",a);G("close",a);
e=d;break;case "iframe":case "object":case "embed":G("load",a);e=d;break;case "video":case "audio":for(e=0;e<Xe.length;e++)G(Xe[e],a);e=d;break;case "source":G("error",a);e=d;break;case "img":case "image":case "link":G("error",a);G("load",a);e=d;break;case "details":G("toggle",a);e=d;break;case "input":Za(a,d);e=Ya(a,d);G("invalid",a);break;case "option":e=eb(a,d);break;case "select":a._wrapperState={wasMultiple:!!d.multiple};e=m({},d,{value:void 0});G("invalid",a);break;case "textarea":hb(a,d);e=
gb(a,d);G("invalid",a);break;default:e=d}vb(c,e);var h=e;for(f in h)if(h.hasOwnProperty(f)){var k=h[f];"style"===f?tb(a,k):"dangerouslySetInnerHTML"===f?(k=k?k.__html:void 0,null!=k&&ob(a,k)):"children"===f?"string"===typeof k?("textarea"!==c||""!==k)&&pb(a,k):"number"===typeof k&&pb(a,""+k):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(ca.hasOwnProperty(f)?null!=k&&"onScroll"===f&&G("scroll",a):null!=k&&qa(a,f,k,g))}switch(c){case "input":Va(a);cb(a,d,!1);
break;case "textarea":Va(a);jb(a);break;case "option":null!=d.value&&a.setAttribute("value",""+Sa(d.value));break;case "select":a.multiple=!!d.multiple;f=d.value;null!=f?fb(a,!!d.multiple,f,!1):null!=d.defaultValue&&fb(a,!!d.multiple,d.defaultValue,!0);break;default:"function"===typeof e.onClick&&(a.onclick=jf)}mf(c,d)&&(b.flags|=4)}null!==b.ref&&(b.flags|=128)}return null;case 6:if(a&&null!=b.stateNode)Ei(a,b,a.memoizedProps,d);else{if("string"!==typeof d&&null===b.stateNode)throw Error(y(166));
c=dh(ch.current);dh(ah.current);rh(b)?(d=b.stateNode,c=b.memoizedProps,d[wf]=b,d.nodeValue!==c&&(b.flags|=4)):(d=(9===c.nodeType?c:c.ownerDocument).createTextNode(d),d[wf]=b,b.stateNode=d)}return null;case 13:H(P);d=b.memoizedState;if(0!==(b.flags&64))return b.lanes=c,b;d=null!==d;c=!1;null===a?void 0!==b.memoizedProps.fallback&&rh(b):c=null!==a.memoizedState;if(d&&!c&&0!==(b.mode&2))if(null===a&&!0!==b.memoizedProps.unstable_avoidThisFallback||0!==(P.current&1))0===V&&(V=3);else{if(0===V||3===V)V=
4;null===U||0===(Dg&134217727)&&0===(Hi&134217727)||Ii(U,W)}if(d||c)b.flags|=4;return null;case 4:return fh(),Ci(b),null===a&&cf(b.stateNode.containerInfo),null;case 10:return rg(b),null;case 17:return Ff(b.type)&&Gf(),null;case 19:H(P);d=b.memoizedState;if(null===d)return null;f=0!==(b.flags&64);g=d.rendering;if(null===g)if(f)Fi(d,!1);else{if(0!==V||null!==a&&0!==(a.flags&64))for(a=b.child;null!==a;){g=ih(a);if(null!==g){b.flags|=64;Fi(d,!1);f=g.updateQueue;null!==f&&(b.updateQueue=f,b.flags|=4);
null===d.lastEffect&&(b.firstEffect=null);b.lastEffect=d.lastEffect;d=c;for(c=b.child;null!==c;)f=c,a=d,f.flags&=2,f.nextEffect=null,f.firstEffect=null,f.lastEffect=null,g=f.alternate,null===g?(f.childLanes=0,f.lanes=a,f.child=null,f.memoizedProps=null,f.memoizedState=null,f.updateQueue=null,f.dependencies=null,f.stateNode=null):(f.childLanes=g.childLanes,f.lanes=g.lanes,f.child=g.child,f.memoizedProps=g.memoizedProps,f.memoizedState=g.memoizedState,f.updateQueue=g.updateQueue,f.type=g.type,a=g.dependencies,
f.dependencies=null===a?null:{lanes:a.lanes,firstContext:a.firstContext}),c=c.sibling;I(P,P.current&1|2);return b.child}a=a.sibling}null!==d.tail&&O()>Ji&&(b.flags|=64,f=!0,Fi(d,!1),b.lanes=33554432)}else{if(!f)if(a=ih(g),null!==a){if(b.flags|=64,f=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.flags|=4),Fi(d,!0),null===d.tail&&"hidden"===d.tailMode&&!g.alternate&&!lh)return b=b.lastEffect=d.lastEffect,null!==b&&(b.nextEffect=null),null}else 2*O()-d.renderingStartTime>Ji&&1073741824!==c&&(b.flags|=
64,f=!0,Fi(d,!1),b.lanes=33554432);d.isBackwards?(g.sibling=b.child,b.child=g):(c=d.last,null!==c?c.sibling=g:b.child=g,d.last=g)}return null!==d.tail?(c=d.tail,d.rendering=c,d.tail=c.sibling,d.lastEffect=b.lastEffect,d.renderingStartTime=O(),c.sibling=null,b=P.current,I(P,f?b&1|2:b&1),c):null;case 23:case 24:return Ki(),null!==a&&null!==a.memoizedState!==(null!==b.memoizedState)&&"unstable-defer-without-hiding"!==d.mode&&(b.flags|=4),null}throw Error(y(156,b.tag));}
function Li(a){switch(a.tag){case 1:Ff(a.type)&&Gf();var b=a.flags;return b&4096?(a.flags=b&-4097|64,a):null;case 3:fh();H(N);H(M);uh();b=a.flags;if(0!==(b&64))throw Error(y(285));a.flags=b&-4097|64;return a;case 5:return hh(a),null;case 13:return H(P),b=a.flags,b&4096?(a.flags=b&-4097|64,a):null;case 19:return H(P),null;case 4:return fh(),null;case 10:return rg(a),null;case 23:case 24:return Ki(),null;default:return null}}
function Mi(a,b){try{var c="",d=b;do c+=Qa(d),d=d.return;while(d);var e=c}catch(f){e="\nError generating stack: "+f.message+"\n"+f.stack}return{value:a,source:b,stack:e}}function Ni(a,b){try{console.error(b.value)}catch(c){setTimeout(function(){throw c;})}}var Oi="function"===typeof WeakMap?WeakMap:Map;function Pi(a,b,c){c=zg(-1,c);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){Qi||(Qi=!0,Ri=d);Ni(a,b)};return c}
function Si(a,b,c){c=zg(-1,c);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){Ni(a,b);return d(e)}}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){"function"!==typeof d&&(null===Ti?Ti=new Set([this]):Ti.add(this),Ni(a,b));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""})});return c}var Ui="function"===typeof WeakSet?WeakSet:Set;
function Vi(a){var b=a.ref;if(null!==b)if("function"===typeof b)try{b(null)}catch(c){Wi(a,c)}else b.current=null}function Xi(a,b){switch(b.tag){case 0:case 11:case 15:case 22:return;case 1:if(b.flags&256&&null!==a){var c=a.memoizedProps,d=a.memoizedState;a=b.stateNode;b=a.getSnapshotBeforeUpdate(b.elementType===b.type?c:lg(b.type,c),d);a.__reactInternalSnapshotBeforeUpdate=b}return;case 3:b.flags&256&&qf(b.stateNode.containerInfo);return;case 5:case 6:case 4:case 17:return}throw Error(y(163));}
function Yi(a,b,c){switch(c.tag){case 0:case 11:case 15:case 22:b=c.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){a=b=b.next;do{if(3===(a.tag&3)){var d=a.create;a.destroy=d()}a=a.next}while(a!==b)}b=c.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){a=b=b.next;do{var e=a;d=e.next;e=e.tag;0!==(e&4)&&0!==(e&1)&&(Zi(c,a),$i(c,a));a=d}while(a!==b)}return;case 1:a=c.stateNode;c.flags&4&&(null===b?a.componentDidMount():(d=c.elementType===c.type?b.memoizedProps:lg(c.type,b.memoizedProps),a.componentDidUpdate(d,
b.memoizedState,a.__reactInternalSnapshotBeforeUpdate)));b=c.updateQueue;null!==b&&Eg(c,b,a);return;case 3:b=c.updateQueue;if(null!==b){a=null;if(null!==c.child)switch(c.child.tag){case 5:a=c.child.stateNode;break;case 1:a=c.child.stateNode}Eg(c,b,a)}return;case 5:a=c.stateNode;null===b&&c.flags&4&&mf(c.type,c.memoizedProps)&&a.focus();return;case 6:return;case 4:return;case 12:return;case 13:null===c.memoizedState&&(c=c.alternate,null!==c&&(c=c.memoizedState,null!==c&&(c=c.dehydrated,null!==c&&Cc(c))));
return;case 19:case 17:case 20:case 21:case 23:case 24:return}throw Error(y(163));}
function aj(a,b){for(var c=a;;){if(5===c.tag){var d=c.stateNode;if(b)d=d.style,"function"===typeof d.setProperty?d.setProperty("display","none","important"):d.display="none";else{d=c.stateNode;var e=c.memoizedProps.style;e=void 0!==e&&null!==e&&e.hasOwnProperty("display")?e.display:null;d.style.display=sb("display",e)}}else if(6===c.tag)c.stateNode.nodeValue=b?"":c.memoizedProps;else if((23!==c.tag&&24!==c.tag||null===c.memoizedState||c===a)&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===
a)break;for(;null===c.sibling;){if(null===c.return||c.return===a)return;c=c.return}c.sibling.return=c.return;c=c.sibling}}
function bj(a,b){if(Mf&&"function"===typeof Mf.onCommitFiberUnmount)try{Mf.onCommitFiberUnmount(Lf,b)}catch(f){}switch(b.tag){case 0:case 11:case 14:case 15:case 22:a=b.updateQueue;if(null!==a&&(a=a.lastEffect,null!==a)){var c=a=a.next;do{var d=c,e=d.destroy;d=d.tag;if(void 0!==e)if(0!==(d&4))Zi(b,c);else{d=b;try{e()}catch(f){Wi(d,f)}}c=c.next}while(c!==a)}break;case 1:Vi(b);a=b.stateNode;if("function"===typeof a.componentWillUnmount)try{a.props=b.memoizedProps,a.state=b.memoizedState,a.componentWillUnmount()}catch(f){Wi(b,
f)}break;case 5:Vi(b);break;case 4:cj(a,b)}}function dj(a){a.alternate=null;a.child=null;a.dependencies=null;a.firstEffect=null;a.lastEffect=null;a.memoizedProps=null;a.memoizedState=null;a.pendingProps=null;a.return=null;a.updateQueue=null}function ej(a){return 5===a.tag||3===a.tag||4===a.tag}
function fj(a){a:{for(var b=a.return;null!==b;){if(ej(b))break a;b=b.return}throw Error(y(160));}var c=b;b=c.stateNode;switch(c.tag){case 5:var d=!1;break;case 3:b=b.containerInfo;d=!0;break;case 4:b=b.containerInfo;d=!0;break;default:throw Error(y(161));}c.flags&16&&(pb(b,""),c.flags&=-17);a:b:for(c=a;;){for(;null===c.sibling;){if(null===c.return||ej(c.return)){c=null;break a}c=c.return}c.sibling.return=c.return;for(c=c.sibling;5!==c.tag&&6!==c.tag&&18!==c.tag;){if(c.flags&2)continue b;if(null===
c.child||4===c.tag)continue b;else c.child.return=c,c=c.child}if(!(c.flags&2)){c=c.stateNode;break a}}d?gj(a,c,b):hj(a,c,b)}
function gj(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=jf));else if(4!==d&&(a=a.child,null!==a))for(gj(a,b,c),a=a.sibling;null!==a;)gj(a,b,c),a=a.sibling}
function hj(a,b,c){var d=a.tag,e=5===d||6===d;if(e)a=e?a.stateNode:a.stateNode.instance,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(hj(a,b,c),a=a.sibling;null!==a;)hj(a,b,c),a=a.sibling}
function cj(a,b){for(var c=b,d=!1,e,f;;){if(!d){d=c.return;a:for(;;){if(null===d)throw Error(y(160));e=d.stateNode;switch(d.tag){case 5:f=!1;break a;case 3:e=e.containerInfo;f=!0;break a;case 4:e=e.containerInfo;f=!0;break a}d=d.return}d=!0}if(5===c.tag||6===c.tag){a:for(var g=a,h=c,k=h;;)if(bj(g,k),null!==k.child&&4!==k.tag)k.child.return=k,k=k.child;else{if(k===h)break a;for(;null===k.sibling;){if(null===k.return||k.return===h)break a;k=k.return}k.sibling.return=k.return;k=k.sibling}f?(g=e,h=c.stateNode,
8===g.nodeType?g.parentNode.removeChild(h):g.removeChild(h)):e.removeChild(c.stateNode)}else if(4===c.tag){if(null!==c.child){e=c.stateNode.containerInfo;f=!0;c.child.return=c;c=c.child;continue}}else if(bj(a,c),null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return;4===c.tag&&(d=!1)}c.sibling.return=c.return;c=c.sibling}}
function ij(a,b){switch(b.tag){case 0:case 11:case 14:case 15:case 22:var c=b.updateQueue;c=null!==c?c.lastEffect:null;if(null!==c){var d=c=c.next;do 3===(d.tag&3)&&(a=d.destroy,d.destroy=void 0,void 0!==a&&a()),d=d.next;while(d!==c)}return;case 1:return;case 5:c=b.stateNode;if(null!=c){d=b.memoizedProps;var e=null!==a?a.memoizedProps:d;a=b.type;var f=b.updateQueue;b.updateQueue=null;if(null!==f){c[xf]=d;"input"===a&&"radio"===d.type&&null!=d.name&&$a(c,d);wb(a,e);b=wb(a,d);for(e=0;e<f.length;e+=
2){var g=f[e],h=f[e+1];"style"===g?tb(c,h):"dangerouslySetInnerHTML"===g?ob(c,h):"children"===g?pb(c,h):qa(c,g,h,b)}switch(a){case "input":ab(c,d);break;case "textarea":ib(c,d);break;case "select":a=c._wrapperState.wasMultiple,c._wrapperState.wasMultiple=!!d.multiple,f=d.value,null!=f?fb(c,!!d.multiple,f,!1):a!==!!d.multiple&&(null!=d.defaultValue?fb(c,!!d.multiple,d.defaultValue,!0):fb(c,!!d.multiple,d.multiple?[]:"",!1))}}}return;case 6:if(null===b.stateNode)throw Error(y(162));b.stateNode.nodeValue=
b.memoizedProps;return;case 3:c=b.stateNode;c.hydrate&&(c.hydrate=!1,Cc(c.containerInfo));return;case 12:return;case 13:null!==b.memoizedState&&(jj=O(),aj(b.child,!0));kj(b);return;case 19:kj(b);return;case 17:return;case 23:case 24:aj(b,null!==b.memoizedState);return}throw Error(y(163));}function kj(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=new Ui);b.forEach(function(b){var d=lj.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}
function mj(a,b){return null!==a&&(a=a.memoizedState,null===a||null!==a.dehydrated)?(b=b.memoizedState,null!==b&&null===b.dehydrated):!1}var nj=Math.ceil,oj=ra.ReactCurrentDispatcher,pj=ra.ReactCurrentOwner,X=0,U=null,Y=null,W=0,qj=0,rj=Bf(0),V=0,sj=null,tj=0,Dg=0,Hi=0,uj=0,vj=null,jj=0,Ji=Infinity;function wj(){Ji=O()+500}var Z=null,Qi=!1,Ri=null,Ti=null,xj=!1,yj=null,zj=90,Aj=[],Bj=[],Cj=null,Dj=0,Ej=null,Fj=-1,Gj=0,Hj=0,Ij=null,Jj=!1;function Hg(){return 0!==(X&48)?O():-1!==Fj?Fj:Fj=O()}
function Ig(a){a=a.mode;if(0===(a&2))return 1;if(0===(a&4))return 99===eg()?1:2;0===Gj&&(Gj=tj);if(0!==kg.transition){0!==Hj&&(Hj=null!==vj?vj.pendingLanes:0);a=Gj;var b=4186112&~Hj;b&=-b;0===b&&(a=4186112&~a,b=a&-a,0===b&&(b=8192));return b}a=eg();0!==(X&4)&&98===a?a=Xc(12,Gj):(a=Sc(a),a=Xc(a,Gj));return a}
function Jg(a,b,c){if(50<Dj)throw Dj=0,Ej=null,Error(y(185));a=Kj(a,b);if(null===a)return null;$c(a,b,c);a===U&&(Hi|=b,4===V&&Ii(a,W));var d=eg();1===b?0!==(X&8)&&0===(X&48)?Lj(a):(Mj(a,c),0===X&&(wj(),ig())):(0===(X&4)||98!==d&&99!==d||(null===Cj?Cj=new Set([a]):Cj.add(a)),Mj(a,c));vj=a}function Kj(a,b){a.lanes|=b;var c=a.alternate;null!==c&&(c.lanes|=b);c=a;for(a=a.return;null!==a;)a.childLanes|=b,c=a.alternate,null!==c&&(c.childLanes|=b),c=a,a=a.return;return 3===c.tag?c.stateNode:null}
function Mj(a,b){for(var c=a.callbackNode,d=a.suspendedLanes,e=a.pingedLanes,f=a.expirationTimes,g=a.pendingLanes;0<g;){var h=31-Vc(g),k=1<<h,l=f[h];if(-1===l){if(0===(k&d)||0!==(k&e)){l=b;Rc(k);var n=F;f[h]=10<=n?l+250:6<=n?l+5E3:-1}}else l<=b&&(a.expiredLanes|=k);g&=~k}d=Uc(a,a===U?W:0);b=F;if(0===d)null!==c&&(c!==Zf&&Pf(c),a.callbackNode=null,a.callbackPriority=0);else{if(null!==c){if(a.callbackPriority===b)return;c!==Zf&&Pf(c)}15===b?(c=Lj.bind(null,a),null===ag?(ag=[c],bg=Of(Uf,jg)):ag.push(c),
c=Zf):14===b?c=hg(99,Lj.bind(null,a)):(c=Tc(b),c=hg(c,Nj.bind(null,a)));a.callbackPriority=b;a.callbackNode=c}}
function Nj(a){Fj=-1;Hj=Gj=0;if(0!==(X&48))throw Error(y(327));var b=a.callbackNode;if(Oj()&&a.callbackNode!==b)return null;var c=Uc(a,a===U?W:0);if(0===c)return null;var d=c;var e=X;X|=16;var f=Pj();if(U!==a||W!==d)wj(),Qj(a,d);do try{Rj();break}catch(h){Sj(a,h)}while(1);qg();oj.current=f;X=e;null!==Y?d=0:(U=null,W=0,d=V);if(0!==(tj&Hi))Qj(a,0);else if(0!==d){2===d&&(X|=64,a.hydrate&&(a.hydrate=!1,qf(a.containerInfo)),c=Wc(a),0!==c&&(d=Tj(a,c)));if(1===d)throw b=sj,Qj(a,0),Ii(a,c),Mj(a,O()),b;a.finishedWork=
a.current.alternate;a.finishedLanes=c;switch(d){case 0:case 1:throw Error(y(345));case 2:Uj(a);break;case 3:Ii(a,c);if((c&62914560)===c&&(d=jj+500-O(),10<d)){if(0!==Uc(a,0))break;e=a.suspendedLanes;if((e&c)!==c){Hg();a.pingedLanes|=a.suspendedLanes&e;break}a.timeoutHandle=of(Uj.bind(null,a),d);break}Uj(a);break;case 4:Ii(a,c);if((c&4186112)===c)break;d=a.eventTimes;for(e=-1;0<c;){var g=31-Vc(c);f=1<<g;g=d[g];g>e&&(e=g);c&=~f}c=e;c=O()-c;c=(120>c?120:480>c?480:1080>c?1080:1920>c?1920:3E3>c?3E3:4320>
c?4320:1960*nj(c/1960))-c;if(10<c){a.timeoutHandle=of(Uj.bind(null,a),c);break}Uj(a);break;case 5:Uj(a);break;default:throw Error(y(329));}}Mj(a,O());return a.callbackNode===b?Nj.bind(null,a):null}function Ii(a,b){b&=~uj;b&=~Hi;a.suspendedLanes|=b;a.pingedLanes&=~b;for(a=a.expirationTimes;0<b;){var c=31-Vc(b),d=1<<c;a[c]=-1;b&=~d}}
function Lj(a){if(0!==(X&48))throw Error(y(327));Oj();if(a===U&&0!==(a.expiredLanes&W)){var b=W;var c=Tj(a,b);0!==(tj&Hi)&&(b=Uc(a,b),c=Tj(a,b))}else b=Uc(a,0),c=Tj(a,b);0!==a.tag&&2===c&&(X|=64,a.hydrate&&(a.hydrate=!1,qf(a.containerInfo)),b=Wc(a),0!==b&&(c=Tj(a,b)));if(1===c)throw c=sj,Qj(a,0),Ii(a,b),Mj(a,O()),c;a.finishedWork=a.current.alternate;a.finishedLanes=b;Uj(a);Mj(a,O());return null}
function Vj(){if(null!==Cj){var a=Cj;Cj=null;a.forEach(function(a){a.expiredLanes|=24&a.pendingLanes;Mj(a,O())})}ig()}function Wj(a,b){var c=X;X|=1;try{return a(b)}finally{X=c,0===X&&(wj(),ig())}}function Xj(a,b){var c=X;X&=-2;X|=8;try{return a(b)}finally{X=c,0===X&&(wj(),ig())}}function ni(a,b){I(rj,qj);qj|=b;tj|=b}function Ki(){qj=rj.current;H(rj)}
function Qj(a,b){a.finishedWork=null;a.finishedLanes=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,pf(c));if(null!==Y)for(c=Y.return;null!==c;){var d=c;switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&Gf();break;case 3:fh();H(N);H(M);uh();break;case 5:hh(d);break;case 4:fh();break;case 13:H(P);break;case 19:H(P);break;case 10:rg(d);break;case 23:case 24:Ki()}c=c.return}U=a;Y=Tg(a.current,null);W=qj=tj=b;V=0;sj=null;uj=Hi=Dg=0}
function Sj(a,b){do{var c=Y;try{qg();vh.current=Gh;if(yh){for(var d=R.memoizedState;null!==d;){var e=d.queue;null!==e&&(e.pending=null);d=d.next}yh=!1}xh=0;T=S=R=null;zh=!1;pj.current=null;if(null===c||null===c.return){V=1;sj=b;Y=null;break}a:{var f=a,g=c.return,h=c,k=b;b=W;h.flags|=2048;h.firstEffect=h.lastEffect=null;if(null!==k&&"object"===typeof k&&"function"===typeof k.then){var l=k;if(0===(h.mode&2)){var n=h.alternate;n?(h.updateQueue=n.updateQueue,h.memoizedState=n.memoizedState,h.lanes=n.lanes):
(h.updateQueue=null,h.memoizedState=null)}var A=0!==(P.current&1),p=g;do{var C;if(C=13===p.tag){var x=p.memoizedState;if(null!==x)C=null!==x.dehydrated?!0:!1;else{var w=p.memoizedProps;C=void 0===w.fallback?!1:!0!==w.unstable_avoidThisFallback?!0:A?!1:!0}}if(C){var z=p.updateQueue;if(null===z){var u=new Set;u.add(l);p.updateQueue=u}else z.add(l);if(0===(p.mode&2)){p.flags|=64;h.flags|=16384;h.flags&=-2981;if(1===h.tag)if(null===h.alternate)h.tag=17;else{var t=zg(-1,1);t.tag=2;Ag(h,t)}h.lanes|=1;break a}k=
void 0;h=b;var q=f.pingCache;null===q?(q=f.pingCache=new Oi,k=new Set,q.set(l,k)):(k=q.get(l),void 0===k&&(k=new Set,q.set(l,k)));if(!k.has(h)){k.add(h);var v=Yj.bind(null,f,l,h);l.then(v,v)}p.flags|=4096;p.lanes=b;break a}p=p.return}while(null!==p);k=Error((Ra(h.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display.")}5!==V&&(V=2);k=Mi(k,h);p=
g;do{switch(p.tag){case 3:f=k;p.flags|=4096;b&=-b;p.lanes|=b;var J=Pi(p,f,b);Bg(p,J);break a;case 1:f=k;var K=p.type,Q=p.stateNode;if(0===(p.flags&64)&&("function"===typeof K.getDerivedStateFromError||null!==Q&&"function"===typeof Q.componentDidCatch&&(null===Ti||!Ti.has(Q)))){p.flags|=4096;b&=-b;p.lanes|=b;var L=Si(p,f,b);Bg(p,L);break a}}p=p.return}while(null!==p)}Zj(c)}catch(va){b=va;Y===c&&null!==c&&(Y=c=c.return);continue}break}while(1)}
function Pj(){var a=oj.current;oj.current=Gh;return null===a?Gh:a}function Tj(a,b){var c=X;X|=16;var d=Pj();U===a&&W===b||Qj(a,b);do try{ak();break}catch(e){Sj(a,e)}while(1);qg();X=c;oj.current=d;if(null!==Y)throw Error(y(261));U=null;W=0;return V}function ak(){for(;null!==Y;)bk(Y)}function Rj(){for(;null!==Y&&!Qf();)bk(Y)}function bk(a){var b=ck(a.alternate,a,qj);a.memoizedProps=a.pendingProps;null===b?Zj(a):Y=b;pj.current=null}
function Zj(a){var b=a;do{var c=b.alternate;a=b.return;if(0===(b.flags&2048)){c=Gi(c,b,qj);if(null!==c){Y=c;return}c=b;if(24!==c.tag&&23!==c.tag||null===c.memoizedState||0!==(qj&1073741824)||0===(c.mode&4)){for(var d=0,e=c.child;null!==e;)d|=e.lanes|e.childLanes,e=e.sibling;c.childLanes=d}null!==a&&0===(a.flags&2048)&&(null===a.firstEffect&&(a.firstEffect=b.firstEffect),null!==b.lastEffect&&(null!==a.lastEffect&&(a.lastEffect.nextEffect=b.firstEffect),a.lastEffect=b.lastEffect),1<b.flags&&(null!==
a.lastEffect?a.lastEffect.nextEffect=b:a.firstEffect=b,a.lastEffect=b))}else{c=Li(b);if(null!==c){c.flags&=2047;Y=c;return}null!==a&&(a.firstEffect=a.lastEffect=null,a.flags|=2048)}b=b.sibling;if(null!==b){Y=b;return}Y=b=a}while(null!==b);0===V&&(V=5)}function Uj(a){var b=eg();gg(99,dk.bind(null,a,b));return null}
function dk(a,b){do Oj();while(null!==yj);if(0!==(X&48))throw Error(y(327));var c=a.finishedWork;if(null===c)return null;a.finishedWork=null;a.finishedLanes=0;if(c===a.current)throw Error(y(177));a.callbackNode=null;var d=c.lanes|c.childLanes,e=d,f=a.pendingLanes&~e;a.pendingLanes=e;a.suspendedLanes=0;a.pingedLanes=0;a.expiredLanes&=e;a.mutableReadLanes&=e;a.entangledLanes&=e;e=a.entanglements;for(var g=a.eventTimes,h=a.expirationTimes;0<f;){var k=31-Vc(f),l=1<<k;e[k]=0;g[k]=-1;h[k]=-1;f&=~l}null!==
Cj&&0===(d&24)&&Cj.has(a)&&Cj.delete(a);a===U&&(Y=U=null,W=0);1<c.flags?null!==c.lastEffect?(c.lastEffect.nextEffect=c,d=c.firstEffect):d=c:d=c.firstEffect;if(null!==d){e=X;X|=32;pj.current=null;kf=fd;g=Ne();if(Oe(g)){if("selectionStart"in g)h={start:g.selectionStart,end:g.selectionEnd};else a:if(h=(h=g.ownerDocument)&&h.defaultView||window,(l=h.getSelection&&h.getSelection())&&0!==l.rangeCount){h=l.anchorNode;f=l.anchorOffset;k=l.focusNode;l=l.focusOffset;try{h.nodeType,k.nodeType}catch(va){h=null;
break a}var n=0,A=-1,p=-1,C=0,x=0,w=g,z=null;b:for(;;){for(var u;;){w!==h||0!==f&&3!==w.nodeType||(A=n+f);w!==k||0!==l&&3!==w.nodeType||(p=n+l);3===w.nodeType&&(n+=w.nodeValue.length);if(null===(u=w.firstChild))break;z=w;w=u}for(;;){if(w===g)break b;z===h&&++C===f&&(A=n);z===k&&++x===l&&(p=n);if(null!==(u=w.nextSibling))break;w=z;z=w.parentNode}w=u}h=-1===A||-1===p?null:{start:A,end:p}}else h=null;h=h||{start:0,end:0}}else h=null;lf={focusedElem:g,selectionRange:h};fd=!1;Ij=null;Jj=!1;Z=d;do try{ek()}catch(va){if(null===
Z)throw Error(y(330));Wi(Z,va);Z=Z.nextEffect}while(null!==Z);Ij=null;Z=d;do try{for(g=a;null!==Z;){var t=Z.flags;t&16&&pb(Z.stateNode,"");if(t&128){var q=Z.alternate;if(null!==q){var v=q.ref;null!==v&&("function"===typeof v?v(null):v.current=null)}}switch(t&1038){case 2:fj(Z);Z.flags&=-3;break;case 6:fj(Z);Z.flags&=-3;ij(Z.alternate,Z);break;case 1024:Z.flags&=-1025;break;case 1028:Z.flags&=-1025;ij(Z.alternate,Z);break;case 4:ij(Z.alternate,Z);break;case 8:h=Z;cj(g,h);var J=h.alternate;dj(h);null!==
J&&dj(J)}Z=Z.nextEffect}}catch(va){if(null===Z)throw Error(y(330));Wi(Z,va);Z=Z.nextEffect}while(null!==Z);v=lf;q=Ne();t=v.focusedElem;g=v.selectionRange;if(q!==t&&t&&t.ownerDocument&&Me(t.ownerDocument.documentElement,t)){null!==g&&Oe(t)&&(q=g.start,v=g.end,void 0===v&&(v=q),"selectionStart"in t?(t.selectionStart=q,t.selectionEnd=Math.min(v,t.value.length)):(v=(q=t.ownerDocument||document)&&q.defaultView||window,v.getSelection&&(v=v.getSelection(),h=t.textContent.length,J=Math.min(g.start,h),g=void 0===
g.end?J:Math.min(g.end,h),!v.extend&&J>g&&(h=g,g=J,J=h),h=Le(t,J),f=Le(t,g),h&&f&&(1!==v.rangeCount||v.anchorNode!==h.node||v.anchorOffset!==h.offset||v.focusNode!==f.node||v.focusOffset!==f.offset)&&(q=q.createRange(),q.setStart(h.node,h.offset),v.removeAllRanges(),J>g?(v.addRange(q),v.extend(f.node,f.offset)):(q.setEnd(f.node,f.offset),v.addRange(q))))));q=[];for(v=t;v=v.parentNode;)1===v.nodeType&&q.push({element:v,left:v.scrollLeft,top:v.scrollTop});"function"===typeof t.focus&&t.focus();for(t=
0;t<q.length;t++)v=q[t],v.element.scrollLeft=v.left,v.element.scrollTop=v.top}fd=!!kf;lf=kf=null;a.current=c;Z=d;do try{for(t=a;null!==Z;){var K=Z.flags;K&36&&Yi(t,Z.alternate,Z);if(K&128){q=void 0;var Q=Z.ref;if(null!==Q){var L=Z.stateNode;switch(Z.tag){case 5:q=L;break;default:q=L}"function"===typeof Q?Q(q):Q.current=q}}Z=Z.nextEffect}}catch(va){if(null===Z)throw Error(y(330));Wi(Z,va);Z=Z.nextEffect}while(null!==Z);Z=null;$f();X=e}else a.current=c;if(xj)xj=!1,yj=a,zj=b;else for(Z=d;null!==Z;)b=
Z.nextEffect,Z.nextEffect=null,Z.flags&8&&(K=Z,K.sibling=null,K.stateNode=null),Z=b;d=a.pendingLanes;0===d&&(Ti=null);1===d?a===Ej?Dj++:(Dj=0,Ej=a):Dj=0;c=c.stateNode;if(Mf&&"function"===typeof Mf.onCommitFiberRoot)try{Mf.onCommitFiberRoot(Lf,c,void 0,64===(c.current.flags&64))}catch(va){}Mj(a,O());if(Qi)throw Qi=!1,a=Ri,Ri=null,a;if(0!==(X&8))return null;ig();return null}
function ek(){for(;null!==Z;){var a=Z.alternate;Jj||null===Ij||(0!==(Z.flags&8)?dc(Z,Ij)&&(Jj=!0):13===Z.tag&&mj(a,Z)&&dc(Z,Ij)&&(Jj=!0));var b=Z.flags;0!==(b&256)&&Xi(a,Z);0===(b&512)||xj||(xj=!0,hg(97,function(){Oj();return null}));Z=Z.nextEffect}}function Oj(){if(90!==zj){var a=97<zj?97:zj;zj=90;return gg(a,fk)}return!1}function $i(a,b){Aj.push(b,a);xj||(xj=!0,hg(97,function(){Oj();return null}))}function Zi(a,b){Bj.push(b,a);xj||(xj=!0,hg(97,function(){Oj();return null}))}
function fk(){if(null===yj)return!1;var a=yj;yj=null;if(0!==(X&48))throw Error(y(331));var b=X;X|=32;var c=Bj;Bj=[];for(var d=0;d<c.length;d+=2){var e=c[d],f=c[d+1],g=e.destroy;e.destroy=void 0;if("function"===typeof g)try{g()}catch(k){if(null===f)throw Error(y(330));Wi(f,k)}}c=Aj;Aj=[];for(d=0;d<c.length;d+=2){e=c[d];f=c[d+1];try{var h=e.create;e.destroy=h()}catch(k){if(null===f)throw Error(y(330));Wi(f,k)}}for(h=a.current.firstEffect;null!==h;)a=h.nextEffect,h.nextEffect=null,h.flags&8&&(h.sibling=
null,h.stateNode=null),h=a;X=b;ig();return!0}function gk(a,b,c){b=Mi(c,b);b=Pi(a,b,1);Ag(a,b);b=Hg();a=Kj(a,1);null!==a&&($c(a,1,b),Mj(a,b))}
function Wi(a,b){if(3===a.tag)gk(a,a,b);else for(var c=a.return;null!==c;){if(3===c.tag){gk(c,a,b);break}else if(1===c.tag){var d=c.stateNode;if("function"===typeof c.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===Ti||!Ti.has(d))){a=Mi(b,a);var e=Si(c,a,1);Ag(c,e);e=Hg();c=Kj(c,1);if(null!==c)$c(c,1,e),Mj(c,e);else if("function"===typeof d.componentDidCatch&&(null===Ti||!Ti.has(d)))try{d.componentDidCatch(b,a)}catch(f){}break}}c=c.return}}
function Yj(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);b=Hg();a.pingedLanes|=a.suspendedLanes&c;U===a&&(W&c)===c&&(4===V||3===V&&(W&62914560)===W&&500>O()-jj?Qj(a,0):uj|=c);Mj(a,b)}function lj(a,b){var c=a.stateNode;null!==c&&c.delete(b);b=0;0===b&&(b=a.mode,0===(b&2)?b=1:0===(b&4)?b=99===eg()?1:2:(0===Gj&&(Gj=tj),b=Yc(62914560&~Gj),0===b&&(b=4194304)));c=Hg();a=Kj(a,b);null!==a&&($c(a,b,c),Mj(a,c))}var ck;
ck=function(a,b,c){var d=b.lanes;if(null!==a)if(a.memoizedProps!==b.pendingProps||N.current)ug=!0;else if(0!==(c&d))ug=0!==(a.flags&16384)?!0:!1;else{ug=!1;switch(b.tag){case 3:ri(b);sh();break;case 5:gh(b);break;case 1:Ff(b.type)&&Jf(b);break;case 4:eh(b,b.stateNode.containerInfo);break;case 10:d=b.memoizedProps.value;var e=b.type._context;I(mg,e._currentValue);e._currentValue=d;break;case 13:if(null!==b.memoizedState){if(0!==(c&b.child.childLanes))return ti(a,b,c);I(P,P.current&1);b=hi(a,b,c);return null!==
b?b.sibling:null}I(P,P.current&1);break;case 19:d=0!==(c&b.childLanes);if(0!==(a.flags&64)){if(d)return Ai(a,b,c);b.flags|=64}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null,e.lastEffect=null);I(P,P.current);if(d)break;else return null;case 23:case 24:return b.lanes=0,mi(a,b,c)}return hi(a,b,c)}else ug=!1;b.lanes=0;switch(b.tag){case 2:d=b.type;null!==a&&(a.alternate=null,b.alternate=null,b.flags|=2);a=b.pendingProps;e=Ef(b,M.current);tg(b,c);e=Ch(null,b,d,a,e,c);b.flags|=1;if("object"===
typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof){b.tag=1;b.memoizedState=null;b.updateQueue=null;if(Ff(d)){var f=!0;Jf(b)}else f=!1;b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null;xg(b);var g=d.getDerivedStateFromProps;"function"===typeof g&&Gg(b,d,g,a);e.updater=Kg;b.stateNode=e;e._reactInternals=b;Og(b,d,a,c);b=qi(null,b,d,!0,f,c)}else b.tag=0,fi(null,b,e,c),b=b.child;return b;case 16:e=b.elementType;a:{null!==a&&(a.alternate=null,b.alternate=null,b.flags|=2);
a=b.pendingProps;f=e._init;e=f(e._payload);b.type=e;f=b.tag=hk(e);a=lg(e,a);switch(f){case 0:b=li(null,b,e,a,c);break a;case 1:b=pi(null,b,e,a,c);break a;case 11:b=gi(null,b,e,a,c);break a;case 14:b=ii(null,b,e,lg(e.type,a),d,c);break a}throw Error(y(306,e,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:lg(d,e),li(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:lg(d,e),pi(a,b,d,e,c);case 3:ri(b);d=b.updateQueue;if(null===a||null===d)throw Error(y(282));
d=b.pendingProps;e=b.memoizedState;e=null!==e?e.element:null;yg(a,b);Cg(b,d,null,c);d=b.memoizedState.element;if(d===e)sh(),b=hi(a,b,c);else{e=b.stateNode;if(f=e.hydrate)kh=rf(b.stateNode.containerInfo.firstChild),jh=b,f=lh=!0;if(f){a=e.mutableSourceEagerHydrationData;if(null!=a)for(e=0;e<a.length;e+=2)f=a[e],f._workInProgressVersionPrimary=a[e+1],th.push(f);c=Zg(b,null,d,c);for(b.child=c;c;)c.flags=c.flags&-3|1024,c=c.sibling}else fi(a,b,d,c),sh();b=b.child}return b;case 5:return gh(b),null===a&&
ph(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:null,g=e.children,nf(d,e)?g=null:null!==f&&nf(d,f)&&(b.flags|=16),oi(a,b),fi(a,b,g,c),b.child;case 6:return null===a&&ph(b),null;case 13:return ti(a,b,c);case 4:return eh(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=Yg(b,null,d,c):fi(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:lg(d,e),gi(a,b,d,e,c);case 7:return fi(a,b,b.pendingProps,c),b.child;case 8:return fi(a,b,b.pendingProps.children,
c),b.child;case 12:return fi(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;g=b.memoizedProps;f=e.value;var h=b.type._context;I(mg,h._currentValue);h._currentValue=f;if(null!==g)if(h=g.value,f=He(h,f)?0:("function"===typeof d._calculateChangedBits?d._calculateChangedBits(h,f):1073741823)|0,0===f){if(g.children===e.children&&!N.current){b=hi(a,b,c);break a}}else for(h=b.child,null!==h&&(h.return=b);null!==h;){var k=h.dependencies;if(null!==k){g=h.child;for(var l=
k.firstContext;null!==l;){if(l.context===d&&0!==(l.observedBits&f)){1===h.tag&&(l=zg(-1,c&-c),l.tag=2,Ag(h,l));h.lanes|=c;l=h.alternate;null!==l&&(l.lanes|=c);sg(h.return,c);k.lanes|=c;break}l=l.next}}else g=10===h.tag?h.type===b.type?null:h.child:h.child;if(null!==g)g.return=h;else for(g=h;null!==g;){if(g===b){g=null;break}h=g.sibling;if(null!==h){h.return=g.return;g=h;break}g=g.return}h=g}fi(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,f=b.pendingProps,d=f.children,tg(b,c),e=vg(e,
f.unstable_observedBits),d=d(e),b.flags|=1,fi(a,b,d,c),b.child;case 14:return e=b.type,f=lg(e,b.pendingProps),f=lg(e.type,f),ii(a,b,e,f,d,c);case 15:return ki(a,b,b.type,b.pendingProps,d,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:lg(d,e),null!==a&&(a.alternate=null,b.alternate=null,b.flags|=2),b.tag=1,Ff(d)?(a=!0,Jf(b)):a=!1,tg(b,c),Mg(b,d,e),Og(b,d,e,c),qi(null,b,d,!0,a,c);case 19:return Ai(a,b,c);case 23:return mi(a,b,c);case 24:return mi(a,b,c)}throw Error(y(156,b.tag));
};function ik(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.flags=0;this.lastEffect=this.firstEffect=this.nextEffect=null;this.childLanes=this.lanes=0;this.alternate=null}function nh(a,b,c,d){return new ik(a,b,c,d)}function ji(a){a=a.prototype;return!(!a||!a.isReactComponent)}
function hk(a){if("function"===typeof a)return ji(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===Aa)return 11;if(a===Da)return 14}return 2}
function Tg(a,b){var c=a.alternate;null===c?(c=nh(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.type=a.type,c.flags=0,c.nextEffect=null,c.firstEffect=null,c.lastEffect=null);c.childLanes=a.childLanes;c.lanes=a.lanes;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{lanes:b.lanes,firstContext:b.firstContext};
c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}
function Vg(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)ji(a)&&(g=1);else if("string"===typeof a)g=5;else a:switch(a){case ua:return Xg(c.children,e,f,b);case Ha:g=8;e|=16;break;case wa:g=8;e|=1;break;case xa:return a=nh(12,c,b,e|8),a.elementType=xa,a.type=xa,a.lanes=f,a;case Ba:return a=nh(13,c,b,e),a.type=Ba,a.elementType=Ba,a.lanes=f,a;case Ca:return a=nh(19,c,b,e),a.elementType=Ca,a.lanes=f,a;case Ia:return vi(c,e,f,b);case Ja:return a=nh(24,c,b,e),a.elementType=Ja,a.lanes=f,a;default:if("object"===
typeof a&&null!==a)switch(a.$$typeof){case ya:g=10;break a;case za:g=9;break a;case Aa:g=11;break a;case Da:g=14;break a;case Ea:g=16;d=null;break a;case Fa:g=22;break a}throw Error(y(130,null==a?a:typeof a,""));}b=nh(g,c,b,e);b.elementType=a;b.type=d;b.lanes=f;return b}function Xg(a,b,c,d){a=nh(7,a,d,b);a.lanes=c;return a}function vi(a,b,c,d){a=nh(23,a,d,b);a.elementType=Ia;a.lanes=c;return a}function Ug(a,b,c){a=nh(6,a,null,b);a.lanes=c;return a}
function Wg(a,b,c){b=nh(4,null!==a.children?a.children:[],a.key,b);b.lanes=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}
function jk(a,b,c){this.tag=b;this.containerInfo=a;this.finishedWork=this.pingCache=this.current=this.pendingChildren=null;this.timeoutHandle=-1;this.pendingContext=this.context=null;this.hydrate=c;this.callbackNode=null;this.callbackPriority=0;this.eventTimes=Zc(0);this.expirationTimes=Zc(-1);this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0;this.entanglements=Zc(0);this.mutableSourceEagerHydrationData=null}
function kk(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:ta,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}
function lk(a,b,c,d){var e=b.current,f=Hg(),g=Ig(e);a:if(c){c=c._reactInternals;b:{if(Zb(c)!==c||1!==c.tag)throw Error(y(170));var h=c;do{switch(h.tag){case 3:h=h.stateNode.context;break b;case 1:if(Ff(h.type)){h=h.stateNode.__reactInternalMemoizedMergedChildContext;break b}}h=h.return}while(null!==h);throw Error(y(171));}if(1===c.tag){var k=c.type;if(Ff(k)){c=If(c,k,h);break a}}c=h}else c=Cf;null===b.context?b.context=c:b.pendingContext=c;b=zg(f,g);b.payload={element:a};d=void 0===d?null:d;null!==
d&&(b.callback=d);Ag(e,b);Jg(e,g,f);return g}function mk(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function nk(a,b){a=a.memoizedState;if(null!==a&&null!==a.dehydrated){var c=a.retryLane;a.retryLane=0!==c&&c<b?c:b}}function ok(a,b){nk(a,b);(a=a.alternate)&&nk(a,b)}function pk(){return null}
function qk(a,b,c){var d=null!=c&&null!=c.hydrationOptions&&c.hydrationOptions.mutableSources||null;c=new jk(a,b,null!=c&&!0===c.hydrate);b=nh(3,null,null,2===b?7:1===b?3:0);c.current=b;b.stateNode=c;xg(b);a[ff]=c.current;cf(8===a.nodeType?a.parentNode:a);if(d)for(a=0;a<d.length;a++){b=d[a];var e=b._getVersion;e=e(b._source);null==c.mutableSourceEagerHydrationData?c.mutableSourceEagerHydrationData=[b,e]:c.mutableSourceEagerHydrationData.push(b,e)}this._internalRoot=c}
qk.prototype.render=function(a){lk(a,this._internalRoot,null,null)};qk.prototype.unmount=function(){var a=this._internalRoot,b=a.containerInfo;lk(null,a,null,function(){b[ff]=null})};function rk(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}
function sk(a,b){b||(b=a?9===a.nodeType?a.documentElement:a.firstChild:null,b=!(!b||1!==b.nodeType||!b.hasAttribute("data-reactroot")));if(!b)for(var c;c=a.lastChild;)a.removeChild(c);return new qk(a,0,b?{hydrate:!0}:void 0)}
function tk(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f._internalRoot;if("function"===typeof e){var h=e;e=function(){var a=mk(g);h.call(a)}}lk(b,g,a,e)}else{f=c._reactRootContainer=sk(c,d);g=f._internalRoot;if("function"===typeof e){var k=e;e=function(){var a=mk(g);k.call(a)}}Xj(function(){lk(b,g,a,e)})}return mk(g)}ec=function(a){if(13===a.tag){var b=Hg();Jg(a,4,b);ok(a,4)}};fc=function(a){if(13===a.tag){var b=Hg();Jg(a,67108864,b);ok(a,67108864)}};
gc=function(a){if(13===a.tag){var b=Hg(),c=Ig(a);Jg(a,c,b);ok(a,c)}};hc=function(a,b){return b()};
yb=function(a,b,c){switch(b){case "input":ab(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=Db(d);if(!e)throw Error(y(90));Wa(d);ab(d,e)}}}break;case "textarea":ib(a,c);break;case "select":b=c.value,null!=b&&fb(a,!!c.multiple,b,!1)}};Gb=Wj;
Hb=function(a,b,c,d,e){var f=X;X|=4;try{return gg(98,a.bind(null,b,c,d,e))}finally{X=f,0===X&&(wj(),ig())}};Ib=function(){0===(X&49)&&(Vj(),Oj())};Jb=function(a,b){var c=X;X|=2;try{return a(b)}finally{X=c,0===X&&(wj(),ig())}};function uk(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;if(!rk(b))throw Error(y(200));return kk(a,b,null,c)}var vk={Events:[Cb,ue,Db,Eb,Fb,Oj,{current:!1}]},wk={findFiberByHostInstance:wc,bundleType:0,version:"17.0.1",rendererPackageName:"react-dom"};
var xk={bundleType:wk.bundleType,version:wk.version,rendererPackageName:wk.rendererPackageName,rendererConfig:wk.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:ra.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=cc(a);return null===a?null:a.stateNode},findFiberByHostInstance:wk.findFiberByHostInstance||
pk,findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null};if("undefined"!==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__){var yk=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!yk.isDisabled&&yk.supportsFiber)try{Lf=yk.inject(xk),Mf=yk}catch(a){}}exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=vk;exports.createPortal=uk;
exports.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternals;if(void 0===b){if("function"===typeof a.render)throw Error(y(188));throw Error(y(268,Object.keys(a)));}a=cc(b);a=null===a?null:a.stateNode;return a};exports.flushSync=function(a,b){var c=X;if(0!==(c&48))return a(b);X|=1;try{if(a)return gg(99,a.bind(null,b))}finally{X=c,ig()}};exports.hydrate=function(a,b,c){if(!rk(b))throw Error(y(200));return tk(null,a,b,!0,c)};
exports.render=function(a,b,c){if(!rk(b))throw Error(y(200));return tk(null,a,b,!1,c)};exports.unmountComponentAtNode=function(a){if(!rk(a))throw Error(y(40));return a._reactRootContainer?(Xj(function(){tk(null,null,a,!1,function(){a._reactRootContainer=null;a[ff]=null})}),!0):!1};exports.unstable_batchedUpdates=Wj;exports.unstable_createPortal=function(a,b){return uk(a,b,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)};
exports.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!rk(c))throw Error(y(200));if(null==a||void 0===a._reactInternals)throw Error(y(38));return tk(a,b,c,!1,d)};exports.version="17.0.1";

},{"react":"ccIB","object-assign":"W2ED","scheduler":"dH6z"}],"x9tB":[function(require,module,exports) {
'use strict';

function checkDCE() {
  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function') {
    return;
  }

  if ("production" !== 'production') {
    // This branch is unreachable because this function is only called
    // in production, but the condition is true only in development.
    // Therefore if the branch is still here, dead code elimination wasn't
    // properly applied.
    // Don't change the message. React DevTools relies on it. Also make sure
    // this message doesn't occur elsewhere in this function, or it will cause
    // a false positive.
    throw new Error('^_^');
  }

  try {
    // Verify that the code above has been dead code eliminated (DCE'd).
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    // DevTools shouldn't crash React, no matter what.
    // We should still report in case we break this code.
    console.error(err);
  }
}

if ("production" === 'production') {
  // DCE check should happen before ReactDOM bundle executes so that
  // DevTools can report bad minification during injection.
  checkDCE();
  module.exports = require('./cjs/react-dom.production.min.js');
} else {
  module.exports = require('./cjs/react-dom.development.js');
}
},{"./cjs/react-dom.production.min.js":"MtQn"}],"Zcgp":[function(require,module,exports) {

},{}],"rH1J":[function(require,module,exports) {

// shim for using process in browser
var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}

function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}

(function () {
  try {
    if (typeof setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }

  try {
    if (typeof clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();

function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  } // if setTimeout wasn't available but was latter defined


  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}

function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  } // if clearTimeout wasn't available but was latter defined


  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}

var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }

  draining = false;

  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }

  if (queue.length) {
    drainQueue();
  }
}

function drainQueue() {
  if (draining) {
    return;
  }

  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;

  while (len) {
    currentQueue = queue;
    queue = [];

    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }

    queueIndex = -1;
    len = queue.length;
  }

  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}

process.nextTick = function (fun) {
  var args = new Array(arguments.length - 1);

  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }

  queue.push(new Item(fun, args));

  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}; // v8 likes predictible objects


function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}

Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};

process.title = 'browser';
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues

process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
  return [];
};

process.binding = function (name) {
  throw new Error('process.binding is not supported');
};

process.cwd = function () {
  return '/';
};

process.chdir = function (dir) {
  throw new Error('process.chdir is not supported');
};

process.umask = function () {
  return 0;
};
},{}],"FHml":[function(require,module,exports) {
var process = require("process");
// .dirname, .basename, and .extname methods are extracted from Node.js v8.11.1,
// backported and transplited with Babel, with backwards-compat fixes

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function (path) {
  if (typeof path !== 'string') path = path + '';
  if (path.length === 0) return '.';
  var code = path.charCodeAt(0);
  var hasRoot = code === 47 /*/*/;
  var end = -1;
  var matchedSlash = true;
  for (var i = path.length - 1; i >= 1; --i) {
    code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        if (!matchedSlash) {
          end = i;
          break;
        }
      } else {
      // We saw the first non-path separator
      matchedSlash = false;
    }
  }

  if (end === -1) return hasRoot ? '/' : '.';
  if (hasRoot && end === 1) {
    // return '//';
    // Backwards-compat fix:
    return '/';
  }
  return path.slice(0, end);
};

function basename(path) {
  if (typeof path !== 'string') path = path + '';

  var start = 0;
  var end = -1;
  var matchedSlash = true;
  var i;

  for (i = path.length - 1; i >= 0; --i) {
    if (path.charCodeAt(i) === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          start = i + 1;
          break;
        }
      } else if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // path component
      matchedSlash = false;
      end = i + 1;
    }
  }

  if (end === -1) return '';
  return path.slice(start, end);
}

// Uses a mixed approach for backwards-compatibility, as ext behavior changed
// in new Node.js versions, so only basename() above is backported here
exports.basename = function (path, ext) {
  var f = basename(path);
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};

exports.extname = function (path) {
  if (typeof path !== 'string') path = path + '';
  var startDot = -1;
  var startPart = 0;
  var end = -1;
  var matchedSlash = true;
  // Track the state of characters (if any) we see before our first dot and
  // after any path separator we find
  var preDotState = 0;
  for (var i = path.length - 1; i >= 0; --i) {
    var code = path.charCodeAt(i);
    if (code === 47 /*/*/) {
        // If we reached a path separator that was not part of a set of path
        // separators at the end of the string, stop now
        if (!matchedSlash) {
          startPart = i + 1;
          break;
        }
        continue;
      }
    if (end === -1) {
      // We saw the first non-path separator, mark this as the end of our
      // extension
      matchedSlash = false;
      end = i + 1;
    }
    if (code === 46 /*.*/) {
        // If this is our first dot, mark it as the start of our extension
        if (startDot === -1)
          startDot = i;
        else if (preDotState !== 1)
          preDotState = 1;
    } else if (startDot !== -1) {
      // We saw a non-dot and non-path separator before our dot, so we should
      // have a good chance at having a non-empty extension
      preDotState = -1;
    }
  }

  if (startDot === -1 || end === -1 ||
      // We saw a non-dot character immediately before the dot
      preDotState === 0 ||
      // The (right-most) trimmed path component is exactly '..'
      preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
    return '';
  }
  return path.slice(startDot, end);
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

},{"process":"rH1J"}],"bYRw":[function(require,module,exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.traverse = exports.traverseChildren = exports.defaultFilter = exports.defaultSkip = exports.getValue = exports.remove = exports.pair = exports.replace = exports.skip = void 0;
class Replace {
    constructor(items) {
        this.items = items;
    }
}
class Pair {
    constructor(key, value) {
        this.key = key;
        this.value = value;
    }
}
exports.skip = Symbol('skip');
function replace(...items) {
    return new Replace(items);
}
exports.replace = replace;
function pair(key, value) {
    return new Pair(key, value);
}
exports.pair = pair;
exports.remove = Object.freeze(new Replace(Object.freeze([])));
const nochanges = Object.freeze({});
// key value pairs in the Replace ??? or something else?
//  Array => value
//  Object => Pair(key, value)
//  Map => Pair(key, value)
//  Set => value
const objectContainerHelper = {
    type: "Object",
    patch(original, newValues) {
        let ctor = original.constructor;
        let iterateValues = { ...original };
        for (let key in newValues) {
            iterateValues[key] = newValues[key];
        }
        let values = {};
        function setValue(name, value) {
            if (value instanceof Pair) {
                values[value.key] = value.value;
            }
            else {
                values[name] = value;
            }
        }
        for (let name in iterateValues) {
            let value = iterateValues[name];
            if (value instanceof Replace) {
                for (let item of value.items) {
                    setValue(item.key, item.value);
                }
            }
            else {
                setValue(name, value);
            }
        }
        return ctor === Object ? values : new ctor(values);
    },
    *keys(container) {
        for (let key in container) {
            if (!key.startsWith("_")) {
                yield key;
            }
        }
    },
    getValue(container, key) {
        return container[key];
    },
};
const arrayContainerHelper = {
    ...objectContainerHelper,
    type: "Array",
    patch(original, newValues) {
        let values = [...original];
        for (let key in newValues) {
            values[key] = newValues[key];
        }
        let newContainer = [];
        for (let value of values) {
            if (value instanceof Replace) {
                for (let item of value.items) {
                    newContainer.push(item);
                }
            }
            else {
                newContainer.push(value);
            }
        }
        return newContainer;
    },
    keys(container) {
        return container.keys();
    },
    getValue(container, key) {
        return container[key];
    },
};
const mapContainerHelper = {
    ...objectContainerHelper,
    type: "Map",
    patch(original, newValues) {
        let iterateMap = new Map(original.entries());
        for (let key in newValues) {
            iterateMap.set(key, newValues[key]);
        }
        let newMap = new Map();
        function setValue(name, value) {
            if (value instanceof Pair) {
                newMap.set(value.key, value.value);
            }
            else {
                newMap.set(name, value);
            }
        }
        for (let name of iterateMap.keys()) {
            let value = iterateMap.get(name);
            if (value instanceof Replace) {
                for (let item of value.items) {
                    setValue(item.key, item.value);
                }
            }
            else {
                setValue(name, value);
            }
        }
        return newMap;
    },
    keys(container) {
        return container.keys();
    },
    getValue(container, key) {
        return container.get(key);
    },
};
function getContainerHelper(node) {
    if (node != null) {
        if (Array.isArray(node)) {
            return arrayContainerHelper;
        }
        if (node instanceof Map) {
            return mapContainerHelper;
        }
        if (typeof node === "object") {
            return objectContainerHelper;
        }
    }
    return null;
}
function getValue(container, key) {
    return getContainerHelper(container).getValue(container, key);
}
exports.getValue = getValue;
function defaultSkip(node) {
    return node instanceof Set;
}
exports.defaultSkip = defaultSkip;
function defaultFilter(node) {
    return node != null && typeof node === "object" && !Array.isArray(node) && !(node instanceof Map);
}
exports.defaultFilter = defaultFilter;
// How do we know to skip some objects like raw objects? without knowing about Node.is?
function traverseChildren(container, visitor, ancestors = [], path = [], merge) {
    const helper = getContainerHelper(container);
    if (helper != null) {
        let changes = null;
        ancestors.push(container);
        for (let key of helper.keys(container)) {
            path.push(key);
            let child = helper.getValue(container, key);
            let result = traverse(child, visitor, ancestors, path);
            if (result === undefined) {
                result = child;
            }
            if (result !== child) {
                if (changes == null) {
                    changes = {};
                }
                changes[key] = result;
            }
            path.pop();
        }
        ancestors.pop();
        if (merge != null) {
            let result = merge(container, changes || nochanges, helper, ancestors, path);
            if (result === undefined && changes !== nochanges) {
                result = helper.patch(container, changes);
            }
            if (result !== undefined) {
                container = result;
            }
        }
        else if (changes != null) {
            container = helper.patch(container, changes);
        }
    }
    return container;
}
exports.traverseChildren = traverseChildren;
function traverse(node, visitor, ancestors = [], path = []) {
    const { enter, merge, leave, skip: _skip = defaultSkip, filter = defaultFilter } = visitor;
    if (node == null || _skip(node)) {
        return node;
    }
    const callback = filter(node);
    let enterResult = null;
    if (callback && enter != null) {
        enterResult = enter(node, ancestors, path);
    }
    if (enterResult !== exports.skip) {
        node = traverseChildren(node, visitor, ancestors, path, callback ? merge : undefined);
    }
    let leaveResult = null;
    if (callback && leave != null) {
        leaveResult = leave(node, ancestors, path);
    }
    return leaveResult || node;
}
exports.traverse = traverse;

},{}],"Zizk":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isNumber = void 0;

function isNumber(value) {
  return typeof value === "number";
}

exports.isNumber = isNumber;
},{}],"iy0N":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toString = exports.isInstance = void 0;

function isInstance(_class, instance) {
  if (instance != null) {
    let _implements = instance.constructor.implements;

    if (_implements) {
      return _implements.has(_class.id);
    }
  }

  return false;
}

exports.isInstance = isInstance;

function toString(value, b) {
  let join = b == null;

  if (b == null) {
    b = [];
  }

  if (value === null) {
    b.push("null");
  } else if (value === undefined) {
    b.push("undefined");
  } else if (typeof value === "function") {
    b.push(`function ${value.name}`);
  } else if (typeof value === "object") {
    if (Array.isArray(value)) {
      b.push("[");

      for (let element of value) {
        toString(element, b);
      }

      b.push("]");
    } else {
      b.push(value.constructor.name);
      b.push("(");
      let count = 0;

      for (let propertyName in value) {
        let propertyValue = value[propertyName];

        if (count++ > 0) {
          b.push(",");
        }

        b.push(propertyName, ":");
        toString(propertyValue, b);
      }

      b.push(")");
    }
  } else {
    b.push(JSON.stringify(value));
  }

  return join ? b.join('') : null;
}

exports.toString = toString;
},{}],"CUCB":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isPosition = exports.Position = void 0;

const Number = __importStar(require("./ion/Number"));

const Class = __importStar(require("./ion/Class"));

class Position {
  constructor(offset, line, column) {
    if (!Number.isNumber(offset)) throw new Error('offset is not a Number: ' + Class.toString(offset));
    if (!Number.isNumber(line)) throw new Error('line is not a Number: ' + Class.toString(line));
    if (!Number.isNumber(column)) throw new Error('column is not a Number: ' + Class.toString(column));
    this.offset = offset;
    this.line = line;
    this.column = column;
    Object.freeze(this);
  }

  static is(value) {
    return isPosition(value);
  }

}

exports.Position = Position;
Position.id = 'Position';
Position.implements = new Set(['Position', 'ion_Object']);

function isPosition(value) {
  return Class.isInstance(Position, value);
}

exports.isPosition = isPosition;
exports.default = Position;
},{"./ion/Number":"Zizk","./ion/Class":"iy0N"}],"CAX3":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isString = void 0;

function isString(value) {
  return typeof value === "string";
}

exports.isString = isString;
},{}],"VU7R":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isLocation = exports.Location = void 0;

const Position = __importStar(require("./Position"));

const String = __importStar(require("./ion/String"));

const Class = __importStar(require("./ion/Class"));

class Location {
  constructor({
    start,
    end,
    filename
  }) {
    if (!Position.isPosition(start)) throw new Error('start is not a Position: ' + Class.toString(start));
    if (!Position.isPosition(end)) throw new Error('end is not a Position: ' + Class.toString(end));
    if (!String.isString(filename)) throw new Error('filename is not a String: ' + Class.toString(filename));
    this.start = start;
    this.end = end;
    this.filename = filename;
    Object.freeze(this);
  }

  patch(properties) {
    return new Location({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isLocation(value);
  }

}

exports.Location = Location;
Location.id = 'Location';
Location.implements = new Set(['Location', 'ion_Object']);

function isLocation(value) {
  return Class.isInstance(Location, value);
}

exports.isLocation = isLocation;
exports.default = Location;
},{"./Position":"CUCB","./ion/String":"CAX3","./ion/Class":"iy0N"}],"ozVR":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isNull = void 0;

function isNull(value) {
  return value == null;
}

exports.isNull = isNull;
},{}],"AiNq":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isMap = void 0;

function isMap(value) {
  return value instanceof globalThis.Map;
}

exports.isMap = isMap;
},{}],"Zz3f":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isAnalysis = exports.Analysis = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Map = __importStar(require("./ion/Map"));

const Class = __importStar(require("./ion/Class"));

class Analysis {
  constructor({
    location = null,
    declarations
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!Map.isMap(declarations)) throw new Error('declarations is not a Map: ' + Class.toString(declarations));
    this.location = location;
    this.declarations = declarations;
    Object.freeze(this);
  }

  patch(properties) {
    return new Analysis({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isAnalysis(value);
  }

}

exports.Analysis = Analysis;
Analysis.id = 'Analysis';
Analysis.implements = new Set(['Analysis', 'ion_Object', 'Node']);

function isAnalysis(value) {
  return Class.isInstance(Analysis, value);
}

exports.isAnalysis = isAnalysis;
exports.default = Analysis;
},{"./Location":"VU7R","./ion/Null":"ozVR","./ion/Map":"AiNq","./ion/Class":"iy0N"}],"kwdr":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isType = exports.Type = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Class = __importStar(require("./ion/Class"));

class Type {
  constructor({
    location = null,
    type = null
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    this.location = location;
    this.type = type;
    Object.freeze(this);
  }

  patch(properties) {
    return new Type({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isType(value);
  }

}

exports.Type = Type;
Type.id = 'Type';
Type.implements = new Set(['Type', 'ion_Object', 'Expression', 'Typed', 'Node']);

function isType(value) {
  return Class.isInstance(Type, value);
}

exports.isType = isType;
exports.default = Type;
},{"./Location":"VU7R","./ion/Null":"ozVR","./ion/Class":"iy0N"}],"PpFg":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isArray = void 0;

function isArray(value) {
  return Array.isArray(value);
}

exports.isArray = isArray;
},{}],"eJLV":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isBoolean = void 0;

function isBoolean(value) {
  return typeof value === "boolean";
}

exports.isBoolean = isBoolean;
},{}],"i6OL":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isArrayExpression = exports.ArrayExpression = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const _Array = __importStar(require("./ion/Array"));

const Boolean = __importStar(require("./ion/Boolean"));

const Class = __importStar(require("./ion/Class"));

class ArrayExpression {
  constructor({
    location = null,
    type = null,
    elements,
    isSet = false
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!_Array.isArray(elements)) throw new Error('elements is not a Array: ' + Class.toString(elements));
    if (!Boolean.isBoolean(isSet)) throw new Error('isSet is not a Boolean: ' + Class.toString(isSet));
    this.location = location;
    this.type = type;
    this.elements = elements;
    this.isSet = isSet;
    Object.freeze(this);
  }

  patch(properties) {
    return new ArrayExpression({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isArrayExpression(value);
  }

}

exports.ArrayExpression = ArrayExpression;
ArrayExpression.id = 'ArrayExpression';
ArrayExpression.implements = new Set(['ArrayExpression', 'ion_Object', 'Expression', 'Typed', 'Node']);

function isArrayExpression(value) {
  return Class.isInstance(ArrayExpression, value);
}

exports.isArrayExpression = isArrayExpression;
exports.default = ArrayExpression;
},{"./Location":"VU7R","./ion/Null":"ozVR","./Type":"kwdr","./ion/Array":"PpFg","./ion/Boolean":"eJLV","./ion/Class":"iy0N"}],"WzJa":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isArrayPattern = exports.ArrayPattern = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const _Array = __importStar(require("./ion/Array"));

const Class = __importStar(require("./ion/Class"));

class ArrayPattern {
  constructor({
    location = null,
    type = null,
    elements
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!_Array.isArray(elements)) throw new Error('elements is not a Array: ' + Class.toString(elements));
    this.location = location;
    this.type = type;
    this.elements = elements;
    Object.freeze(this);
  }

  patch(properties) {
    return new ArrayPattern({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isArrayPattern(value);
  }

}

exports.ArrayPattern = ArrayPattern;
ArrayPattern.id = 'ArrayPattern';
ArrayPattern.implements = new Set(['ArrayPattern', 'ion_Object', 'Pattern', 'Typed', 'Node']);

function isArrayPattern(value) {
  return Class.isInstance(ArrayPattern, value);
}

exports.isArrayPattern = isArrayPattern;
exports.default = ArrayPattern;
},{"./Location":"VU7R","./ion/Null":"ozVR","./Type":"kwdr","./ion/Array":"PpFg","./ion/Class":"iy0N"}],"zMtI":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isExpression = exports.Expression = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const Class = __importStar(require("./ion/Class"));

class Expression {
  constructor({
    location = null,
    type = null
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    this.location = location;
    this.type = type;
    Object.freeze(this);
  }

  patch(properties) {
    return new Expression({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isExpression(value);
  }

}

exports.Expression = Expression;
Expression.id = 'Expression';
Expression.implements = new Set(['Expression', 'ion_Object', 'Typed', 'Node']);

function isExpression(value) {
  return Class.isInstance(Expression, value);
}

exports.isExpression = isExpression;
exports.default = Expression;
},{"./Location":"VU7R","./ion/Null":"ozVR","./Type":"kwdr","./ion/Class":"iy0N"}],"I4Ao":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isBlockStatement = exports.BlockStatement = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const _Array = __importStar(require("./ion/Array"));

const Class = __importStar(require("./ion/Class"));

class BlockStatement {
  constructor({
    location = null,
    type = null,
    body
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!_Array.isArray(body)) throw new Error('body is not a Array: ' + Class.toString(body));
    this.location = location;
    this.type = type;
    this.body = body;
    Object.freeze(this);
  }

  patch(properties) {
    return new BlockStatement({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isBlockStatement(value);
  }

}

exports.BlockStatement = BlockStatement;
BlockStatement.id = 'BlockStatement';
BlockStatement.implements = new Set(['BlockStatement', 'ion_Object', 'Statement', 'Scope', 'Typed', 'Node']);

function isBlockStatement(value) {
  return Class.isInstance(BlockStatement, value);
}

exports.isBlockStatement = isBlockStatement;
exports.default = BlockStatement;
},{"./Location":"VU7R","./ion/Null":"ozVR","./Type":"kwdr","./ion/Array":"PpFg","./ion/Class":"iy0N"}],"j5r3":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isArrowFunctionExpression = exports.ArrowFunctionExpression = void 0;

const Expression = __importStar(require("./Expression"));

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const _Array = __importStar(require("./ion/Array"));

const BlockStatement = __importStar(require("./BlockStatement"));

const Boolean = __importStar(require("./ion/Boolean"));

const Class = __importStar(require("./ion/Class"));

class ArrowFunctionExpression {
  constructor({
    location = null,
    type = null,
    params,
    body,
    expression
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!_Array.isArray(params)) throw new Error('params is not a Array: ' + Class.toString(params));
    if (!(BlockStatement.isBlockStatement(body) || Expression.isExpression(body))) throw new Error('body is not a BlockStatement | Expression: ' + Class.toString(body));
    if (!Boolean.isBoolean(expression)) throw new Error('expression is not a Boolean: ' + Class.toString(expression));
    this.location = location;
    this.type = type;
    this.params = params;
    this.body = body;
    this.expression = expression;
    Object.freeze(this);
  }

  patch(properties) {
    return new ArrowFunctionExpression({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isArrowFunctionExpression(value);
  }

}

exports.ArrowFunctionExpression = ArrowFunctionExpression;
ArrowFunctionExpression.id = 'ArrowFunctionExpression';
ArrowFunctionExpression.implements = new Set(['ArrowFunctionExpression', 'ion_Object', 'Expression', 'Scope', 'Typed', 'Node']);

function isArrowFunctionExpression(value) {
  return Class.isInstance(ArrowFunctionExpression, value);
}

exports.isArrowFunctionExpression = isArrowFunctionExpression;
exports.default = ArrowFunctionExpression;
},{"./Expression":"zMtI","./Location":"VU7R","./ion/Null":"ozVR","./Type":"kwdr","./ion/Array":"PpFg","./BlockStatement":"I4Ao","./ion/Boolean":"eJLV","./ion/Class":"iy0N"}],"MADx":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isAssembly = exports.Assembly = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Map = __importStar(require("./ion/Map"));

const Class = __importStar(require("./ion/Class"));

class Assembly {
  constructor({
    location = null,
    modules
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!Map.isMap(modules)) throw new Error('modules is not a Map: ' + Class.toString(modules));
    this.location = location;
    this.modules = modules;
    Object.freeze(this);
  }

  patch(properties) {
    return new Assembly({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isAssembly(value);
  }

}

exports.Assembly = Assembly;
Assembly.id = 'Assembly';
Assembly.implements = new Set(['Assembly', 'ion_Object', 'Node']);

function isAssembly(value) {
  return Class.isInstance(Assembly, value);
}

exports.isAssembly = isAssembly;
exports.default = Assembly;
},{"./Location":"VU7R","./ion/Null":"ozVR","./ion/Map":"AiNq","./ion/Class":"iy0N"}],"qBpR":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isPattern = exports.Pattern = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const Class = __importStar(require("./ion/Class"));

class Pattern {
  constructor({
    location = null,
    type = null
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    this.location = location;
    this.type = type;
    Object.freeze(this);
  }

  patch(properties) {
    return new Pattern({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isPattern(value);
  }

}

exports.Pattern = Pattern;
Pattern.id = 'Pattern';
Pattern.implements = new Set(['Pattern', 'ion_Object', 'Typed', 'Node']);

function isPattern(value) {
  return Class.isInstance(Pattern, value);
}

exports.isPattern = isPattern;
exports.default = Pattern;
},{"./Location":"VU7R","./ion/Null":"ozVR","./Type":"kwdr","./ion/Class":"iy0N"}],"gGtP":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isAssignmentPattern = exports.AssignmentPattern = void 0;

const Pattern = __importStar(require("./Pattern"));

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const Expression = __importStar(require("./Expression"));

const Class = __importStar(require("./ion/Class"));

class AssignmentPattern {
  constructor({
    location = null,
    type = null,
    left,
    right
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!Pattern.isPattern(left)) throw new Error('left is not a Pattern: ' + Class.toString(left));
    if (!Expression.isExpression(right)) throw new Error('right is not a Expression: ' + Class.toString(right));
    this.location = location;
    this.type = type;
    this.left = left;
    this.right = right;
    Object.freeze(this);
  }

  patch(properties) {
    return new AssignmentPattern({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isAssignmentPattern(value);
  }

}

exports.AssignmentPattern = AssignmentPattern;
AssignmentPattern.id = 'AssignmentPattern';
AssignmentPattern.implements = new Set(['AssignmentPattern', 'ion_Object', 'Pattern', 'Typed', 'Node']);

function isAssignmentPattern(value) {
  return Class.isInstance(AssignmentPattern, value);
}

exports.isAssignmentPattern = isAssignmentPattern;
exports.default = AssignmentPattern;
},{"./Pattern":"qBpR","./Location":"VU7R","./ion/Null":"ozVR","./Type":"kwdr","./Expression":"zMtI","./ion/Class":"iy0N"}],"IblK":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isAssignmentStatement = exports.AssignmentStatement = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const String = __importStar(require("./ion/String"));

const Pattern = __importStar(require("./Pattern"));

const Expression = __importStar(require("./Expression"));

const Class = __importStar(require("./ion/Class"));

class AssignmentStatement {
  constructor({
    location = null,
    type = null,
    operator = '=',
    left,
    right
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!String.isString(operator)) throw new Error('operator is not a String: ' + Class.toString(operator));
    if (!(Pattern.isPattern(left) || Expression.isExpression(left))) throw new Error('left is not a Pattern | Expression: ' + Class.toString(left));
    if (!Expression.isExpression(right)) throw new Error('right is not a Expression: ' + Class.toString(right));
    this.location = location;
    this.type = type;
    this.operator = operator;
    this.left = left;
    this.right = right;
    Object.freeze(this);
  }

  patch(properties) {
    return new AssignmentStatement({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isAssignmentStatement(value);
  }

}

exports.AssignmentStatement = AssignmentStatement;
AssignmentStatement.id = 'AssignmentStatement';
AssignmentStatement.implements = new Set(['AssignmentStatement', 'ion_Object', 'Statement', 'Typed', 'Node']);

function isAssignmentStatement(value) {
  return Class.isInstance(AssignmentStatement, value);
}

exports.isAssignmentStatement = isAssignmentStatement;
exports.default = AssignmentStatement;
},{"./Location":"VU7R","./ion/Null":"ozVR","./Type":"kwdr","./ion/String":"CAX3","./Pattern":"qBpR","./Expression":"zMtI","./ion/Class":"iy0N"}],"nmv9":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isAwaitExpression = exports.AwaitExpression = void 0;

const Expression = __importStar(require("./Expression"));

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const Class = __importStar(require("./ion/Class"));

class AwaitExpression {
  constructor({
    location = null,
    type = null,
    argument
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!Expression.isExpression(argument)) throw new Error('argument is not a Expression: ' + Class.toString(argument));
    this.location = location;
    this.type = type;
    this.argument = argument;
    Object.freeze(this);
  }

  patch(properties) {
    return new AwaitExpression({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isAwaitExpression(value);
  }

}

exports.AwaitExpression = AwaitExpression;
AwaitExpression.id = 'AwaitExpression';
AwaitExpression.implements = new Set(['AwaitExpression', 'ion_Object', 'Expression', 'Typed', 'Node']);

function isAwaitExpression(value) {
  return Class.isInstance(AwaitExpression, value);
}

exports.isAwaitExpression = isAwaitExpression;
exports.default = AwaitExpression;
},{"./Expression":"zMtI","./Location":"VU7R","./ion/Null":"ozVR","./Type":"kwdr","./ion/Class":"iy0N"}],"LQtK":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isBinaryExpression = exports.BinaryExpression = void 0;

const Expression = __importStar(require("./Expression"));

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const String = __importStar(require("./ion/String"));

const Class = __importStar(require("./ion/Class"));

class BinaryExpression {
  constructor({
    location = null,
    type = null,
    left,
    operator,
    right
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!Expression.isExpression(left)) throw new Error('left is not a Expression: ' + Class.toString(left));
    if (!String.isString(operator)) throw new Error('operator is not a String: ' + Class.toString(operator));
    if (!Expression.isExpression(right)) throw new Error('right is not a Expression: ' + Class.toString(right));
    this.location = location;
    this.type = type;
    this.left = left;
    this.operator = operator;
    this.right = right;
    Object.freeze(this);
  }

  patch(properties) {
    return new BinaryExpression({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isBinaryExpression(value);
  }

}

exports.BinaryExpression = BinaryExpression;
BinaryExpression.id = 'BinaryExpression';
BinaryExpression.implements = new Set(['BinaryExpression', 'ion_Object', 'Expression', 'Typed', 'Node']);

function isBinaryExpression(value) {
  return Class.isInstance(BinaryExpression, value);
}

exports.isBinaryExpression = isBinaryExpression;
exports.default = BinaryExpression;
},{"./Expression":"zMtI","./Location":"VU7R","./ion/Null":"ozVR","./Type":"kwdr","./ion/String":"CAX3","./ion/Class":"iy0N"}],"Ho18":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isBreakStatement = exports.BreakStatement = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const Class = __importStar(require("./ion/Class"));

class BreakStatement {
  constructor({
    location = null,
    type = null
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    this.location = location;
    this.type = type;
    Object.freeze(this);
  }

  patch(properties) {
    return new BreakStatement({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isBreakStatement(value);
  }

}

exports.BreakStatement = BreakStatement;
BreakStatement.id = 'BreakStatement';
BreakStatement.implements = new Set(['BreakStatement', 'ion_Object', 'Statement', 'Typed', 'Node']);

function isBreakStatement(value) {
  return Class.isInstance(BreakStatement, value);
}

exports.isBreakStatement = isBreakStatement;
exports.default = BreakStatement;
},{"./Location":"VU7R","./ion/Null":"ozVR","./Type":"kwdr","./ion/Class":"iy0N"}],"qwkJ":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isCallExpression = exports.CallExpression = void 0;

const Expression = __importStar(require("./Expression"));

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const Boolean = __importStar(require("./ion/Boolean"));

const _Array = __importStar(require("./ion/Array"));

const Class = __importStar(require("./ion/Class"));

class CallExpression {
  constructor({
    location = null,
    type = null,
    optional = false,
    new: _new = false,
    callee,
    arguments: _arguments
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!Boolean.isBoolean(optional)) throw new Error('optional is not a Boolean: ' + Class.toString(optional));
    if (!Boolean.isBoolean(_new)) throw new Error('new is not a Boolean: ' + Class.toString(_new));
    if (!Expression.isExpression(callee)) throw new Error('callee is not a Expression: ' + Class.toString(callee));
    if (!_Array.isArray(_arguments)) throw new Error('arguments is not a Array: ' + Class.toString(_arguments));
    this.location = location;
    this.type = type;
    this.optional = optional;
    this.new = _new;
    this.callee = callee;
    this.arguments = _arguments;
    Object.freeze(this);
  }

  patch(properties) {
    return new CallExpression({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isCallExpression(value);
  }

}

exports.CallExpression = CallExpression;
CallExpression.id = 'CallExpression';
CallExpression.implements = new Set(['CallExpression', 'ion_Object', 'Expression', 'ChainElement', 'Typed', 'Node']);

function isCallExpression(value) {
  return Class.isInstance(CallExpression, value);
}

exports.isCallExpression = isCallExpression;
exports.default = CallExpression;
},{"./Expression":"zMtI","./Location":"VU7R","./ion/Null":"ozVR","./Type":"kwdr","./ion/Boolean":"eJLV","./ion/Array":"PpFg","./ion/Class":"iy0N"}],"X9Am":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isCatchClause = exports.CatchClause = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Pattern = __importStar(require("./Pattern"));

const BlockStatement = __importStar(require("./BlockStatement"));

const Class = __importStar(require("./ion/Class"));

class CatchClause {
  constructor({
    location = null,
    param,
    body
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!Pattern.isPattern(param)) throw new Error('param is not a Pattern: ' + Class.toString(param));
    if (!BlockStatement.isBlockStatement(body)) throw new Error('body is not a BlockStatement: ' + Class.toString(body));
    this.location = location;
    this.param = param;
    this.body = body;
    Object.freeze(this);
  }

  patch(properties) {
    return new CatchClause({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isCatchClause(value);
  }

}

exports.CatchClause = CatchClause;
CatchClause.id = 'CatchClause';
CatchClause.implements = new Set(['CatchClause', 'ion_Object', 'Node']);

function isCatchClause(value) {
  return Class.isInstance(CatchClause, value);
}

exports.isCatchClause = isCatchClause;
exports.default = CatchClause;
},{"./Location":"VU7R","./ion/Null":"ozVR","./Pattern":"qBpR","./BlockStatement":"I4Ao","./ion/Class":"iy0N"}],"u2aQ":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isChainElement = exports.ChainElement = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Boolean = __importStar(require("./ion/Boolean"));

const Class = __importStar(require("./ion/Class"));

class ChainElement {
  constructor({
    location = null,
    optional = false
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!Boolean.isBoolean(optional)) throw new Error('optional is not a Boolean: ' + Class.toString(optional));
    this.location = location;
    this.optional = optional;
    Object.freeze(this);
  }

  patch(properties) {
    return new ChainElement({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isChainElement(value);
  }

}

exports.ChainElement = ChainElement;
ChainElement.id = 'ChainElement';
ChainElement.implements = new Set(['ChainElement', 'ion_Object', 'Node']);

function isChainElement(value) {
  return Class.isInstance(ChainElement, value);
}

exports.isChainElement = isChainElement;
exports.default = ChainElement;
},{"./Location":"VU7R","./ion/Null":"ozVR","./ion/Boolean":"eJLV","./ion/Class":"iy0N"}],"L0Jq":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isInteger = void 0;
/*
This file was generated from ion source. Do not edit.
*/

const Number = __importStar(require("./Number"));

function isInteger(value) {
  return Number.isNumber(value) && value % 1 === 0;
}

exports.isInteger = isInteger;
},{"./Number":"Zizk"}],"gz3F":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isDeclarator = exports.Declarator = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const String = __importStar(require("./ion/String"));

const Type = __importStar(require("./Type"));

const Class = __importStar(require("./ion/Class"));

class Declarator {
  constructor({
    location = null,
    name,
    path = null,
    type = null
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!String.isString(name)) throw new Error('name is not a String: ' + Class.toString(name));
    if (!(String.isString(path) || Null.isNull(path))) throw new Error('path is not a String | Null: ' + Class.toString(path));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    this.location = location;
    this.name = name;
    this.path = path;
    this.type = type;
    Object.freeze(this);
  }

  patch(properties) {
    return new Declarator({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isDeclarator(value);
  }

}

exports.Declarator = Declarator;
Declarator.id = 'Declarator';
Declarator.implements = new Set(['Declarator', 'ion_Object', 'Identifier', 'Pattern', 'Node', 'Typed']);

function isDeclarator(value) {
  return Class.isInstance(Declarator, value);
}

exports.isDeclarator = isDeclarator;
exports.default = Declarator;
},{"./Location":"VU7R","./ion/Null":"ozVR","./ion/String":"CAX3","./Type":"kwdr","./ion/Class":"iy0N"}],"m0dC":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isInstanceDeclarations = exports.InstanceDeclarations = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const _Array = __importStar(require("./ion/Array"));

const Class = __importStar(require("./ion/Class"));

class InstanceDeclarations {
  constructor({
    location = null,
    declarations
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!_Array.isArray(declarations)) throw new Error('declarations is not a Array: ' + Class.toString(declarations));
    this.location = location;
    this.declarations = declarations;
    Object.freeze(this);
  }

  patch(properties) {
    return new InstanceDeclarations({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isInstanceDeclarations(value);
  }

}

exports.InstanceDeclarations = InstanceDeclarations;
InstanceDeclarations.id = 'InstanceDeclarations';
InstanceDeclarations.implements = new Set(['InstanceDeclarations', 'ion_Object', 'Scope', 'Node']);

function isInstanceDeclarations(value) {
  return Class.isInstance(InstanceDeclarations, value);
}

exports.isInstanceDeclarations = isInstanceDeclarations;
exports.default = InstanceDeclarations;
},{"./Location":"VU7R","./ion/Null":"ozVR","./ion/Array":"PpFg","./ion/Class":"iy0N"}],"b3SL":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isClassDeclaration = exports.ClassDeclaration = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const Integer = __importStar(require("./ion/Integer"));

const Boolean = __importStar(require("./ion/Boolean"));

const Declarator = __importStar(require("./Declarator"));

const _Array = __importStar(require("./ion/Array"));

const InstanceDeclarations = __importStar(require("./InstanceDeclarations"));

const Class = __importStar(require("./ion/Class"));

class ClassDeclaration {
  constructor({
    location = null,
    type = null,
    export: _export = 0,
    isStruct = false,
    isData = false,
    id,
    parameters = [],
    baseClasses = [],
    static: _static,
    instance,
    instanceType = null
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!Integer.isInteger(_export)) throw new Error('export is not a Integer: ' + Class.toString(_export));
    if (!Boolean.isBoolean(isStruct)) throw new Error('isStruct is not a Boolean: ' + Class.toString(isStruct));
    if (!Boolean.isBoolean(isData)) throw new Error('isData is not a Boolean: ' + Class.toString(isData));
    if (!Declarator.isDeclarator(id)) throw new Error('id is not a Declarator: ' + Class.toString(id));
    if (!_Array.isArray(parameters)) throw new Error('parameters is not a Array: ' + Class.toString(parameters));
    if (!_Array.isArray(baseClasses)) throw new Error('baseClasses is not a Array: ' + Class.toString(baseClasses));
    if (!_Array.isArray(_static)) throw new Error('static is not a Array: ' + Class.toString(_static));
    if (!InstanceDeclarations.isInstanceDeclarations(instance)) throw new Error('instance is not a InstanceDeclarations: ' + Class.toString(instance));
    if (!(Type.isType(instanceType) || Null.isNull(instanceType))) throw new Error('instanceType is not a Type | Null: ' + Class.toString(instanceType));
    this.location = location;
    this.type = type;
    this.export = _export;
    this.isStruct = isStruct;
    this.isData = isData;
    this.id = id;
    this.parameters = parameters;
    this.baseClasses = baseClasses;
    this.static = _static;
    this.instance = instance;
    this.instanceType = instanceType;
    Object.freeze(this);
  }

  patch(properties) {
    return new ClassDeclaration({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isClassDeclaration(value);
  }

}

exports.ClassDeclaration = ClassDeclaration;
ClassDeclaration.id = 'ClassDeclaration';
ClassDeclaration.implements = new Set(['ClassDeclaration', 'ion_Object', 'Declaration', 'Expression', 'Statement', 'Exportable', 'Typed', 'Node']);

function isClassDeclaration(value) {
  return Class.isInstance(ClassDeclaration, value);
}

exports.isClassDeclaration = isClassDeclaration;
exports.default = ClassDeclaration;
},{"./Location":"VU7R","./ion/Null":"ozVR","./Type":"kwdr","./ion/Integer":"L0Jq","./ion/Boolean":"eJLV","./Declarator":"gz3F","./ion/Array":"PpFg","./InstanceDeclarations":"m0dC","./ion/Class":"iy0N"}],"lIID":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isIdentifier = exports.Identifier = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const String = __importStar(require("./ion/String"));

const Class = __importStar(require("./ion/Class"));

class Identifier {
  constructor({
    location = null,
    name,
    path = null
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!String.isString(name)) throw new Error('name is not a String: ' + Class.toString(name));
    if (!(String.isString(path) || Null.isNull(path))) throw new Error('path is not a String | Null: ' + Class.toString(path));
    this.location = location;
    this.name = name;
    this.path = path;
    Object.freeze(this);
  }

  patch(properties) {
    return new Identifier({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isIdentifier(value);
  }

}

exports.Identifier = Identifier;
Identifier.id = 'Identifier';
Identifier.implements = new Set(['Identifier', 'ion_Object', 'Node']);

function isIdentifier(value) {
  return Class.isInstance(Identifier, value);
}

exports.isIdentifier = isIdentifier;
exports.default = Identifier;
},{"./Location":"VU7R","./ion/Null":"ozVR","./ion/String":"CAX3","./ion/Class":"iy0N"}],"tYb2":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isConditionalDeclaration = exports.ConditionalDeclaration = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const Pattern = __importStar(require("./Pattern"));

const Expression = __importStar(require("./Expression"));

const Integer = __importStar(require("./ion/Integer"));

const String = __importStar(require("./ion/String"));

const Identifier = __importStar(require("./Identifier"));

const Boolean = __importStar(require("./ion/Boolean"));

const Class = __importStar(require("./ion/Class"));

class ConditionalDeclaration {
  constructor({
    location = null,
    type = null,
    id,
    value = null,
    export: _export = 0,
    kind,
    static: _static = null,
    instance = false,
    negate = false
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!(Pattern.isPattern(id) || Expression.isExpression(id))) throw new Error('id is not a Pattern | Expression: ' + Class.toString(id));
    if (!(Expression.isExpression(value) || Null.isNull(value))) throw new Error('value is not a Expression | Null: ' + Class.toString(value));
    if (!Integer.isInteger(_export)) throw new Error('export is not a Integer: ' + Class.toString(_export));
    if (!String.isString(kind)) throw new Error('kind is not a String: ' + Class.toString(kind));
    if (!(Identifier.isIdentifier(_static) || Null.isNull(_static))) throw new Error('static is not a Identifier | Null: ' + Class.toString(_static));
    if (!Boolean.isBoolean(instance)) throw new Error('instance is not a Boolean: ' + Class.toString(instance));
    if (!Boolean.isBoolean(negate)) throw new Error('negate is not a Boolean: ' + Class.toString(negate));
    this.location = location;
    this.type = type;
    this.id = id;
    this.value = value;
    this.export = _export;
    this.kind = kind;
    this.static = _static;
    this.instance = instance;
    this.negate = negate;
    Object.freeze(this);
  }

  patch(properties) {
    return new ConditionalDeclaration({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isConditionalDeclaration(value);
  }

}

exports.ConditionalDeclaration = ConditionalDeclaration;
ConditionalDeclaration.id = 'ConditionalDeclaration';
ConditionalDeclaration.implements = new Set(['ConditionalDeclaration', 'ion_Object', 'VariableDeclaration', 'Variable', 'Declaration', 'Typed', 'Node', 'Statement', 'Exportable']);

function isConditionalDeclaration(value) {
  return Class.isInstance(ConditionalDeclaration, value);
}

exports.isConditionalDeclaration = isConditionalDeclaration;
exports.default = ConditionalDeclaration;
},{"./Location":"VU7R","./ion/Null":"ozVR","./Type":"kwdr","./Pattern":"qBpR","./Expression":"zMtI","./ion/Integer":"L0Jq","./ion/String":"CAX3","./Identifier":"lIID","./ion/Boolean":"eJLV","./ion/Class":"iy0N"}],"iQCi":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isConditionalExpression = exports.ConditionalExpression = void 0;

const Expression = __importStar(require("./Expression"));

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const Class = __importStar(require("./ion/Class"));

class ConditionalExpression {
  constructor({
    location = null,
    type = null,
    test,
    consequent,
    alternate
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!Expression.isExpression(test)) throw new Error('test is not a Expression: ' + Class.toString(test));
    if (!Expression.isExpression(consequent)) throw new Error('consequent is not a Expression: ' + Class.toString(consequent));
    if (!Expression.isExpression(alternate)) throw new Error('alternate is not a Expression: ' + Class.toString(alternate));
    this.location = location;
    this.type = type;
    this.test = test;
    this.consequent = consequent;
    this.alternate = alternate;
    Object.freeze(this);
  }

  patch(properties) {
    return new ConditionalExpression({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isConditionalExpression(value);
  }

}

exports.ConditionalExpression = ConditionalExpression;
ConditionalExpression.id = 'ConditionalExpression';
ConditionalExpression.implements = new Set(['ConditionalExpression', 'ion_Object', 'Expression', 'Typed', 'Node']);

function isConditionalExpression(value) {
  return Class.isInstance(ConditionalExpression, value);
}

exports.isConditionalExpression = isConditionalExpression;
exports.default = ConditionalExpression;
},{"./Expression":"zMtI","./Location":"VU7R","./ion/Null":"ozVR","./Type":"kwdr","./ion/Class":"iy0N"}],"fi0y":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isContinueStatement = exports.ContinueStatement = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const Class = __importStar(require("./ion/Class"));

class ContinueStatement {
  constructor({
    location = null,
    type = null
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    this.location = location;
    this.type = type;
    Object.freeze(this);
  }

  patch(properties) {
    return new ContinueStatement({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isContinueStatement(value);
  }

}

exports.ContinueStatement = ContinueStatement;
ContinueStatement.id = 'ContinueStatement';
ContinueStatement.implements = new Set(['ContinueStatement', 'ion_Object', 'Statement', 'Typed', 'Node']);

function isContinueStatement(value) {
  return Class.isInstance(ContinueStatement, value);
}

exports.isContinueStatement = isContinueStatement;
exports.default = ContinueStatement;
},{"./Location":"VU7R","./ion/Null":"ozVR","./Type":"kwdr","./ion/Class":"iy0N"}],"Ih7j":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isDeclaration = exports.Declaration = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const Integer = __importStar(require("./ion/Integer"));

const Class = __importStar(require("./ion/Class"));

class Declaration {
  constructor({
    location = null,
    type = null,
    export: _export = 0
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!Integer.isInteger(_export)) throw new Error('export is not a Integer: ' + Class.toString(_export));
    this.location = location;
    this.type = type;
    this.export = _export;
    Object.freeze(this);
  }

  patch(properties) {
    return new Declaration({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isDeclaration(value);
  }

}

exports.Declaration = Declaration;
Declaration.id = 'Declaration';
Declaration.implements = new Set(['Declaration', 'ion_Object', 'Statement', 'Exportable', 'Typed', 'Node']);

function isDeclaration(value) {
  return Class.isInstance(Declaration, value);
}

exports.isDeclaration = isDeclaration;
exports.default = Declaration;
},{"./Location":"VU7R","./ion/Null":"ozVR","./Type":"kwdr","./ion/Integer":"L0Jq","./ion/Class":"iy0N"}],"qkdi":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isDotExpression = exports.DotExpression = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const Class = __importStar(require("./ion/Class"));

class DotExpression {
  constructor({
    location = null,
    type = null
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    this.location = location;
    this.type = type;
    Object.freeze(this);
  }

  patch(properties) {
    return new DotExpression({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isDotExpression(value);
  }

}

exports.DotExpression = DotExpression;
DotExpression.id = 'DotExpression';
DotExpression.implements = new Set(['DotExpression', 'ion_Object', 'Expression', 'Typed', 'Node']);

function isDotExpression(value) {
  return Class.isInstance(DotExpression, value);
}

exports.isDotExpression = isDotExpression;
exports.default = DotExpression;
},{"./Location":"VU7R","./ion/Null":"ozVR","./Type":"kwdr","./ion/Class":"iy0N"}],"BWYI":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isElementExpression = exports.ElementExpression = void 0;

const Expression = __importStar(require("./Expression"));

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const _Array = __importStar(require("./ion/Array"));

const Class = __importStar(require("./ion/Class"));

class ElementExpression {
  constructor({
    location = null,
    type = null,
    kind,
    close = null,
    properties,
    children
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!Expression.isExpression(kind)) throw new Error('kind is not a Expression: ' + Class.toString(kind));
    if (!(Expression.isExpression(close) || Null.isNull(close))) throw new Error('close is not a Expression | Null: ' + Class.toString(close));
    if (!_Array.isArray(properties)) throw new Error('properties is not a Array: ' + Class.toString(properties));
    if (!_Array.isArray(children)) throw new Error('children is not a Array: ' + Class.toString(children));
    this.location = location;
    this.type = type;
    this.kind = kind;
    this.close = close;
    this.properties = properties;
    this.children = children;
    Object.freeze(this);
  }

  patch(properties) {
    return new ElementExpression({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isElementExpression(value);
  }

}

exports.ElementExpression = ElementExpression;
ElementExpression.id = 'ElementExpression';
ElementExpression.implements = new Set(['ElementExpression', 'ion_Object', 'Expression', 'Typed', 'Node']);

function isElementExpression(value) {
  return Class.isInstance(ElementExpression, value);
}

exports.isElementExpression = isElementExpression;
exports.default = ElementExpression;
},{"./Expression":"zMtI","./Location":"VU7R","./ion/Null":"ozVR","./Type":"kwdr","./ion/Array":"PpFg","./ion/Class":"iy0N"}],"Kv8W":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isExportable = exports.Exportable = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Integer = __importStar(require("./ion/Integer"));

const Class = __importStar(require("./ion/Class"));

class Exportable {
  constructor({
    location = null,
    export: _export = 0
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!Integer.isInteger(_export)) throw new Error('export is not a Integer: ' + Class.toString(_export));
    this.location = location;
    this.export = _export;
    Object.freeze(this);
  }

  patch(properties) {
    return new Exportable({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isExportable(value);
  }

}

exports.Exportable = Exportable;
Exportable.id = 'Exportable';
Exportable.implements = new Set(['Exportable', 'ion_Object', 'Node']);

function isExportable(value) {
  return Class.isInstance(Exportable, value);
}

exports.isExportable = isExportable;
exports.default = Exportable;
},{"./Location":"VU7R","./ion/Null":"ozVR","./ion/Integer":"L0Jq","./ion/Class":"iy0N"}],"xOhy":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isSpreadElement = exports.SpreadElement = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Expression = __importStar(require("./Expression"));

const Class = __importStar(require("./ion/Class"));

class SpreadElement {
  constructor({
    location = null,
    argument
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!Expression.isExpression(argument)) throw new Error('argument is not a Expression: ' + Class.toString(argument));
    this.location = location;
    this.argument = argument;
    Object.freeze(this);
  }

  patch(properties) {
    return new SpreadElement({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isSpreadElement(value);
  }

}

exports.SpreadElement = SpreadElement;
SpreadElement.id = 'SpreadElement';
SpreadElement.implements = new Set(['SpreadElement', 'ion_Object', 'Node']);

function isSpreadElement(value) {
  return Class.isInstance(SpreadElement, value);
}

exports.isSpreadElement = isSpreadElement;
exports.default = SpreadElement;
},{"./Location":"VU7R","./ion/Null":"ozVR","./Expression":"zMtI","./ion/Class":"iy0N"}],"jtwp":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isExpressionStatement = exports.ExpressionStatement = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const Expression = __importStar(require("./Expression"));

const SpreadElement = __importStar(require("./SpreadElement"));

const Class = __importStar(require("./ion/Class"));

class ExpressionStatement {
  constructor({
    location = null,
    type = null,
    expression
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!(Expression.isExpression(expression) || SpreadElement.isSpreadElement(expression))) throw new Error('expression is not a Expression | SpreadElement: ' + Class.toString(expression));
    this.location = location;
    this.type = type;
    this.expression = expression;
    Object.freeze(this);
  }

  patch(properties) {
    return new ExpressionStatement({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isExpressionStatement(value);
  }

}

exports.ExpressionStatement = ExpressionStatement;
ExpressionStatement.id = 'ExpressionStatement';
ExpressionStatement.implements = new Set(['ExpressionStatement', 'ion_Object', 'Statement', 'Typed', 'Node']);

function isExpressionStatement(value) {
  return Class.isInstance(ExpressionStatement, value);
}

exports.isExpressionStatement = isExpressionStatement;
exports.default = ExpressionStatement;
},{"./Location":"VU7R","./ion/Null":"ozVR","./Type":"kwdr","./Expression":"zMtI","./SpreadElement":"xOhy","./ion/Class":"iy0N"}],"KDXm":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isVariableDeclaration = exports.VariableDeclaration = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const Pattern = __importStar(require("./Pattern"));

const Expression = __importStar(require("./Expression"));

const Integer = __importStar(require("./ion/Integer"));

const String = __importStar(require("./ion/String"));

const Identifier = __importStar(require("./Identifier"));

const Boolean = __importStar(require("./ion/Boolean"));

const Class = __importStar(require("./ion/Class"));

class VariableDeclaration {
  constructor({
    location = null,
    type = null,
    id,
    value = null,
    export: _export = 0,
    kind,
    static: _static = null,
    instance = false
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!(Pattern.isPattern(id) || Expression.isExpression(id))) throw new Error('id is not a Pattern | Expression: ' + Class.toString(id));
    if (!(Expression.isExpression(value) || Null.isNull(value))) throw new Error('value is not a Expression | Null: ' + Class.toString(value));
    if (!Integer.isInteger(_export)) throw new Error('export is not a Integer: ' + Class.toString(_export));
    if (!String.isString(kind)) throw new Error('kind is not a String: ' + Class.toString(kind));
    if (!(Identifier.isIdentifier(_static) || Null.isNull(_static))) throw new Error('static is not a Identifier | Null: ' + Class.toString(_static));
    if (!Boolean.isBoolean(instance)) throw new Error('instance is not a Boolean: ' + Class.toString(instance));
    this.location = location;
    this.type = type;
    this.id = id;
    this.value = value;
    this.export = _export;
    this.kind = kind;
    this.static = _static;
    this.instance = instance;
    Object.freeze(this);
  }

  patch(properties) {
    return new VariableDeclaration({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isVariableDeclaration(value);
  }

}

exports.VariableDeclaration = VariableDeclaration;
VariableDeclaration.id = 'VariableDeclaration';
VariableDeclaration.implements = new Set(['VariableDeclaration', 'ion_Object', 'Variable', 'Declaration', 'Typed', 'Node', 'Statement', 'Exportable']);

function isVariableDeclaration(value) {
  return Class.isInstance(VariableDeclaration, value);
}

exports.isVariableDeclaration = isVariableDeclaration;
exports.default = VariableDeclaration;
},{"./Location":"VU7R","./ion/Null":"ozVR","./Type":"kwdr","./Pattern":"qBpR","./Expression":"zMtI","./ion/Integer":"L0Jq","./ion/String":"CAX3","./Identifier":"lIID","./ion/Boolean":"eJLV","./ion/Class":"iy0N"}],"k7LE":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isForOfStatement = exports.ForOfStatement = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const VariableDeclaration = __importStar(require("./VariableDeclaration"));

const Expression = __importStar(require("./Expression"));

const BlockStatement = __importStar(require("./BlockStatement"));

const Class = __importStar(require("./ion/Class"));

class ForOfStatement {
  constructor({
    location = null,
    type = null,
    left,
    right,
    body
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!VariableDeclaration.isVariableDeclaration(left)) throw new Error('left is not a VariableDeclaration: ' + Class.toString(left));
    if (!Expression.isExpression(right)) throw new Error('right is not a Expression: ' + Class.toString(right));
    if (!BlockStatement.isBlockStatement(body)) throw new Error('body is not a BlockStatement: ' + Class.toString(body));
    this.location = location;
    this.type = type;
    this.left = left;
    this.right = right;
    this.body = body;
    Object.freeze(this);
  }

  patch(properties) {
    return new ForOfStatement({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isForOfStatement(value);
  }

}

exports.ForOfStatement = ForOfStatement;
ForOfStatement.id = 'ForOfStatement';
ForOfStatement.implements = new Set(['ForOfStatement', 'ion_Object', 'Statement', 'Typed', 'Node']);

function isForOfStatement(value) {
  return Class.isInstance(ForOfStatement, value);
}

exports.isForOfStatement = isForOfStatement;
exports.default = ForOfStatement;
},{"./Location":"VU7R","./ion/Null":"ozVR","./Type":"kwdr","./VariableDeclaration":"KDXm","./Expression":"zMtI","./BlockStatement":"I4Ao","./ion/Class":"iy0N"}],"EYTx":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isForStatement = exports.ForStatement = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const VariableDeclaration = __importStar(require("./VariableDeclaration"));

const Expression = __importStar(require("./Expression"));

const BlockStatement = __importStar(require("./BlockStatement"));

const Class = __importStar(require("./ion/Class"));

class ForStatement {
  constructor({
    location = null,
    type = null,
    init = null,
    test = null,
    update = null,
    body
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!(VariableDeclaration.isVariableDeclaration(init) || Null.isNull(init))) throw new Error('init is not a VariableDeclaration | Null: ' + Class.toString(init));
    if (!(Expression.isExpression(test) || Null.isNull(test))) throw new Error('test is not a Expression | Null: ' + Class.toString(test));
    if (!(Expression.isExpression(update) || Null.isNull(update))) throw new Error('update is not a Expression | Null: ' + Class.toString(update));
    if (!BlockStatement.isBlockStatement(body)) throw new Error('body is not a BlockStatement: ' + Class.toString(body));
    this.location = location;
    this.type = type;
    this.init = init;
    this.test = test;
    this.update = update;
    this.body = body;
    Object.freeze(this);
  }

  patch(properties) {
    return new ForStatement({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isForStatement(value);
  }

}

exports.ForStatement = ForStatement;
ForStatement.id = 'ForStatement';
ForStatement.implements = new Set(['ForStatement', 'ion_Object', 'Statement', 'Typed', 'Node']);

function isForStatement(value) {
  return Class.isInstance(ForStatement, value);
}

exports.isForStatement = isForStatement;
exports.default = ForStatement;
},{"./Location":"VU7R","./ion/Null":"ozVR","./Type":"kwdr","./VariableDeclaration":"KDXm","./Expression":"zMtI","./BlockStatement":"I4Ao","./ion/Class":"iy0N"}],"mzLz":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isFunctionExpression = exports.FunctionExpression = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const Identifier = __importStar(require("./Identifier"));

const _Array = __importStar(require("./ion/Array"));

const BlockStatement = __importStar(require("./BlockStatement"));

const Boolean = __importStar(require("./ion/Boolean"));

const Class = __importStar(require("./ion/Class"));

class FunctionExpression {
  constructor({
    location = null,
    type = null,
    id = null,
    params,
    body,
    async: _async = false,
    generator = false,
    returnType = null
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!(Identifier.isIdentifier(id) || Null.isNull(id))) throw new Error('id is not a Identifier | Null: ' + Class.toString(id));
    if (!_Array.isArray(params)) throw new Error('params is not a Array: ' + Class.toString(params));
    if (!BlockStatement.isBlockStatement(body)) throw new Error('body is not a BlockStatement: ' + Class.toString(body));
    if (!Boolean.isBoolean(_async)) throw new Error('async is not a Boolean: ' + Class.toString(_async));
    if (!Boolean.isBoolean(generator)) throw new Error('generator is not a Boolean: ' + Class.toString(generator));
    if (!(Type.isType(returnType) || Null.isNull(returnType))) throw new Error('returnType is not a Type | Null: ' + Class.toString(returnType));
    this.location = location;
    this.type = type;
    this.id = id;
    this.params = params;
    this.body = body;
    this.async = _async;
    this.generator = generator;
    this.returnType = returnType;
    Object.freeze(this);
  }

  patch(properties) {
    return new FunctionExpression({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isFunctionExpression(value);
  }

}

exports.FunctionExpression = FunctionExpression;
FunctionExpression.id = 'FunctionExpression';
FunctionExpression.implements = new Set(['FunctionExpression', 'ion_Object', 'Expression', 'Scope', 'Typed', 'Node']);

function isFunctionExpression(value) {
  return Class.isInstance(FunctionExpression, value);
}

exports.isFunctionExpression = isFunctionExpression;
exports.default = FunctionExpression;
},{"./Location":"VU7R","./ion/Null":"ozVR","./Type":"kwdr","./Identifier":"lIID","./ion/Array":"PpFg","./BlockStatement":"I4Ao","./ion/Boolean":"eJLV","./ion/Class":"iy0N"}],"iqg9":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isFunctionType = exports.FunctionType = void 0;

const Type = __importStar(require("./Type"));

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const _Array = __importStar(require("./ion/Array"));

const Boolean = __importStar(require("./ion/Boolean"));

const Class = __importStar(require("./ion/Class"));

class FunctionType {
  constructor({
    location = null,
    type = null,
    params,
    async: _async = false,
    returnType = null
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!_Array.isArray(params)) throw new Error('params is not a Array: ' + Class.toString(params));
    if (!Boolean.isBoolean(_async)) throw new Error('async is not a Boolean: ' + Class.toString(_async));
    if (!(Type.isType(returnType) || Null.isNull(returnType))) throw new Error('returnType is not a Type | Null: ' + Class.toString(returnType));
    this.location = location;
    this.type = type;
    this.params = params;
    this.async = _async;
    this.returnType = returnType;
    Object.freeze(this);
  }

  patch(properties) {
    return new FunctionType({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isFunctionType(value);
  }

}

exports.FunctionType = FunctionType;
FunctionType.id = 'FunctionType';
FunctionType.implements = new Set(['FunctionType', 'ion_Object', 'Type', 'Expression', 'Typed', 'Node']);

function isFunctionType(value) {
  return Class.isInstance(FunctionType, value);
}

exports.isFunctionType = isFunctionType;
exports.default = FunctionType;
},{"./Type":"kwdr","./Location":"VU7R","./ion/Null":"ozVR","./ion/Array":"PpFg","./ion/Boolean":"eJLV","./ion/Class":"iy0N"}],"vQyy":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isIfStatement = exports.IfStatement = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const Expression = __importStar(require("./Expression"));

const BlockStatement = __importStar(require("./BlockStatement"));

const Class = __importStar(require("./ion/Class"));

class IfStatement {
  constructor({
    location = null,
    type = null,
    test,
    consequent,
    alternate = null
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!Expression.isExpression(test)) throw new Error('test is not a Expression: ' + Class.toString(test));
    if (!BlockStatement.isBlockStatement(consequent)) throw new Error('consequent is not a BlockStatement: ' + Class.toString(consequent));
    if (!(BlockStatement.isBlockStatement(alternate) || isIfStatement(alternate) || Null.isNull(alternate))) throw new Error('alternate is not a BlockStatement | IfStatement | Null: ' + Class.toString(alternate));
    this.location = location;
    this.type = type;
    this.test = test;
    this.consequent = consequent;
    this.alternate = alternate;
    Object.freeze(this);
  }

  patch(properties) {
    return new IfStatement({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isIfStatement(value);
  }

}

exports.IfStatement = IfStatement;
IfStatement.id = 'IfStatement';
IfStatement.implements = new Set(['IfStatement', 'ion_Object', 'Statement', 'Typed', 'Node']);

function isIfStatement(value) {
  return Class.isInstance(IfStatement, value);
}

exports.isIfStatement = isIfStatement;
exports.default = IfStatement;
},{"./Location":"VU7R","./ion/Null":"ozVR","./Type":"kwdr","./Expression":"zMtI","./BlockStatement":"I4Ao","./ion/Class":"iy0N"}],"r0zz":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isImportSpecifier = exports.ImportSpecifier = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Identifier = __importStar(require("./Identifier"));

const Class = __importStar(require("./ion/Class"));

class ImportSpecifier {
  constructor({
    location = null,
    local,
    imported
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!Identifier.isIdentifier(local)) throw new Error('local is not a Identifier: ' + Class.toString(local));
    if (!Identifier.isIdentifier(imported)) throw new Error('imported is not a Identifier: ' + Class.toString(imported));
    this.location = location;
    this.local = local;
    this.imported = imported;
    Object.freeze(this);
  }

  patch(properties) {
    return new ImportSpecifier({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isImportSpecifier(value);
  }

}

exports.ImportSpecifier = ImportSpecifier;
ImportSpecifier.id = 'ImportSpecifier';
ImportSpecifier.implements = new Set(['ImportSpecifier', 'ion_Object', 'ModuleSpecifier', 'Node']);

function isImportSpecifier(value) {
  return Class.isInstance(ImportSpecifier, value);
}

exports.isImportSpecifier = isImportSpecifier;
exports.default = ImportSpecifier;
},{"./Location":"VU7R","./ion/Null":"ozVR","./Identifier":"lIID","./ion/Class":"iy0N"}],"yw5q":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isImportDefaultSpecifier = exports.ImportDefaultSpecifier = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Identifier = __importStar(require("./Identifier"));

const Class = __importStar(require("./ion/Class"));

class ImportDefaultSpecifier {
  constructor({
    location = null,
    local
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!Identifier.isIdentifier(local)) throw new Error('local is not a Identifier: ' + Class.toString(local));
    this.location = location;
    this.local = local;
    Object.freeze(this);
  }

  patch(properties) {
    return new ImportDefaultSpecifier({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isImportDefaultSpecifier(value);
  }

}

exports.ImportDefaultSpecifier = ImportDefaultSpecifier;
ImportDefaultSpecifier.id = 'ImportDefaultSpecifier';
ImportDefaultSpecifier.implements = new Set(['ImportDefaultSpecifier', 'ion_Object', 'ModuleSpecifier', 'Node']);

function isImportDefaultSpecifier(value) {
  return Class.isInstance(ImportDefaultSpecifier, value);
}

exports.isImportDefaultSpecifier = isImportDefaultSpecifier;
exports.default = ImportDefaultSpecifier;
},{"./Location":"VU7R","./ion/Null":"ozVR","./Identifier":"lIID","./ion/Class":"iy0N"}],"NN6s":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isImportNamespaceSpecifier = exports.ImportNamespaceSpecifier = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Identifier = __importStar(require("./Identifier"));

const Class = __importStar(require("./ion/Class"));

class ImportNamespaceSpecifier {
  constructor({
    location = null,
    local
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!Identifier.isIdentifier(local)) throw new Error('local is not a Identifier: ' + Class.toString(local));
    this.location = location;
    this.local = local;
    Object.freeze(this);
  }

  patch(properties) {
    return new ImportNamespaceSpecifier({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isImportNamespaceSpecifier(value);
  }

}

exports.ImportNamespaceSpecifier = ImportNamespaceSpecifier;
ImportNamespaceSpecifier.id = 'ImportNamespaceSpecifier';
ImportNamespaceSpecifier.implements = new Set(['ImportNamespaceSpecifier', 'ion_Object', 'ModuleSpecifier', 'Node']);

function isImportNamespaceSpecifier(value) {
  return Class.isInstance(ImportNamespaceSpecifier, value);
}

exports.isImportNamespaceSpecifier = isImportNamespaceSpecifier;
exports.default = ImportNamespaceSpecifier;
},{"./Location":"VU7R","./ion/Null":"ozVR","./Identifier":"lIID","./ion/Class":"iy0N"}],"jxHw":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isLiteral = exports.Literal = void 0;

const Type = __importStar(require("./Type"));

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const String = __importStar(require("./ion/String"));

const Number = __importStar(require("./ion/Number"));

const Boolean = __importStar(require("./ion/Boolean"));

const Class = __importStar(require("./ion/Class"));

class Literal {
  constructor({
    location = null,
    type = null,
    value
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!(String.isString(value) || Number.isNumber(value) || Boolean.isBoolean(value) || Null.isNull(value))) throw new Error('value is not a String | Number | Boolean | Null: ' + Class.toString(value));
    this.location = location;
    this.type = type;
    this.value = value;
    Object.freeze(this);
  }

  patch(properties) {
    return new Literal({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isLiteral(value);
  }

}

exports.Literal = Literal;
Literal.id = 'Literal';
Literal.implements = new Set(['Literal', 'ion_Object', 'Expression', 'Type', 'Typed', 'Node']);

function isLiteral(value) {
  return Class.isInstance(Literal, value);
}

exports.isLiteral = isLiteral;
exports.default = Literal;
},{"./Type":"kwdr","./Location":"VU7R","./ion/Null":"ozVR","./ion/String":"CAX3","./ion/Number":"Zizk","./ion/Boolean":"eJLV","./ion/Class":"iy0N"}],"g7Am":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isImportDeclaration = exports.ImportDeclaration = exports.isSpecifier = void 0;
/*
This file was generated from ion source. Do not edit.
*/

const ImportSpecifier = __importStar(require("./ImportSpecifier"));

const ImportDefaultSpecifier = __importStar(require("./ImportDefaultSpecifier"));

const ImportNamespaceSpecifier = __importStar(require("./ImportNamespaceSpecifier"));

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const Integer = __importStar(require("./ion/Integer"));

const _Array = __importStar(require("./ion/Array"));

const Literal = __importStar(require("./Literal"));

const Class = __importStar(require("./ion/Class"));

function isSpecifier(value) {
  return ImportSpecifier.isImportSpecifier(value) || ImportDefaultSpecifier.isImportDefaultSpecifier(value) || ImportNamespaceSpecifier.isImportNamespaceSpecifier(value);
}

exports.isSpecifier = isSpecifier;

class ImportDeclaration {
  constructor({
    location = null,
    type = null,
    export: _export = 0,
    specifiers,
    source
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!Integer.isInteger(_export)) throw new Error('export is not a Integer: ' + Class.toString(_export));
    if (!_Array.isArray(specifiers)) throw new Error('specifiers is not a Array: ' + Class.toString(specifiers));
    if (!Literal.isLiteral(source)) throw new Error('source is not a Literal: ' + Class.toString(source));
    this.location = location;
    this.type = type;
    this.export = _export;
    this.specifiers = specifiers;
    this.source = source;
    Object.freeze(this);
  }

  patch(properties) {
    return new ImportDeclaration({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isImportDeclaration(value);
  }

}

exports.ImportDeclaration = ImportDeclaration;
ImportDeclaration.id = 'ImportDeclaration';
ImportDeclaration.implements = new Set(['ImportDeclaration', 'ion_Object', 'Declaration', 'Statement', 'Exportable', 'Typed', 'Node']);

function isImportDeclaration(value) {
  return Class.isInstance(ImportDeclaration, value);
}

exports.isImportDeclaration = isImportDeclaration;
exports.default = ImportDeclaration;
},{"./ImportSpecifier":"r0zz","./ImportDefaultSpecifier":"yw5q","./ImportNamespaceSpecifier":"NN6s","./Location":"VU7R","./ion/Null":"ozVR","./Type":"kwdr","./ion/Integer":"L0Jq","./ion/Array":"PpFg","./Literal":"jxHw","./ion/Class":"iy0N"}],"Ukrj":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isMemberExpression = exports.MemberExpression = void 0;

const Expression = __importStar(require("./Expression"));

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const Boolean = __importStar(require("./ion/Boolean"));

const Identifier = __importStar(require("./Identifier"));

const Class = __importStar(require("./ion/Class"));

class MemberExpression {
  constructor({
    location = null,
    type = null,
    optional = false,
    object,
    property
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!Boolean.isBoolean(optional)) throw new Error('optional is not a Boolean: ' + Class.toString(optional));
    if (!Expression.isExpression(object)) throw new Error('object is not a Expression: ' + Class.toString(object));
    if (!(Identifier.isIdentifier(property) || Expression.isExpression(property))) throw new Error('property is not a Identifier | Expression: ' + Class.toString(property));
    this.location = location;
    this.type = type;
    this.optional = optional;
    this.object = object;
    this.property = property;
    Object.freeze(this);
  }

  patch(properties) {
    return new MemberExpression({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isMemberExpression(value);
  }

}

exports.MemberExpression = MemberExpression;
MemberExpression.id = 'MemberExpression';
MemberExpression.implements = new Set(['MemberExpression', 'ion_Object', 'Expression', 'ChainElement', 'Typed', 'Node']);

function isMemberExpression(value) {
  return Class.isInstance(MemberExpression, value);
}

exports.isMemberExpression = isMemberExpression;
exports.default = MemberExpression;
},{"./Expression":"zMtI","./Location":"VU7R","./ion/Null":"ozVR","./Type":"kwdr","./ion/Boolean":"eJLV","./Identifier":"lIID","./ion/Class":"iy0N"}],"N0RR":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isMethodDefinition = exports.MethodDefinition = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Expression = __importStar(require("./Expression"));

const Identifier = __importStar(require("./Identifier"));

const FunctionExpression = __importStar(require("./FunctionExpression"));

const String = __importStar(require("./ion/String"));

const Boolean = __importStar(require("./ion/Boolean"));

const Class = __importStar(require("./ion/Class"));

class MethodDefinition {
  constructor({
    location = null,
    key,
    value,
    kind = 'method',
    computed = false,
    static: _static = false
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Expression.isExpression(key) || Identifier.isIdentifier(key))) throw new Error('key is not a Expression | Identifier: ' + Class.toString(key));
    if (!FunctionExpression.isFunctionExpression(value)) throw new Error('value is not a FunctionExpression: ' + Class.toString(value));
    if (!String.isString(kind)) throw new Error('kind is not a String: ' + Class.toString(kind));
    if (!Boolean.isBoolean(computed)) throw new Error('computed is not a Boolean: ' + Class.toString(computed));
    if (!Boolean.isBoolean(_static)) throw new Error('static is not a Boolean: ' + Class.toString(_static));
    this.location = location;
    this.key = key;
    this.value = value;
    this.kind = kind;
    this.computed = computed;
    this.static = _static;
    Object.freeze(this);
  }

  patch(properties) {
    return new MethodDefinition({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isMethodDefinition(value);
  }

}

exports.MethodDefinition = MethodDefinition;
MethodDefinition.id = 'MethodDefinition';
MethodDefinition.implements = new Set(['MethodDefinition', 'ion_Object', 'Node']);

function isMethodDefinition(value) {
  return Class.isInstance(MethodDefinition, value);
}

exports.isMethodDefinition = isMethodDefinition;
exports.default = MethodDefinition;
},{"./Location":"VU7R","./ion/Null":"ozVR","./Expression":"zMtI","./Identifier":"lIID","./FunctionExpression":"mzLz","./ion/String":"CAX3","./ion/Boolean":"eJLV","./ion/Class":"iy0N"}],"xPps":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isModuleSpecifier = exports.ModuleSpecifier = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Identifier = __importStar(require("./Identifier"));

const Class = __importStar(require("./ion/Class"));

class ModuleSpecifier {
  constructor({
    location = null,
    local
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!Identifier.isIdentifier(local)) throw new Error('local is not a Identifier: ' + Class.toString(local));
    this.location = location;
    this.local = local;
    Object.freeze(this);
  }

  patch(properties) {
    return new ModuleSpecifier({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isModuleSpecifier(value);
  }

}

exports.ModuleSpecifier = ModuleSpecifier;
ModuleSpecifier.id = 'ModuleSpecifier';
ModuleSpecifier.implements = new Set(['ModuleSpecifier', 'ion_Object', 'Node']);

function isModuleSpecifier(value) {
  return Class.isInstance(ModuleSpecifier, value);
}

exports.isModuleSpecifier = isModuleSpecifier;
exports.default = ModuleSpecifier;
},{"./Location":"VU7R","./ion/Null":"ozVR","./Identifier":"lIID","./ion/Class":"iy0N"}],"wYgM":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isNode = exports.Node = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Class = __importStar(require("./ion/Class"));

class Node {
  constructor({
    location = null
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    this.location = location;
    Object.freeze(this);
  }

  patch(properties) {
    return new Node({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isNode(value);
  }

}

exports.Node = Node;
Node.id = 'Node';
Node.implements = new Set(['Node', 'ion_Object']);

function isNode(value) {
  return Class.isInstance(Node, value);
}

exports.isNode = isNode;
exports.default = Node;
},{"./Location":"VU7R","./ion/Null":"ozVR","./ion/Class":"iy0N"}],"cWiT":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isObjectExpression = exports.ObjectExpression = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const _Array = __importStar(require("./ion/Array"));

const Boolean = __importStar(require("./ion/Boolean"));

const Class = __importStar(require("./ion/Class"));

class ObjectExpression {
  constructor({
    location = null,
    type = null,
    properties,
    isMap = false
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!_Array.isArray(properties)) throw new Error('properties is not a Array: ' + Class.toString(properties));
    if (!Boolean.isBoolean(isMap)) throw new Error('isMap is not a Boolean: ' + Class.toString(isMap));
    this.location = location;
    this.type = type;
    this.properties = properties;
    this.isMap = isMap;
    Object.freeze(this);
  }

  patch(properties) {
    return new ObjectExpression({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isObjectExpression(value);
  }

}

exports.ObjectExpression = ObjectExpression;
ObjectExpression.id = 'ObjectExpression';
ObjectExpression.implements = new Set(['ObjectExpression', 'ion_Object', 'Expression', 'Typed', 'Node']);

function isObjectExpression(value) {
  return Class.isInstance(ObjectExpression, value);
}

exports.isObjectExpression = isObjectExpression;
exports.default = ObjectExpression;
},{"./Location":"VU7R","./ion/Null":"ozVR","./Type":"kwdr","./ion/Array":"PpFg","./ion/Boolean":"eJLV","./ion/Class":"iy0N"}],"lvQy":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isObjectPattern = exports.ObjectPattern = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const _Array = __importStar(require("./ion/Array"));

const Class = __importStar(require("./ion/Class"));

class ObjectPattern {
  constructor({
    location = null,
    type = null,
    properties
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!_Array.isArray(properties)) throw new Error('properties is not a Array: ' + Class.toString(properties));
    this.location = location;
    this.type = type;
    this.properties = properties;
    Object.freeze(this);
  }

  patch(properties) {
    return new ObjectPattern({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isObjectPattern(value);
  }

}

exports.ObjectPattern = ObjectPattern;
ObjectPattern.id = 'ObjectPattern';
ObjectPattern.implements = new Set(['ObjectPattern', 'ion_Object', 'Pattern', 'Typed', 'Node']);

function isObjectPattern(value) {
  return Class.isInstance(ObjectPattern, value);
}

exports.isObjectPattern = isObjectPattern;
exports.default = ObjectPattern;
},{"./Location":"VU7R","./ion/Null":"ozVR","./Type":"kwdr","./ion/Array":"PpFg","./ion/Class":"iy0N"}],"ywPB":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isOutlineOperation = exports.OutlineOperation = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const _Array = __importStar(require("./ion/Array"));

const String = __importStar(require("./ion/String"));

const Class = __importStar(require("./ion/Class"));

class OutlineOperation {
  constructor({
    location = null,
    type = null,
    operands,
    operator
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!_Array.isArray(operands)) throw new Error('operands is not a Array: ' + Class.toString(operands));
    if (!String.isString(operator)) throw new Error('operator is not a String: ' + Class.toString(operator));
    this.location = location;
    this.type = type;
    this.operands = operands;
    this.operator = operator;
    Object.freeze(this);
  }

  patch(properties) {
    return new OutlineOperation({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isOutlineOperation(value);
  }

}

exports.OutlineOperation = OutlineOperation;
OutlineOperation.id = 'OutlineOperation';
OutlineOperation.implements = new Set(['OutlineOperation', 'ion_Object', 'Expression', 'Typed', 'Node']);

function isOutlineOperation(value) {
  return Class.isInstance(OutlineOperation, value);
}

exports.isOutlineOperation = isOutlineOperation;
exports.default = OutlineOperation;
},{"./Location":"VU7R","./ion/Null":"ozVR","./Type":"kwdr","./ion/Array":"PpFg","./ion/String":"CAX3","./ion/Class":"iy0N"}],"O8G7":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isParameter = exports.Parameter = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const Pattern = __importStar(require("./Pattern"));

const Expression = __importStar(require("./Expression"));

const Class = __importStar(require("./ion/Class"));

class Parameter {
  constructor({
    location = null,
    type = null,
    id,
    value = null
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!(Pattern.isPattern(id) || Expression.isExpression(id))) throw new Error('id is not a Pattern | Expression: ' + Class.toString(id));
    if (!(Expression.isExpression(value) || Null.isNull(value))) throw new Error('value is not a Expression | Null: ' + Class.toString(value));
    this.location = location;
    this.type = type;
    this.id = id;
    this.value = value;
    Object.freeze(this);
  }

  patch(properties) {
    return new Parameter({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isParameter(value);
  }

}

exports.Parameter = Parameter;
Parameter.id = 'Parameter';
Parameter.implements = new Set(['Parameter', 'ion_Object', 'Variable', 'Typed', 'Node']);

function isParameter(value) {
  return Class.isInstance(Parameter, value);
}

exports.isParameter = isParameter;
exports.default = Parameter;
},{"./Location":"VU7R","./ion/Null":"ozVR","./Type":"kwdr","./Pattern":"qBpR","./Expression":"zMtI","./ion/Class":"iy0N"}],"ByPT":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isProgram = exports.Program = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Declarator = __importStar(require("./Declarator"));

const _Array = __importStar(require("./ion/Array"));

const Class = __importStar(require("./ion/Class"));

class Program {
  constructor({
    location = null,
    id,
    body
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!Declarator.isDeclarator(id)) throw new Error('id is not a Declarator: ' + Class.toString(id));
    if (!_Array.isArray(body)) throw new Error('body is not a Array: ' + Class.toString(body));
    this.location = location;
    this.id = id;
    this.body = body;
    Object.freeze(this);
  }

  patch(properties) {
    return new Program({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isProgram(value);
  }

}

exports.Program = Program;
Program.id = 'Program';
Program.implements = new Set(['Program', 'ion_Object', 'Scope', 'Node']);

function isProgram(value) {
  return Class.isInstance(Program, value);
}

exports.isProgram = isProgram;
exports.default = Program;
},{"./Location":"VU7R","./ion/Null":"ozVR","./Declarator":"gz3F","./ion/Array":"PpFg","./ion/Class":"iy0N"}],"kVPM":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isProperty = exports.Property = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const Expression = __importStar(require("./Expression"));

const Identifier = __importStar(require("./Identifier"));

const Pattern = __importStar(require("./Pattern"));

const String = __importStar(require("./ion/String"));

const Boolean = __importStar(require("./ion/Boolean"));

const Class = __importStar(require("./ion/Class"));

class Property {
  constructor({
    location = null,
    type = null,
    key,
    value,
    kind = 'init',
    method = false,
    shorthand = false,
    computed = false
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!(Expression.isExpression(key) || Identifier.isIdentifier(key))) throw new Error('key is not a Expression | Identifier: ' + Class.toString(key));
    if (!(Expression.isExpression(value) || Pattern.isPattern(value))) throw new Error('value is not a Expression | Pattern: ' + Class.toString(value));
    if (!String.isString(kind)) throw new Error('kind is not a String: ' + Class.toString(kind));
    if (!Boolean.isBoolean(method)) throw new Error('method is not a Boolean: ' + Class.toString(method));
    if (!Boolean.isBoolean(shorthand)) throw new Error('shorthand is not a Boolean: ' + Class.toString(shorthand));
    if (!Boolean.isBoolean(computed)) throw new Error('computed is not a Boolean: ' + Class.toString(computed));
    this.location = location;
    this.type = type;
    this.key = key;
    this.value = value;
    this.kind = kind;
    this.method = method;
    this.shorthand = shorthand;
    this.computed = computed;
    Object.freeze(this);
  }

  patch(properties) {
    return new Property({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isProperty(value);
  }

}

exports.Property = Property;
Property.id = 'Property';
Property.implements = new Set(['Property', 'ion_Object', 'Typed', 'Node']);

function isProperty(value) {
  return Class.isInstance(Property, value);
}

exports.isProperty = isProperty;
exports.default = Property;
},{"./Location":"VU7R","./ion/Null":"ozVR","./Type":"kwdr","./Expression":"zMtI","./Identifier":"lIID","./Pattern":"qBpR","./ion/String":"CAX3","./ion/Boolean":"eJLV","./ion/Class":"iy0N"}],"JB1h":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isPropertyStatement = exports.PropertyStatement = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const Property = __importStar(require("./Property"));

const Class = __importStar(require("./ion/Class"));

class PropertyStatement {
  constructor({
    location = null,
    type = null,
    property
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!Property.isProperty(property)) throw new Error('property is not a Property: ' + Class.toString(property));
    this.location = location;
    this.type = type;
    this.property = property;
    Object.freeze(this);
  }

  patch(properties) {
    return new PropertyStatement({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isPropertyStatement(value);
  }

}

exports.PropertyStatement = PropertyStatement;
PropertyStatement.id = 'PropertyStatement';
PropertyStatement.implements = new Set(['PropertyStatement', 'ion_Object', 'Statement', 'Typed', 'Node']);

function isPropertyStatement(value) {
  return Class.isInstance(PropertyStatement, value);
}

exports.isPropertyStatement = isPropertyStatement;
exports.default = PropertyStatement;
},{"./Location":"VU7R","./ion/Null":"ozVR","./Type":"kwdr","./Property":"kVPM","./ion/Class":"iy0N"}],"zd4v":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isReference = exports.Reference = void 0;

const Type = __importStar(require("./Type"));

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const String = __importStar(require("./ion/String"));

const _Array = __importStar(require("./ion/Array"));

const Class = __importStar(require("./ion/Class"));

class Reference {
  constructor({
    location = null,
    name,
    path = null,
    type = null,
    arguments: _arguments = null
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!String.isString(name)) throw new Error('name is not a String: ' + Class.toString(name));
    if (!(String.isString(path) || Null.isNull(path))) throw new Error('path is not a String | Null: ' + Class.toString(path));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!(_Array.isArray(_arguments) || Null.isNull(_arguments))) throw new Error('arguments is not a Array | Null: ' + Class.toString(_arguments));
    this.location = location;
    this.name = name;
    this.path = path;
    this.type = type;
    this.arguments = _arguments;
    Object.freeze(this);
  }

  patch(properties) {
    return new Reference({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isReference(value);
  }

}

exports.Reference = Reference;
Reference.id = 'Reference';
Reference.implements = new Set(['Reference', 'ion_Object', 'Identifier', 'Expression', 'Type', 'Node', 'Typed']);

function isReference(value) {
  return Class.isInstance(Reference, value);
}

exports.isReference = isReference;
exports.default = Reference;
},{"./Type":"kwdr","./Location":"VU7R","./ion/Null":"ozVR","./ion/String":"CAX3","./ion/Array":"PpFg","./ion/Class":"iy0N"}],"WQbd":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isRegularExpression = exports.RegularExpression = void 0;

const Type = __importStar(require("./Type"));

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const String = __importStar(require("./ion/String"));

const Class = __importStar(require("./ion/Class"));

class RegularExpression {
  constructor({
    location = null,
    type = null,
    pattern,
    flags
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!String.isString(pattern)) throw new Error('pattern is not a String: ' + Class.toString(pattern));
    if (!String.isString(flags)) throw new Error('flags is not a String: ' + Class.toString(flags));
    this.location = location;
    this.type = type;
    this.pattern = pattern;
    this.flags = flags;
    Object.freeze(this);
  }

  patch(properties) {
    return new RegularExpression({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isRegularExpression(value);
  }

}

exports.RegularExpression = RegularExpression;
RegularExpression.id = 'RegularExpression';
RegularExpression.implements = new Set(['RegularExpression', 'ion_Object', 'Expression', 'Type', 'Typed', 'Node']);

function isRegularExpression(value) {
  return Class.isInstance(RegularExpression, value);
}

exports.isRegularExpression = isRegularExpression;
exports.default = RegularExpression;
},{"./Type":"kwdr","./Location":"VU7R","./ion/Null":"ozVR","./ion/String":"CAX3","./ion/Class":"iy0N"}],"CZHB":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isRestElement = exports.RestElement = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const Declarator = __importStar(require("./Declarator"));

const Class = __importStar(require("./ion/Class"));

class RestElement {
  constructor({
    location = null,
    type = null,
    argument
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!Declarator.isDeclarator(argument)) throw new Error('argument is not a Declarator: ' + Class.toString(argument));
    this.location = location;
    this.type = type;
    this.argument = argument;
    Object.freeze(this);
  }

  patch(properties) {
    return new RestElement({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isRestElement(value);
  }

}

exports.RestElement = RestElement;
RestElement.id = 'RestElement';
RestElement.implements = new Set(['RestElement', 'ion_Object', 'Pattern', 'Typed', 'Node']);

function isRestElement(value) {
  return Class.isInstance(RestElement, value);
}

exports.isRestElement = isRestElement;
exports.default = RestElement;
},{"./Location":"VU7R","./ion/Null":"ozVR","./Type":"kwdr","./Declarator":"gz3F","./ion/Class":"iy0N"}],"GuMA":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isReturnStatement = exports.ReturnStatement = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const Expression = __importStar(require("./Expression"));

const Class = __importStar(require("./ion/Class"));

class ReturnStatement {
  constructor({
    location = null,
    type = null,
    argument
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!Expression.isExpression(argument)) throw new Error('argument is not a Expression: ' + Class.toString(argument));
    this.location = location;
    this.type = type;
    this.argument = argument;
    Object.freeze(this);
  }

  patch(properties) {
    return new ReturnStatement({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isReturnStatement(value);
  }

}

exports.ReturnStatement = ReturnStatement;
ReturnStatement.id = 'ReturnStatement';
ReturnStatement.implements = new Set(['ReturnStatement', 'ion_Object', 'Statement', 'Typed', 'Node']);

function isReturnStatement(value) {
  return Class.isInstance(ReturnStatement, value);
}

exports.isReturnStatement = isReturnStatement;
exports.default = ReturnStatement;
},{"./Location":"VU7R","./ion/Null":"ozVR","./Type":"kwdr","./Expression":"zMtI","./ion/Class":"iy0N"}],"LFRz":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isScope = exports.Scope = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Class = __importStar(require("./ion/Class"));

class Scope {
  constructor({
    location = null
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    this.location = location;
    Object.freeze(this);
  }

  patch(properties) {
    return new Scope({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isScope(value);
  }

}

exports.Scope = Scope;
Scope.id = 'Scope';
Scope.implements = new Set(['Scope', 'ion_Object', 'Node']);

function isScope(value) {
  return Class.isInstance(Scope, value);
}

exports.isScope = isScope;
exports.default = Scope;
},{"./Location":"VU7R","./ion/Null":"ozVR","./ion/Class":"iy0N"}],"diY0":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isStatement = exports.Statement = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const Class = __importStar(require("./ion/Class"));

class Statement {
  constructor({
    location = null,
    type = null
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    this.location = location;
    this.type = type;
    Object.freeze(this);
  }

  patch(properties) {
    return new Statement({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isStatement(value);
  }

}

exports.Statement = Statement;
Statement.id = 'Statement';
Statement.implements = new Set(['Statement', 'ion_Object', 'Typed', 'Node']);

function isStatement(value) {
  return Class.isInstance(Statement, value);
}

exports.isStatement = isStatement;
exports.default = Statement;
},{"./Location":"VU7R","./ion/Null":"ozVR","./Type":"kwdr","./ion/Class":"iy0N"}],"arKK":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isSwitchCase = exports.SwitchCase = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Expression = __importStar(require("./Expression"));

const BlockStatement = __importStar(require("./BlockStatement"));

const Class = __importStar(require("./ion/Class"));

class SwitchCase {
  constructor({
    location = null,
    test,
    consequent
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Expression.isExpression(test) || Null.isNull(test))) throw new Error('test is not a Expression | Null: ' + Class.toString(test));
    if (!(BlockStatement.isBlockStatement(consequent) || Null.isNull(consequent))) throw new Error('consequent is not a BlockStatement | Null: ' + Class.toString(consequent));
    this.location = location;
    this.test = test;
    this.consequent = consequent;
    Object.freeze(this);
  }

  patch(properties) {
    return new SwitchCase({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isSwitchCase(value);
  }

}

exports.SwitchCase = SwitchCase;
SwitchCase.id = 'SwitchCase';
SwitchCase.implements = new Set(['SwitchCase', 'ion_Object', 'Node']);

function isSwitchCase(value) {
  return Class.isInstance(SwitchCase, value);
}

exports.isSwitchCase = isSwitchCase;
exports.default = SwitchCase;
},{"./Location":"VU7R","./ion/Null":"ozVR","./Expression":"zMtI","./BlockStatement":"I4Ao","./ion/Class":"iy0N"}],"R7gG":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isSwitchStatement = exports.SwitchStatement = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const Expression = __importStar(require("./Expression"));

const _Array = __importStar(require("./ion/Array"));

const Class = __importStar(require("./ion/Class"));

class SwitchStatement {
  constructor({
    location = null,
    type = null,
    discriminant,
    cases
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!Expression.isExpression(discriminant)) throw new Error('discriminant is not a Expression: ' + Class.toString(discriminant));
    if (!_Array.isArray(cases)) throw new Error('cases is not a Array: ' + Class.toString(cases));
    this.location = location;
    this.type = type;
    this.discriminant = discriminant;
    this.cases = cases;
    Object.freeze(this);
  }

  patch(properties) {
    return new SwitchStatement({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isSwitchStatement(value);
  }

}

exports.SwitchStatement = SwitchStatement;
SwitchStatement.id = 'SwitchStatement';
SwitchStatement.implements = new Set(['SwitchStatement', 'ion_Object', 'Statement', 'Typed', 'Node']);

function isSwitchStatement(value) {
  return Class.isInstance(SwitchStatement, value);
}

exports.isSwitchStatement = isSwitchStatement;
exports.default = SwitchStatement;
},{"./Location":"VU7R","./ion/Null":"ozVR","./Type":"kwdr","./Expression":"zMtI","./ion/Array":"PpFg","./ion/Class":"iy0N"}],"Fqwb":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isThisExpression = exports.ThisExpression = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const Class = __importStar(require("./ion/Class"));

class ThisExpression {
  constructor({
    location = null,
    type = null
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    this.location = location;
    this.type = type;
    Object.freeze(this);
  }

  patch(properties) {
    return new ThisExpression({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isThisExpression(value);
  }

}

exports.ThisExpression = ThisExpression;
ThisExpression.id = 'ThisExpression';
ThisExpression.implements = new Set(['ThisExpression', 'ion_Object', 'Expression', 'Typed', 'Node']);

function isThisExpression(value) {
  return Class.isInstance(ThisExpression, value);
}

exports.isThisExpression = isThisExpression;
exports.default = ThisExpression;
},{"./Location":"VU7R","./ion/Null":"ozVR","./Type":"kwdr","./ion/Class":"iy0N"}],"mZrm":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isThrowStatement = exports.ThrowStatement = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const Expression = __importStar(require("./Expression"));

const Class = __importStar(require("./ion/Class"));

class ThrowStatement {
  constructor({
    location = null,
    type = null,
    argument
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!Expression.isExpression(argument)) throw new Error('argument is not a Expression: ' + Class.toString(argument));
    this.location = location;
    this.type = type;
    this.argument = argument;
    Object.freeze(this);
  }

  patch(properties) {
    return new ThrowStatement({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isThrowStatement(value);
  }

}

exports.ThrowStatement = ThrowStatement;
ThrowStatement.id = 'ThrowStatement';
ThrowStatement.implements = new Set(['ThrowStatement', 'ion_Object', 'Statement', 'Typed', 'Node']);

function isThrowStatement(value) {
  return Class.isInstance(ThrowStatement, value);
}

exports.isThrowStatement = isThrowStatement;
exports.default = ThrowStatement;
},{"./Location":"VU7R","./ion/Null":"ozVR","./Type":"kwdr","./Expression":"zMtI","./ion/Class":"iy0N"}],"oCbk":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isTryStatement = exports.TryStatement = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const BlockStatement = __importStar(require("./BlockStatement"));

const CatchClause = __importStar(require("./CatchClause"));

const Class = __importStar(require("./ion/Class"));

class TryStatement {
  constructor({
    location = null,
    type = null,
    block,
    handler = null,
    finalizer = null
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!BlockStatement.isBlockStatement(block)) throw new Error('block is not a BlockStatement: ' + Class.toString(block));
    if (!(CatchClause.isCatchClause(handler) || Null.isNull(handler))) throw new Error('handler is not a CatchClause | Null: ' + Class.toString(handler));
    if (!(BlockStatement.isBlockStatement(finalizer) || Null.isNull(finalizer))) throw new Error('finalizer is not a BlockStatement | Null: ' + Class.toString(finalizer));
    this.location = location;
    this.type = type;
    this.block = block;
    this.handler = handler;
    this.finalizer = finalizer;
    Object.freeze(this);
  }

  patch(properties) {
    return new TryStatement({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isTryStatement(value);
  }

}

exports.TryStatement = TryStatement;
TryStatement.id = 'TryStatement';
TryStatement.implements = new Set(['TryStatement', 'ion_Object', 'Statement', 'Typed', 'Node']);

function isTryStatement(value) {
  return Class.isInstance(TryStatement, value);
}

exports.isTryStatement = isTryStatement;
exports.default = TryStatement;
},{"./Location":"VU7R","./ion/Null":"ozVR","./Type":"kwdr","./BlockStatement":"I4Ao","./CatchClause":"X9Am","./ion/Class":"iy0N"}],"z1pI":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isTypeExpression = exports.TypeExpression = void 0;

const Type = __importStar(require("./Type"));

const Expression = __importStar(require("./Expression"));

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Class = __importStar(require("./ion/Class"));

class TypeExpression {
  constructor({
    location = null,
    type = null,
    value
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!Expression.isExpression(value)) throw new Error('value is not a Expression: ' + Class.toString(value));
    this.location = location;
    this.type = type;
    this.value = value;
    Object.freeze(this);
  }

  patch(properties) {
    return new TypeExpression({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isTypeExpression(value);
  }

}

exports.TypeExpression = TypeExpression;
TypeExpression.id = 'TypeExpression';
TypeExpression.implements = new Set(['TypeExpression', 'ion_Object', 'Type', 'Expression', 'Typed', 'Node']);

function isTypeExpression(value) {
  return Class.isInstance(TypeExpression, value);
}

exports.isTypeExpression = isTypeExpression;
exports.default = TypeExpression;
},{"./Type":"kwdr","./Expression":"zMtI","./Location":"VU7R","./ion/Null":"ozVR","./ion/Class":"iy0N"}],"WUcu":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isTyped = exports.Typed = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const Class = __importStar(require("./ion/Class"));

class Typed {
  constructor({
    location = null,
    type = null
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    this.location = location;
    this.type = type;
    Object.freeze(this);
  }

  patch(properties) {
    return new Typed({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isTyped(value);
  }

}

exports.Typed = Typed;
Typed.id = 'Typed';
Typed.implements = new Set(['Typed', 'ion_Object', 'Node']);

function isTyped(value) {
  return Class.isInstance(Typed, value);
}

exports.isTyped = isTyped;
exports.default = Typed;
},{"./Location":"VU7R","./ion/Null":"ozVR","./Type":"kwdr","./ion/Class":"iy0N"}],"rGFG":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isUnaryExpression = exports.UnaryExpression = void 0;

const Expression = __importStar(require("./Expression"));

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const String = __importStar(require("./ion/String"));

const Boolean = __importStar(require("./ion/Boolean"));

const Class = __importStar(require("./ion/Class"));

class UnaryExpression {
  constructor({
    location = null,
    type = null,
    operator,
    argument,
    prefix = true
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!String.isString(operator)) throw new Error('operator is not a String: ' + Class.toString(operator));
    if (!Expression.isExpression(argument)) throw new Error('argument is not a Expression: ' + Class.toString(argument));
    if (!Boolean.isBoolean(prefix)) throw new Error('prefix is not a Boolean: ' + Class.toString(prefix));
    this.location = location;
    this.type = type;
    this.operator = operator;
    this.argument = argument;
    this.prefix = prefix;
    Object.freeze(this);
  }

  patch(properties) {
    return new UnaryExpression({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isUnaryExpression(value);
  }

}

exports.UnaryExpression = UnaryExpression;
UnaryExpression.id = 'UnaryExpression';
UnaryExpression.implements = new Set(['UnaryExpression', 'ion_Object', 'Expression', 'Typed', 'Node']);

function isUnaryExpression(value) {
  return Class.isInstance(UnaryExpression, value);
}

exports.isUnaryExpression = isUnaryExpression;
exports.default = UnaryExpression;
},{"./Expression":"zMtI","./Location":"VU7R","./ion/Null":"ozVR","./Type":"kwdr","./ion/String":"CAX3","./ion/Boolean":"eJLV","./ion/Class":"iy0N"}],"WykT":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isVariable = exports.Variable = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const Pattern = __importStar(require("./Pattern"));

const Expression = __importStar(require("./Expression"));

const Class = __importStar(require("./ion/Class"));

class Variable {
  constructor({
    location = null,
    type = null,
    id,
    value = null
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!(Pattern.isPattern(id) || Expression.isExpression(id))) throw new Error('id is not a Pattern | Expression: ' + Class.toString(id));
    if (!(Expression.isExpression(value) || Null.isNull(value))) throw new Error('value is not a Expression | Null: ' + Class.toString(value));
    this.location = location;
    this.type = type;
    this.id = id;
    this.value = value;
    Object.freeze(this);
  }

  patch(properties) {
    return new Variable({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isVariable(value);
  }

}

exports.Variable = Variable;
Variable.id = 'Variable';
Variable.implements = new Set(['Variable', 'ion_Object', 'Typed', 'Node']);

function isVariable(value) {
  return Class.isInstance(Variable, value);
}

exports.isVariable = isVariable;
exports.default = Variable;
},{"./Location":"VU7R","./ion/Null":"ozVR","./Type":"kwdr","./Pattern":"qBpR","./Expression":"zMtI","./ion/Class":"iy0N"}],"cyio":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isWhileStatement = exports.WhileStatement = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const Expression = __importStar(require("./Expression"));

const BlockStatement = __importStar(require("./BlockStatement"));

const Class = __importStar(require("./ion/Class"));

class WhileStatement {
  constructor({
    location = null,
    type = null,
    test,
    body
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!Expression.isExpression(test)) throw new Error('test is not a Expression: ' + Class.toString(test));
    if (!BlockStatement.isBlockStatement(body)) throw new Error('body is not a BlockStatement: ' + Class.toString(body));
    this.location = location;
    this.type = type;
    this.test = test;
    this.body = body;
    Object.freeze(this);
  }

  patch(properties) {
    return new WhileStatement({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isWhileStatement(value);
  }

}

exports.WhileStatement = WhileStatement;
WhileStatement.id = 'WhileStatement';
WhileStatement.implements = new Set(['WhileStatement', 'ion_Object', 'Statement', 'Typed', 'Node']);

function isWhileStatement(value) {
  return Class.isInstance(WhileStatement, value);
}

exports.isWhileStatement = isWhileStatement;
exports.default = WhileStatement;
},{"./Location":"VU7R","./ion/Null":"ozVR","./Type":"kwdr","./Expression":"zMtI","./BlockStatement":"I4Ao","./ion/Class":"iy0N"}],"ef5A":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isYieldExpression = exports.YieldExpression = void 0;

const Expression = __importStar(require("./Expression"));

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const Boolean = __importStar(require("./ion/Boolean"));

const Class = __importStar(require("./ion/Class"));

class YieldExpression {
  constructor({
    location = null,
    type = null,
    argument,
    delegate = false
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!Expression.isExpression(argument)) throw new Error('argument is not a Expression: ' + Class.toString(argument));
    if (!Boolean.isBoolean(delegate)) throw new Error('delegate is not a Boolean: ' + Class.toString(delegate));
    this.location = location;
    this.type = type;
    this.argument = argument;
    this.delegate = delegate;
    Object.freeze(this);
  }

  patch(properties) {
    return new YieldExpression({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isYieldExpression(value);
  }

}

exports.YieldExpression = YieldExpression;
YieldExpression.id = 'YieldExpression';
YieldExpression.implements = new Set(['YieldExpression', 'ion_Object', 'Expression', 'Typed', 'Node']);

function isYieldExpression(value) {
  return Class.isInstance(YieldExpression, value);
}

exports.isYieldExpression = isYieldExpression;
exports.default = YieldExpression;
},{"./Expression":"zMtI","./Location":"VU7R","./ion/Null":"ozVR","./Type":"kwdr","./ion/Boolean":"eJLV","./ion/Class":"iy0N"}],"tHlf":[function(require,module,exports) {
"use strict";

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Property = exports.Program = exports.Position = exports.Pattern = exports.Parameter = exports.OutlineOperation = exports.ObjectPattern = exports.ObjectExpression = exports.Node = exports.ModuleSpecifier = exports.MethodDefinition = exports.MemberExpression = exports.Location = exports.Literal = exports.InstanceDeclarations = exports.ImportSpecifier = exports.ImportNamespaceSpecifier = exports.ImportDefaultSpecifier = exports.ImportDeclaration = exports.IfStatement = exports.Identifier = exports.FunctionType = exports.FunctionExpression = exports.ForStatement = exports.ForOfStatement = exports.ExpressionStatement = exports.Expression = exports.Exportable = exports.ElementExpression = exports.DotExpression = exports.Declarator = exports.Declaration = exports.ContinueStatement = exports.ConditionalExpression = exports.ConditionalDeclaration = exports.ClassDeclaration = exports.ChainElement = exports.CatchClause = exports.CallExpression = exports.BreakStatement = exports.BlockStatement = exports.BinaryExpression = exports.AwaitExpression = exports.AssignmentStatement = exports.AssignmentPattern = exports.Assembly = exports.ArrowFunctionExpression = exports.ArrayPattern = exports.ArrayExpression = exports.Analysis = void 0;
exports.YieldExpression = exports.WhileStatement = exports.VariableDeclaration = exports.Variable = exports.UnaryExpression = exports.Typed = exports.TypeExpression = exports.Type = exports.TryStatement = exports.ThrowStatement = exports.ThisExpression = exports.SwitchStatement = exports.SwitchCase = exports.Statement = exports.SpreadElement = exports.Scope = exports.ReturnStatement = exports.RestElement = exports.RegularExpression = exports.Reference = exports.PropertyStatement = void 0;

var Analysis_1 = require("./Analysis");

Object.defineProperty(exports, "Analysis", {
  enumerable: true,
  get: function () {
    return __importDefault(Analysis_1).default;
  }
});

var ArrayExpression_1 = require("./ArrayExpression");

Object.defineProperty(exports, "ArrayExpression", {
  enumerable: true,
  get: function () {
    return __importDefault(ArrayExpression_1).default;
  }
});

var ArrayPattern_1 = require("./ArrayPattern");

Object.defineProperty(exports, "ArrayPattern", {
  enumerable: true,
  get: function () {
    return __importDefault(ArrayPattern_1).default;
  }
});

var ArrowFunctionExpression_1 = require("./ArrowFunctionExpression");

Object.defineProperty(exports, "ArrowFunctionExpression", {
  enumerable: true,
  get: function () {
    return __importDefault(ArrowFunctionExpression_1).default;
  }
});

var Assembly_1 = require("./Assembly");

Object.defineProperty(exports, "Assembly", {
  enumerable: true,
  get: function () {
    return __importDefault(Assembly_1).default;
  }
});

var AssignmentPattern_1 = require("./AssignmentPattern");

Object.defineProperty(exports, "AssignmentPattern", {
  enumerable: true,
  get: function () {
    return __importDefault(AssignmentPattern_1).default;
  }
});

var AssignmentStatement_1 = require("./AssignmentStatement");

Object.defineProperty(exports, "AssignmentStatement", {
  enumerable: true,
  get: function () {
    return __importDefault(AssignmentStatement_1).default;
  }
});

var AwaitExpression_1 = require("./AwaitExpression");

Object.defineProperty(exports, "AwaitExpression", {
  enumerable: true,
  get: function () {
    return __importDefault(AwaitExpression_1).default;
  }
});

var BinaryExpression_1 = require("./BinaryExpression");

Object.defineProperty(exports, "BinaryExpression", {
  enumerable: true,
  get: function () {
    return __importDefault(BinaryExpression_1).default;
  }
});

var BlockStatement_1 = require("./BlockStatement");

Object.defineProperty(exports, "BlockStatement", {
  enumerable: true,
  get: function () {
    return __importDefault(BlockStatement_1).default;
  }
});

var BreakStatement_1 = require("./BreakStatement");

Object.defineProperty(exports, "BreakStatement", {
  enumerable: true,
  get: function () {
    return __importDefault(BreakStatement_1).default;
  }
});

var CallExpression_1 = require("./CallExpression");

Object.defineProperty(exports, "CallExpression", {
  enumerable: true,
  get: function () {
    return __importDefault(CallExpression_1).default;
  }
});

var CatchClause_1 = require("./CatchClause");

Object.defineProperty(exports, "CatchClause", {
  enumerable: true,
  get: function () {
    return __importDefault(CatchClause_1).default;
  }
});

var ChainElement_1 = require("./ChainElement");

Object.defineProperty(exports, "ChainElement", {
  enumerable: true,
  get: function () {
    return __importDefault(ChainElement_1).default;
  }
});

var ClassDeclaration_1 = require("./ClassDeclaration");

Object.defineProperty(exports, "ClassDeclaration", {
  enumerable: true,
  get: function () {
    return __importDefault(ClassDeclaration_1).default;
  }
});

var ConditionalDeclaration_1 = require("./ConditionalDeclaration");

Object.defineProperty(exports, "ConditionalDeclaration", {
  enumerable: true,
  get: function () {
    return __importDefault(ConditionalDeclaration_1).default;
  }
});

var ConditionalExpression_1 = require("./ConditionalExpression");

Object.defineProperty(exports, "ConditionalExpression", {
  enumerable: true,
  get: function () {
    return __importDefault(ConditionalExpression_1).default;
  }
});

var ContinueStatement_1 = require("./ContinueStatement");

Object.defineProperty(exports, "ContinueStatement", {
  enumerable: true,
  get: function () {
    return __importDefault(ContinueStatement_1).default;
  }
});

var Declaration_1 = require("./Declaration");

Object.defineProperty(exports, "Declaration", {
  enumerable: true,
  get: function () {
    return __importDefault(Declaration_1).default;
  }
});

var Declarator_1 = require("./Declarator");

Object.defineProperty(exports, "Declarator", {
  enumerable: true,
  get: function () {
    return __importDefault(Declarator_1).default;
  }
});

var DotExpression_1 = require("./DotExpression");

Object.defineProperty(exports, "DotExpression", {
  enumerable: true,
  get: function () {
    return __importDefault(DotExpression_1).default;
  }
});

var ElementExpression_1 = require("./ElementExpression");

Object.defineProperty(exports, "ElementExpression", {
  enumerable: true,
  get: function () {
    return __importDefault(ElementExpression_1).default;
  }
});

var Exportable_1 = require("./Exportable");

Object.defineProperty(exports, "Exportable", {
  enumerable: true,
  get: function () {
    return __importDefault(Exportable_1).default;
  }
});

var Expression_1 = require("./Expression");

Object.defineProperty(exports, "Expression", {
  enumerable: true,
  get: function () {
    return __importDefault(Expression_1).default;
  }
});

var ExpressionStatement_1 = require("./ExpressionStatement");

Object.defineProperty(exports, "ExpressionStatement", {
  enumerable: true,
  get: function () {
    return __importDefault(ExpressionStatement_1).default;
  }
});

var ForOfStatement_1 = require("./ForOfStatement");

Object.defineProperty(exports, "ForOfStatement", {
  enumerable: true,
  get: function () {
    return __importDefault(ForOfStatement_1).default;
  }
});

var ForStatement_1 = require("./ForStatement");

Object.defineProperty(exports, "ForStatement", {
  enumerable: true,
  get: function () {
    return __importDefault(ForStatement_1).default;
  }
});

var FunctionExpression_1 = require("./FunctionExpression");

Object.defineProperty(exports, "FunctionExpression", {
  enumerable: true,
  get: function () {
    return __importDefault(FunctionExpression_1).default;
  }
});

var FunctionType_1 = require("./FunctionType");

Object.defineProperty(exports, "FunctionType", {
  enumerable: true,
  get: function () {
    return __importDefault(FunctionType_1).default;
  }
});

var Identifier_1 = require("./Identifier");

Object.defineProperty(exports, "Identifier", {
  enumerable: true,
  get: function () {
    return __importDefault(Identifier_1).default;
  }
});

var IfStatement_1 = require("./IfStatement");

Object.defineProperty(exports, "IfStatement", {
  enumerable: true,
  get: function () {
    return __importDefault(IfStatement_1).default;
  }
});

var ImportDeclaration_1 = require("./ImportDeclaration");

Object.defineProperty(exports, "ImportDeclaration", {
  enumerable: true,
  get: function () {
    return __importDefault(ImportDeclaration_1).default;
  }
});

var ImportDefaultSpecifier_1 = require("./ImportDefaultSpecifier");

Object.defineProperty(exports, "ImportDefaultSpecifier", {
  enumerable: true,
  get: function () {
    return __importDefault(ImportDefaultSpecifier_1).default;
  }
});

var ImportNamespaceSpecifier_1 = require("./ImportNamespaceSpecifier");

Object.defineProperty(exports, "ImportNamespaceSpecifier", {
  enumerable: true,
  get: function () {
    return __importDefault(ImportNamespaceSpecifier_1).default;
  }
});

var ImportSpecifier_1 = require("./ImportSpecifier");

Object.defineProperty(exports, "ImportSpecifier", {
  enumerable: true,
  get: function () {
    return __importDefault(ImportSpecifier_1).default;
  }
});

var InstanceDeclarations_1 = require("./InstanceDeclarations");

Object.defineProperty(exports, "InstanceDeclarations", {
  enumerable: true,
  get: function () {
    return __importDefault(InstanceDeclarations_1).default;
  }
});

var Literal_1 = require("./Literal");

Object.defineProperty(exports, "Literal", {
  enumerable: true,
  get: function () {
    return __importDefault(Literal_1).default;
  }
});

var Location_1 = require("./Location");

Object.defineProperty(exports, "Location", {
  enumerable: true,
  get: function () {
    return __importDefault(Location_1).default;
  }
});

var MemberExpression_1 = require("./MemberExpression");

Object.defineProperty(exports, "MemberExpression", {
  enumerable: true,
  get: function () {
    return __importDefault(MemberExpression_1).default;
  }
});

var MethodDefinition_1 = require("./MethodDefinition");

Object.defineProperty(exports, "MethodDefinition", {
  enumerable: true,
  get: function () {
    return __importDefault(MethodDefinition_1).default;
  }
});

var ModuleSpecifier_1 = require("./ModuleSpecifier");

Object.defineProperty(exports, "ModuleSpecifier", {
  enumerable: true,
  get: function () {
    return __importDefault(ModuleSpecifier_1).default;
  }
});

var Node_1 = require("./Node");

Object.defineProperty(exports, "Node", {
  enumerable: true,
  get: function () {
    return __importDefault(Node_1).default;
  }
});

var ObjectExpression_1 = require("./ObjectExpression");

Object.defineProperty(exports, "ObjectExpression", {
  enumerable: true,
  get: function () {
    return __importDefault(ObjectExpression_1).default;
  }
});

var ObjectPattern_1 = require("./ObjectPattern");

Object.defineProperty(exports, "ObjectPattern", {
  enumerable: true,
  get: function () {
    return __importDefault(ObjectPattern_1).default;
  }
});

var OutlineOperation_1 = require("./OutlineOperation");

Object.defineProperty(exports, "OutlineOperation", {
  enumerable: true,
  get: function () {
    return __importDefault(OutlineOperation_1).default;
  }
});

var Parameter_1 = require("./Parameter");

Object.defineProperty(exports, "Parameter", {
  enumerable: true,
  get: function () {
    return __importDefault(Parameter_1).default;
  }
});

var Pattern_1 = require("./Pattern");

Object.defineProperty(exports, "Pattern", {
  enumerable: true,
  get: function () {
    return __importDefault(Pattern_1).default;
  }
});

var Position_1 = require("./Position");

Object.defineProperty(exports, "Position", {
  enumerable: true,
  get: function () {
    return __importDefault(Position_1).default;
  }
});

var Program_1 = require("./Program");

Object.defineProperty(exports, "Program", {
  enumerable: true,
  get: function () {
    return __importDefault(Program_1).default;
  }
});

var Property_1 = require("./Property");

Object.defineProperty(exports, "Property", {
  enumerable: true,
  get: function () {
    return __importDefault(Property_1).default;
  }
});

var PropertyStatement_1 = require("./PropertyStatement");

Object.defineProperty(exports, "PropertyStatement", {
  enumerable: true,
  get: function () {
    return __importDefault(PropertyStatement_1).default;
  }
});

var Reference_1 = require("./Reference");

Object.defineProperty(exports, "Reference", {
  enumerable: true,
  get: function () {
    return __importDefault(Reference_1).default;
  }
});

var RegularExpression_1 = require("./RegularExpression");

Object.defineProperty(exports, "RegularExpression", {
  enumerable: true,
  get: function () {
    return __importDefault(RegularExpression_1).default;
  }
});

var RestElement_1 = require("./RestElement");

Object.defineProperty(exports, "RestElement", {
  enumerable: true,
  get: function () {
    return __importDefault(RestElement_1).default;
  }
});

var ReturnStatement_1 = require("./ReturnStatement");

Object.defineProperty(exports, "ReturnStatement", {
  enumerable: true,
  get: function () {
    return __importDefault(ReturnStatement_1).default;
  }
});

var Scope_1 = require("./Scope");

Object.defineProperty(exports, "Scope", {
  enumerable: true,
  get: function () {
    return __importDefault(Scope_1).default;
  }
});

var SpreadElement_1 = require("./SpreadElement");

Object.defineProperty(exports, "SpreadElement", {
  enumerable: true,
  get: function () {
    return __importDefault(SpreadElement_1).default;
  }
});

var Statement_1 = require("./Statement");

Object.defineProperty(exports, "Statement", {
  enumerable: true,
  get: function () {
    return __importDefault(Statement_1).default;
  }
});

var SwitchCase_1 = require("./SwitchCase");

Object.defineProperty(exports, "SwitchCase", {
  enumerable: true,
  get: function () {
    return __importDefault(SwitchCase_1).default;
  }
});

var SwitchStatement_1 = require("./SwitchStatement");

Object.defineProperty(exports, "SwitchStatement", {
  enumerable: true,
  get: function () {
    return __importDefault(SwitchStatement_1).default;
  }
});

var ThisExpression_1 = require("./ThisExpression");

Object.defineProperty(exports, "ThisExpression", {
  enumerable: true,
  get: function () {
    return __importDefault(ThisExpression_1).default;
  }
});

var ThrowStatement_1 = require("./ThrowStatement");

Object.defineProperty(exports, "ThrowStatement", {
  enumerable: true,
  get: function () {
    return __importDefault(ThrowStatement_1).default;
  }
});

var TryStatement_1 = require("./TryStatement");

Object.defineProperty(exports, "TryStatement", {
  enumerable: true,
  get: function () {
    return __importDefault(TryStatement_1).default;
  }
});

var Type_1 = require("./Type");

Object.defineProperty(exports, "Type", {
  enumerable: true,
  get: function () {
    return __importDefault(Type_1).default;
  }
});

var TypeExpression_1 = require("./TypeExpression");

Object.defineProperty(exports, "TypeExpression", {
  enumerable: true,
  get: function () {
    return __importDefault(TypeExpression_1).default;
  }
});

var Typed_1 = require("./Typed");

Object.defineProperty(exports, "Typed", {
  enumerable: true,
  get: function () {
    return __importDefault(Typed_1).default;
  }
});

var UnaryExpression_1 = require("./UnaryExpression");

Object.defineProperty(exports, "UnaryExpression", {
  enumerable: true,
  get: function () {
    return __importDefault(UnaryExpression_1).default;
  }
});

var Variable_1 = require("./Variable");

Object.defineProperty(exports, "Variable", {
  enumerable: true,
  get: function () {
    return __importDefault(Variable_1).default;
  }
});

var VariableDeclaration_1 = require("./VariableDeclaration");

Object.defineProperty(exports, "VariableDeclaration", {
  enumerable: true,
  get: function () {
    return __importDefault(VariableDeclaration_1).default;
  }
});

var WhileStatement_1 = require("./WhileStatement");

Object.defineProperty(exports, "WhileStatement", {
  enumerable: true,
  get: function () {
    return __importDefault(WhileStatement_1).default;
  }
});

var YieldExpression_1 = require("./YieldExpression");

Object.defineProperty(exports, "YieldExpression", {
  enumerable: true,
  get: function () {
    return __importDefault(YieldExpression_1).default;
  }
});
},{"./Analysis":"Zz3f","./ArrayExpression":"i6OL","./ArrayPattern":"WzJa","./ArrowFunctionExpression":"j5r3","./Assembly":"MADx","./AssignmentPattern":"gGtP","./AssignmentStatement":"IblK","./AwaitExpression":"nmv9","./BinaryExpression":"LQtK","./BlockStatement":"I4Ao","./BreakStatement":"Ho18","./CallExpression":"qwkJ","./CatchClause":"X9Am","./ChainElement":"u2aQ","./ClassDeclaration":"b3SL","./ConditionalDeclaration":"tYb2","./ConditionalExpression":"iQCi","./ContinueStatement":"fi0y","./Declaration":"Ih7j","./Declarator":"gz3F","./DotExpression":"qkdi","./ElementExpression":"BWYI","./Exportable":"Kv8W","./Expression":"zMtI","./ExpressionStatement":"jtwp","./ForOfStatement":"k7LE","./ForStatement":"EYTx","./FunctionExpression":"mzLz","./FunctionType":"iqg9","./Identifier":"lIID","./IfStatement":"vQyy","./ImportDeclaration":"g7Am","./ImportDefaultSpecifier":"yw5q","./ImportNamespaceSpecifier":"NN6s","./ImportSpecifier":"r0zz","./InstanceDeclarations":"m0dC","./Literal":"jxHw","./Location":"VU7R","./MemberExpression":"Ukrj","./MethodDefinition":"N0RR","./ModuleSpecifier":"xPps","./Node":"wYgM","./ObjectExpression":"cWiT","./ObjectPattern":"lvQy","./OutlineOperation":"ywPB","./Parameter":"O8G7","./Pattern":"qBpR","./Position":"CUCB","./Program":"ByPT","./Property":"kVPM","./PropertyStatement":"JB1h","./Reference":"zd4v","./RegularExpression":"WQbd","./RestElement":"CZHB","./ReturnStatement":"GuMA","./Scope":"LFRz","./SpreadElement":"xOhy","./Statement":"diY0","./SwitchCase":"arKK","./SwitchStatement":"R7gG","./ThisExpression":"Fqwb","./ThrowStatement":"mZrm","./TryStatement":"oCbk","./Type":"kwdr","./TypeExpression":"z1pI","./Typed":"WUcu","./UnaryExpression":"rGFG","./Variable":"WykT","./VariableDeclaration":"KDXm","./WhileStatement":"cyio","./YieldExpression":"ef5A"}],"gPgA":[function(require,module,exports) {
var process = require("process");
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.write = exports.makeDirectories = exports.exists = exports.getInputFilesRecursive = exports.getPathFromFilename = exports.read = exports.findPackage = exports.difference = exports.intersection = exports.union = exports.getLast = exports.mapValues = exports.toMap = exports.SemanticError = exports.freeze = exports.clone = exports.getOriginalDeclaration = exports.getAncestor = exports.getAncestorsAndSelfList = exports.getDeclarator = exports.getOriginalDeclarator = exports.isValidId = exports.memoize = exports.memoizeIntern = exports.getNodesOfType = exports.runtimeModuleName = void 0;

const fs = __importStar(require("fs"));

const np = __importStar(require("path"));

const traverse_1 = require("@glas/traverse");

const ast_1 = require("./ast");

exports.runtimeModuleName = "ionscript";

function getNodesOfType(root, predicate) {
  let nodes = new Array();
  traverse_1.traverse(root, {
    enter(node) {
      if (predicate(node)) {
        nodes.push(node);
      }
    }

  });
  return nodes;
}

exports.getNodesOfType = getNodesOfType;

function memoizeIntern(fn) {
  const cache = new Map();
  return memoize(fn, false, cache);
}

exports.memoizeIntern = memoizeIntern;

function memoize(fn, cacheResultAsKey = false, cache = new WeakMap()) {
  return function (arg) {
    let result = cache.get(arg);

    if (result === undefined) {
      cache.set(arg, result = fn.apply(this, arguments));

      if (cacheResultAsKey) {
        cache.set(result, result);
      }
    }

    return result;
  };
}

exports.memoize = memoize;
const validIdRegex = /^[a-z_][a-z0-9_]*$/i;

function isValidId(name) {
  return validIdRegex.test(name);
}

exports.isValidId = isValidId; ////////////////////////////////////////////////////////////////////////////////
//  Miscelaneous Functions
////////////////////////////////////////////////////////////////////////////////

function getOriginalDeclarator(declarator, scopes, ancestors) {
  let parent = ancestors.get(declarator);

  if (ast_1.ModuleSpecifier.is(parent)) {
    let importDeclaration = ancestors.get(parent);
    let sourceModuleDeclaration = scopes.get(declarator)[importDeclaration.source.value];

    if (sourceModuleDeclaration) {
      if (ast_1.ImportNamespaceSpecifier.is(parent)) {
        return sourceModuleDeclaration;
      }

      let name;

      if (ast_1.ImportSpecifier.is(parent)) {
        name = parent.imported.name;
      } else if (ast_1.ImportDefaultSpecifier.is(parent)) {
        name = "default";
      } else {
        throw new Error();
      }

      let sourceProgramScope = scopes.get(sourceModuleDeclaration);
      let sourceDeclarator = sourceProgramScope[name];

      if (sourceDeclarator == null) {
        throw SemanticError(`${importDeclaration.source.value} does not have export ${name}`, parent);
      }

      let sourceDeclaratorParent = ancestors.get(sourceDeclarator);

      if (!ast_1.Exportable.is(sourceDeclaratorParent) || !sourceDeclaratorParent.export) {
        throw SemanticError(`${importDeclaration.source.value} ${name} is not exported`, parent);
      } // recurse in case this exported value is also a reference or re-export
      // return sourceDeclarator


      return getOriginalDeclarator(sourceDeclarator, scopes, ancestors);
    }
  } // traverse variables that are just constant re-declarations


  if (ast_1.VariableDeclaration.is(parent) && parent.kind !== "var" && ast_1.Reference.is(parent.value)) {
    // keep following references to the original
    return getDeclarator(parent.value, scopes, ancestors, true, false);
  }

  return declarator;
}

exports.getOriginalDeclarator = getOriginalDeclarator;

function getDeclarator(ref, scopes, ancestors, traverseReferences = false, throwError = true) {
  let scope = scopes.get(ref);
  let declarator = scope[ref.name];

  if (declarator == null) {
    if (throwError) {
      throw SemanticError(`${ref.name} declarator not found`, ref);
    } else {
      return null;
    }
  }

  return traverseReferences ? getOriginalDeclarator(declarator, scopes, ancestors) : declarator;
}

exports.getDeclarator = getDeclarator;
/**
 * Returns an array of self and ancestors where 0 == self and length - 1 = root
 */

function getAncestorsAndSelfList(node, ancestorsMap) {
  let ancestorsList = new Array();

  while (node != null) {
    ancestorsList.push(node);
    node = ancestorsMap.get(node);
  }

  return ancestorsList;
}

exports.getAncestorsAndSelfList = getAncestorsAndSelfList;

function getAncestor(node, ancestors, predicate) {
  while (node != null) {
    let ancestor = ancestors.get(node);

    if (predicate(ancestor)) {
      return ancestor;
    }

    node = ancestor;
  }

  return null;
}

exports.getAncestor = getAncestor;

function getOriginalDeclaration(ref, scopes, ancestors, predicate = ast_1.Declaration.is) {
  let declarator = getDeclarator(ref, scopes, ancestors, true, false);
  return declarator != null ? getAncestor(declarator, ancestors, predicate) : null;
}

exports.getOriginalDeclaration = getOriginalDeclaration;

function clone(value) {
  if (value == null || typeof value !== "object") {
    return value;
  }

  if (value.clone) {
    return value.clone();
  }

  if (value instanceof Set) {
    return new Set(Array.from(value.values()).map(clone));
  }

  if (value instanceof Map) {
    return new Map(Array.from(value.entries()).map(clone));
  }

  if (Array.isArray(value)) {
    return value.map(clone);
  }

  if (ast_1.Node.is(value)) {
    return new value.constructor(value);
  }

  let newValues = {};

  for (let name in value) {
    newValues[name] = clone(value[name]);
  }

  let copy = new value.constructor(newValues);
  return copy;
}

exports.clone = clone;

function freeze(object, deep = true) {
  if (object != null && typeof object === 'object') {
    Object.freeze(object);

    if (deep) {
      for (let name in object) {
        freeze(object[name]);
      }
    }
  }
}

exports.freeze = freeze;

function SemanticError(message, location) {
  let error = new Error(message);
  error.location = location.location || location;
  return error;
}

exports.SemanticError = SemanticError;

function toMap(object) {
  let result = new Map();

  for (let name in object) {
    result.set(name, object[name]);
  }

  return result;
}

exports.toMap = toMap;

function mapValues(object, fn) {
  let result = new Map();

  for (let key of object.keys()) {
    let value = object.get(key);
    result.set(key, fn(value, key));
  }

  return result;
}

exports.mapValues = mapValues;

function getLast(array, predicate) {
  for (let i = array.length - 1; i >= 0; i--) {
    let item = array[i];

    if (predicate(item)) {
      return item;
    }
  }

  return null;
}

exports.getLast = getLast; ////////////////////////////////////////////////////////////////////////////////
//  Set Functions
////////////////////////////////////////////////////////////////////////////////

function union(a, b) {
  let result = new Set();

  for (let e of a) result.add(e);

  for (let e of b) result.add(e);

  return result;
}

exports.union = union;

function intersection(a, b) {
  let result = new Set();

  for (let e of a) {
    if (b.has(e)) result.add(e);
  }

  return result;
}

exports.intersection = intersection;

function difference(a, b) {
  let result = new Set();

  for (let e of a) {
    if (!b.has(e)) result.add(e);
  }

  return result;
}

exports.difference = difference; ////////////////////////////////////////////////////////////////////////////////
//  File operations
////////////////////////////////////////////////////////////////////////////////

const ionExt = '.is';

function findPackage(dir = process.cwd()) {
  let checkFilename = np.join(dir, "package.json"); // console.log("check", checkFilename)

  if (fs.existsSync(checkFilename)) {
    return require(checkFilename);
  }

  let newDir = np.dirname(dir);

  if (newDir != dir) {
    return findPackage(newDir);
  }

  return null;
}

exports.findPackage = findPackage;

function read(file) {
  return fs.readFileSync(file, 'utf8');
}

exports.read = read;

function getPathFromFilename(namespace, filename) {
  let path = filename.substring(0, filename.length - ionExt.length).split(/[\/\\]+/g);
  return namespace.replace(/[\/\\]/g, "/") + "/" + path.join("/");
}

exports.getPathFromFilename = getPathFromFilename;

function getInputFilesRecursive(directory, namespace, rootDirectory = null, allFiles = {}) {
  if (Array.isArray(directory)) {
    for (let dir of directory) {
      getInputFilesRecursive(dir, namespace, dir, allFiles);
    }
  } else {
    if (rootDirectory == null) rootDirectory = directory;

    for (let name of fs.readdirSync(directory)) {
      let filename = np.join(directory, name);
      let fileInfo = fs.statSync(filename);

      if (fileInfo.isFile()) {
        if (name.endsWith(ionExt)) {
          let path = getPathFromFilename(namespace, filename.substring(rootDirectory.length + 1));
          allFiles[path] = read(filename);
        }
      } else {
        getInputFilesRecursive(filename, namespace, rootDirectory, allFiles);
      }
    }
  }

  return allFiles;
}

exports.getInputFilesRecursive = getInputFilesRecursive;

function exists(file) {
  return fs.existsSync(file);
}

exports.exists = exists;

function makeDirectories(dir) {
  if (!exists(dir)) {
    // make parent first
    makeDirectories(np.dirname(dir)); // make self

    fs.mkdirSync(dir);
  }
}

exports.makeDirectories = makeDirectories;

function write(file, content, encoding) {
  makeDirectories(np.dirname(file));

  if (content != null) {
    if (encoding === undefined && typeof content === 'string') encoding = 'utf8';
    fs.writeFileSync(file, content, {
      encoding
    });
  } else if (exists(file)) {
    fs.unlinkSync(file);
  }
}

exports.write = write;
},{"fs":"Zcgp","path":"FHml","@glas/traverse":"bYRw","./ast":"tHlf","process":"rH1J"}],"HyZG":[function(require,module,exports) {

exports.isBrowser = typeof window !== 'undefined';

},{}],"u9RV":[function(require,module,exports) {

var Processor = function Processor(options){
  this.selfOptions = options || {};
  this.pipes = {};
};

Processor.prototype.options = function(options) {
  if (options) {
    this.selfOptions = options;
  }
  return this.selfOptions;
};

Processor.prototype.pipe = function(name, pipe) {
  if (typeof name === 'string') {
    if (typeof pipe === 'undefined') {
      return this.pipes[name];
    } else {
      this.pipes[name] = pipe;
    }
  }
  if (name && name.name) {
    pipe = name;
    if (pipe.processor === this) { return pipe; }
    this.pipes[pipe.name] = pipe;
  }
  pipe.processor = this;
  return pipe;
};

Processor.prototype.process = function(input, pipe) {
  var context = input;
  context.options = this.options();
  var nextPipe = pipe || input.pipe || 'default';
  var lastPipe, lastContext;
  while (nextPipe) {
    if (typeof context.nextAfterChildren !== 'undefined') {
      // children processed and coming back to parent
      context.next = context.nextAfterChildren;
      context.nextAfterChildren = null;
    }

    if (typeof nextPipe === 'string') {
      nextPipe = this.pipe(nextPipe);
    }
    nextPipe.process(context);
    lastContext = context;
    lastPipe = nextPipe;
    nextPipe = null;
    if (context) {
      if (context.next) {
        context = context.next;
        nextPipe = lastContext.nextPipe || context.pipe || lastPipe;
      }
    }
  }
  return context.hasResult ? context.result : undefined;
};

exports.Processor = Processor;

},{}],"S41N":[function(require,module,exports) {
var Pipe = function Pipe(name) {
  this.name = name;
  this.filters = [];
};

Pipe.prototype.process = function(input) {
  if (!this.processor) {
    throw new Error('add this pipe to a processor before using it');
  }
  var debug = this.debug;
  var length = this.filters.length;
  var context = input;
  for (var index = 0; index < length; index++) {
    var filter = this.filters[index];
    if (debug) {
      this.log('filter: ' + filter.filterName);
    }
    filter(context);
    if (typeof context === 'object' && context.exiting) {
      context.exiting = false;
      break;
    }
  }
  if (!context.next && this.resultCheck) {
    this.resultCheck(context);
  }
};

Pipe.prototype.log = function(msg) {
  console.log('[jsondiffpatch] ' + this.name + ' pipe, ' + msg);
};

Pipe.prototype.append = function() {
  this.filters.push.apply(this.filters, arguments);
  return this;
};

Pipe.prototype.prepend = function() {
  this.filters.unshift.apply(this.filters, arguments);
  return this;
};

Pipe.prototype.indexOf = function(filterName) {
  if (!filterName) {
    throw new Error('a filter name is required');
  }
  for (var index = 0; index < this.filters.length; index++) {
    var filter = this.filters[index];
    if (filter.filterName === filterName) {
      return index;
    }
  }
  throw new Error('filter not found: ' + filterName);
};

Pipe.prototype.list = function() {
  var names = [];
  for (var index = 0; index < this.filters.length; index++) {
    var filter = this.filters[index];
    names.push(filter.filterName);
  }
  return names;
};

Pipe.prototype.after = function(filterName) {
  var index = this.indexOf(filterName);
  var params = Array.prototype.slice.call(arguments, 1);
  if (!params.length) {
    throw new Error('a filter is required');
  }
  params.unshift(index + 1, 0);
  Array.prototype.splice.apply(this.filters, params);
  return this;
};

Pipe.prototype.before = function(filterName) {
  var index = this.indexOf(filterName);
  var params = Array.prototype.slice.call(arguments, 1);
  if (!params.length) {
    throw new Error('a filter is required');
  }
  params.unshift(index, 0);
  Array.prototype.splice.apply(this.filters, params);
  return this;
};

Pipe.prototype.replace = function(filterName) {
  var index = this.indexOf(filterName);
  var params = Array.prototype.slice.call(arguments, 1);
  if (!params.length) {
    throw new Error('a filter is required');
  }
  params.unshift(index, 1);
  Array.prototype.splice.apply(this.filters, params);
  return this;
};

Pipe.prototype.remove = function(filterName) {
  var index = this.indexOf(filterName);
  this.filters.splice(index, 1);
  return this;
};

Pipe.prototype.clear = function() {
  this.filters.length = 0;
  return this;
};

Pipe.prototype.shouldHaveResult = function(should) {
  if (should === false) {
    this.resultCheck = null;
    return;
  }
  if (this.resultCheck) {
    return;
  }
  var pipe = this;
  this.resultCheck = function(context) {
    if (!context.hasResult) {
      console.log(context);
      var error = new Error(pipe.name + ' failed');
      error.noResult = true;
      throw error;
    }
  };
  return this;
};

exports.Pipe = Pipe;

},{}],"s376":[function(require,module,exports) {

var Pipe = require('../pipe').Pipe;

var Context = function Context(){
};

Context.prototype.setResult = function(result) {
	this.result = result;
	this.hasResult = true;
	return this;
};

Context.prototype.exit = function() {
	this.exiting = true;
	return this;
};

Context.prototype.switchTo = function(next, pipe) {
	if (typeof next === 'string' || next instanceof Pipe) {
		this.nextPipe = next;
	} else {
		this.next = next;
		if (pipe) {
			this.nextPipe = pipe;
		}
	}
	return this;
};

Context.prototype.push = function(child, name) {
	child.parent = this;
	if (typeof name !== 'undefined') {
		child.childName = name;
	}
	child.root = this.root || this;
	child.options = child.options || this.options;
	if (!this.children) {
		this.children = [child];
		this.nextAfterChildren = this.next || null;
		this.next = child;
	} else {
		this.children[this.children.length - 1].next = child;
		this.children.push(child);
	}
	child.next = this;
	return this;
};

exports.Context = Context;

},{"../pipe":"S41N"}],"ntOD":[function(require,module,exports) {

var isArray = (typeof Array.isArray === 'function') ?
  // use native function
  Array.isArray :
  // use instanceof operator
  function(a) {
    return a instanceof Array;
  };

function cloneRegExp(re) {
  var regexMatch = /^\/(.*)\/([gimyu]*)$/.exec(re.toString());
  return new RegExp(regexMatch[1], regexMatch[2]);
}

function clone(arg) {
  if (typeof arg !== 'object') {
    return arg;
  }
  if (arg === null) {
    return null;
  }
  if (isArray(arg)) {
    return arg.map(clone);
  }
  if (arg instanceof Date) {
    return new Date(arg.getTime());
  }
  if (arg instanceof RegExp) {
    return cloneRegExp(arg);
  }
  var cloned = {};
  for (var name in arg) {
    if (Object.prototype.hasOwnProperty.call(arg, name)) {
      cloned[name] = clone(arg[name]);
    }
  }
  return cloned;
}

module.exports = clone;

},{}],"jVyF":[function(require,module,exports) {
var Context = require('./context').Context;
var defaultClone = require('../clone');

var DiffContext = function DiffContext(left, right) {
  this.left = left;
  this.right = right;
  this.pipe = 'diff';
};

DiffContext.prototype = new Context();

DiffContext.prototype.setResult = function(result) {
  if (this.options.cloneDiffValues && typeof result === 'object') {
    var clone = typeof this.options.cloneDiffValues === 'function' ?
      this.options.cloneDiffValues : defaultClone;
    if (typeof result[0] === 'object') {
      result[0] = clone(result[0]);
    }
    if (typeof result[1] === 'object') {
      result[1] = clone(result[1]);
    }
  }
  return Context.prototype.setResult.apply(this, arguments);
};

exports.DiffContext = DiffContext;

},{"./context":"s376","../clone":"ntOD"}],"lHZV":[function(require,module,exports) {
var Context = require('./context').Context;

var PatchContext = function PatchContext(left, delta) {
  this.left = left;
  this.delta = delta;
  this.pipe = 'patch';
};

PatchContext.prototype = new Context();

exports.PatchContext = PatchContext;

},{"./context":"s376"}],"hVO5":[function(require,module,exports) {
var Context = require('./context').Context;

var ReverseContext = function ReverseContext(delta) {
  this.delta = delta;
  this.pipe = 'reverse';
};

ReverseContext.prototype = new Context();

exports.ReverseContext = ReverseContext;

},{"./context":"s376"}],"kYF4":[function(require,module,exports) {
var isArray = (typeof Array.isArray === 'function') ?
  // use native function
  Array.isArray :
  // use instanceof operator
  function(a) {
    return a instanceof Array;
  };

var diffFilter = function trivialMatchesDiffFilter(context) {
  if (context.left === context.right) {
    context.setResult(undefined).exit();
    return;
  }
  if (typeof context.left === 'undefined') {
    if (typeof context.right === 'function') {
      throw new Error('functions are not supported');
    }
    context.setResult([context.right]).exit();
    return;
  }
  if (typeof context.right === 'undefined') {
    context.setResult([context.left, 0, 0]).exit();
    return;
  }
  if (typeof context.left === 'function' || typeof context.right === 'function') {
    throw new Error('functions are not supported');
  }
  context.leftType = context.left === null ? 'null' : typeof context.left;
  context.rightType = context.right === null ? 'null' : typeof context.right;
  if (context.leftType !== context.rightType) {
    context.setResult([context.left, context.right]).exit();
    return;
  }
  if (context.leftType === 'boolean' || context.leftType === 'number') {
    context.setResult([context.left, context.right]).exit();
    return;
  }
  if (context.leftType === 'object') {
    context.leftIsArray = isArray(context.left);
  }
  if (context.rightType === 'object') {
    context.rightIsArray = isArray(context.right);
  }
  if (context.leftIsArray !== context.rightIsArray) {
    context.setResult([context.left, context.right]).exit();
    return;
  }

  if (context.left instanceof RegExp) {
    if (context.right instanceof RegExp) {
      context.setResult([context.left.toString(), context.right.toString()]).exit();
    } else {
      context.setResult([context.left, context.right]).exit();
      return;
    }
  }
};
diffFilter.filterName = 'trivial';

var patchFilter = function trivialMatchesPatchFilter(context) {
  if (typeof context.delta === 'undefined') {
    context.setResult(context.left).exit();
    return;
  }
  context.nested = !isArray(context.delta);
  if (context.nested) {
    return;
  }
  if (context.delta.length === 1) {
    context.setResult(context.delta[0]).exit();
    return;
  }
  if (context.delta.length === 2) {
    if (context.left instanceof RegExp) {
      var regexArgs = /^\/(.*)\/([gimyu]+)$/.exec(context.delta[1]);
      if (regexArgs) {
        context.setResult(new RegExp(regexArgs[1], regexArgs[2])).exit();
        return;
      }
    }
    context.setResult(context.delta[1]).exit();
    return;
  }
  if (context.delta.length === 3 && context.delta[2] === 0) {
    context.setResult(undefined).exit();
    return;
  }
};
patchFilter.filterName = 'trivial';

var reverseFilter = function trivialReferseFilter(context) {
  if (typeof context.delta === 'undefined') {
    context.setResult(context.delta).exit();
    return;
  }
  context.nested = !isArray(context.delta);
  if (context.nested) {
    return;
  }
  if (context.delta.length === 1) {
    context.setResult([context.delta[0], 0, 0]).exit();
    return;
  }
  if (context.delta.length === 2) {
    context.setResult([context.delta[1], context.delta[0]]).exit();
    return;
  }
  if (context.delta.length === 3 && context.delta[2] === 0) {
    context.setResult([context.delta[0]]).exit();
    return;
  }
};
reverseFilter.filterName = 'trivial';

exports.diffFilter = diffFilter;
exports.patchFilter = patchFilter;
exports.reverseFilter = reverseFilter;

},{}],"EpOW":[function(require,module,exports) {
var DiffContext = require('../contexts/diff').DiffContext;
var PatchContext = require('../contexts/patch').PatchContext;
var ReverseContext = require('../contexts/reverse').ReverseContext;

var collectChildrenDiffFilter = function collectChildrenDiffFilter(context) {
  if (!context || !context.children) {
    return;
  }
  var length = context.children.length;
  var child;
  var result = context.result;
  for (var index = 0; index < length; index++) {
    child = context.children[index];
    if (typeof child.result === 'undefined') {
      continue;
    }
    result = result || {};
    result[child.childName] = child.result;
  }
  if (result && context.leftIsArray) {
    result._t = 'a';
  }
  context.setResult(result).exit();
};
collectChildrenDiffFilter.filterName = 'collectChildren';

var objectsDiffFilter = function objectsDiffFilter(context) {
  if (context.leftIsArray || context.leftType !== 'object') {
    return;
  }

  var name, child, propertyFilter = context.options.propertyFilter;
  for (name in context.left) {
    if (!Object.prototype.hasOwnProperty.call(context.left, name)) {
      continue;
    }
    if (propertyFilter && !propertyFilter(name, context)) {
      continue;
    }
    child = new DiffContext(context.left[name], context.right[name]);
    context.push(child, name);
  }
  for (name in context.right) {
    if (!Object.prototype.hasOwnProperty.call(context.right, name)) {
      continue;
    }
    if (propertyFilter && !propertyFilter(name, context)) {
      continue;
    }
    if (typeof context.left[name] === 'undefined') {
      child = new DiffContext(undefined, context.right[name]);
      context.push(child, name);
    }
  }

  if (!context.children || context.children.length === 0) {
    context.setResult(undefined).exit();
    return;
  }
  context.exit();
};
objectsDiffFilter.filterName = 'objects';

var patchFilter = function nestedPatchFilter(context) {
  if (!context.nested) {
    return;
  }
  if (context.delta._t) {
    return;
  }
  var name, child;
  for (name in context.delta) {
    child = new PatchContext(context.left[name], context.delta[name]);
    context.push(child, name);
  }
  context.exit();
};
patchFilter.filterName = 'objects';

var collectChildrenPatchFilter = function collectChildrenPatchFilter(context) {
  if (!context || !context.children) {
    return;
  }
  if (context.delta._t) {
    return;
  }
  var length = context.children.length;
  var child;
  for (var index = 0; index < length; index++) {
    child = context.children[index];
    if (Object.prototype.hasOwnProperty.call(context.left, child.childName) && child.result === undefined) {
      delete context.left[child.childName];
    } else if (context.left[child.childName] !== child.result) {
      context.left[child.childName] = child.result;
    }
  }
  context.setResult(context.left).exit();
};
collectChildrenPatchFilter.filterName = 'collectChildren';

var reverseFilter = function nestedReverseFilter(context) {
  if (!context.nested) {
    return;
  }
  if (context.delta._t) {
    return;
  }
  var name, child;
  for (name in context.delta) {
    child = new ReverseContext(context.delta[name]);
    context.push(child, name);
  }
  context.exit();
};
reverseFilter.filterName = 'objects';

var collectChildrenReverseFilter = function collectChildrenReverseFilter(context) {
  if (!context || !context.children) {
    return;
  }
  if (context.delta._t) {
    return;
  }
  var length = context.children.length;
  var child;
  var delta = {};
  for (var index = 0; index < length; index++) {
    child = context.children[index];
    if (delta[child.childName] !== child.result) {
      delta[child.childName] = child.result;
    }
  }
  context.setResult(delta).exit();
};
collectChildrenReverseFilter.filterName = 'collectChildren';

exports.collectChildrenDiffFilter = collectChildrenDiffFilter;
exports.objectsDiffFilter = objectsDiffFilter;
exports.patchFilter = patchFilter;
exports.collectChildrenPatchFilter = collectChildrenPatchFilter;
exports.reverseFilter = reverseFilter;
exports.collectChildrenReverseFilter = collectChildrenReverseFilter;

},{"../contexts/diff":"jVyF","../contexts/patch":"lHZV","../contexts/reverse":"hVO5"}],"hetX":[function(require,module,exports) {
/*

LCS implementation that supports arrays or strings

reference: http://en.wikipedia.org/wiki/Longest_common_subsequence_problem

*/

var defaultMatch = function(array1, array2, index1, index2) {
  return array1[index1] === array2[index2];
};

var lengthMatrix = function(array1, array2, match, context) {
  var len1 = array1.length;
  var len2 = array2.length;
  var x, y;

  // initialize empty matrix of len1+1 x len2+1
  var matrix = [len1 + 1];
  for (x = 0; x < len1 + 1; x++) {
    matrix[x] = [len2 + 1];
    for (y = 0; y < len2 + 1; y++) {
      matrix[x][y] = 0;
    }
  }
  matrix.match = match;
  // save sequence lengths for each coordinate
  for (x = 1; x < len1 + 1; x++) {
    for (y = 1; y < len2 + 1; y++) {
      if (match(array1, array2, x - 1, y - 1, context)) {
        matrix[x][y] = matrix[x - 1][y - 1] + 1;
      } else {
        matrix[x][y] = Math.max(matrix[x - 1][y], matrix[x][y - 1]);
      }
    }
  }
  return matrix;
};

var backtrack = function(matrix, array1, array2, index1, index2, context) {
  if (index1 === 0 || index2 === 0) {
    return {
      sequence: [],
      indices1: [],
      indices2: []
    };
  }

  if (matrix.match(array1, array2, index1 - 1, index2 - 1, context)) {
    var subsequence = backtrack(matrix, array1, array2, index1 - 1, index2 - 1, context);
    subsequence.sequence.push(array1[index1 - 1]);
    subsequence.indices1.push(index1 - 1);
    subsequence.indices2.push(index2 - 1);
    return subsequence;
  }

  if (matrix[index1][index2 - 1] > matrix[index1 - 1][index2]) {
    return backtrack(matrix, array1, array2, index1, index2 - 1, context);
  } else {
    return backtrack(matrix, array1, array2, index1 - 1, index2, context);
  }
};

var get = function(array1, array2, match, context) {
  context = context || {};
  var matrix = lengthMatrix(array1, array2, match || defaultMatch, context);
  var result = backtrack(matrix, array1, array2, array1.length, array2.length, context);
  if (typeof array1 === 'string' && typeof array2 === 'string') {
    result.sequence = result.sequence.join('');
  }
  return result;
};

exports.get = get;

},{}],"AM6u":[function(require,module,exports) {
var DiffContext = require('../contexts/diff').DiffContext;
var PatchContext = require('../contexts/patch').PatchContext;
var ReverseContext = require('../contexts/reverse').ReverseContext;

var lcs = require('./lcs');

var ARRAY_MOVE = 3;

var isArray = (typeof Array.isArray === 'function') ?
  // use native function
  Array.isArray :
  // use instanceof operator
  function(a) {
    return a instanceof Array;
  };

var arrayIndexOf = typeof Array.prototype.indexOf === 'function' ?
  function(array, item) {
    return array.indexOf(item);
  } : function(array, item) {
    var length = array.length;
    for (var i = 0; i < length; i++) {
      if (array[i] === item) {
        return i;
      }
    }
    return -1;
  };

function arraysHaveMatchByRef(array1, array2, len1, len2) {
  for (var index1 = 0; index1 < len1; index1++) {
    var val1 = array1[index1];
    for (var index2 = 0; index2 < len2; index2++) {
      var val2 = array2[index2];
      if (index1 !== index2 && val1 === val2) {
        return true;
      }
    }
  }
}

function matchItems(array1, array2, index1, index2, context) {
  var value1 = array1[index1];
  var value2 = array2[index2];
  if (value1 === value2) {
    return true;
  }
  if (typeof value1 !== 'object' || typeof value2 !== 'object') {
    return false;
  }
  var objectHash = context.objectHash;
  if (!objectHash) {
    // no way to match objects was provided, try match by position
    return context.matchByPosition && index1 === index2;
  }
  var hash1;
  var hash2;
  if (typeof index1 === 'number') {
    context.hashCache1 = context.hashCache1 || [];
    hash1 = context.hashCache1[index1];
    if (typeof hash1 === 'undefined') {
      context.hashCache1[index1] = hash1 = objectHash(value1, index1);
    }
  } else {
    hash1 = objectHash(value1);
  }
  if (typeof hash1 === 'undefined') {
    return false;
  }
  if (typeof index2 === 'number') {
    context.hashCache2 = context.hashCache2 || [];
    hash2 = context.hashCache2[index2];
    if (typeof hash2 === 'undefined') {
      context.hashCache2[index2] = hash2 = objectHash(value2, index2);
    }
  } else {
    hash2 = objectHash(value2);
  }
  if (typeof hash2 === 'undefined') {
    return false;
  }
  return hash1 === hash2;
}

var diffFilter = function arraysDiffFilter(context) {
  if (!context.leftIsArray) {
    return;
  }

  var matchContext = {
    objectHash: context.options && context.options.objectHash,
    matchByPosition: context.options && context.options.matchByPosition
  };
  var commonHead = 0;
  var commonTail = 0;
  var index;
  var index1;
  var index2;
  var array1 = context.left;
  var array2 = context.right;
  var len1 = array1.length;
  var len2 = array2.length;

  var child;

  if (len1 > 0 && len2 > 0 && !matchContext.objectHash &&
    typeof matchContext.matchByPosition !== 'boolean') {
    matchContext.matchByPosition = !arraysHaveMatchByRef(array1, array2, len1, len2);
  }

  // separate common head
  while (commonHead < len1 && commonHead < len2 &&
    matchItems(array1, array2, commonHead, commonHead, matchContext)) {
    index = commonHead;
    child = new DiffContext(context.left[index], context.right[index]);
    context.push(child, index);
    commonHead++;
  }
  // separate common tail
  while (commonTail + commonHead < len1 && commonTail + commonHead < len2 &&
    matchItems(array1, array2, len1 - 1 - commonTail, len2 - 1 - commonTail, matchContext)) {
    index1 = len1 - 1 - commonTail;
    index2 = len2 - 1 - commonTail;
    child = new DiffContext(context.left[index1], context.right[index2]);
    context.push(child, index2);
    commonTail++;
  }
  var result;
  if (commonHead + commonTail === len1) {
    if (len1 === len2) {
      // arrays are identical
      context.setResult(undefined).exit();
      return;
    }
    // trivial case, a block (1 or more consecutive items) was added
    result = result || {
      _t: 'a'
    };
    for (index = commonHead; index < len2 - commonTail; index++) {
      result[index] = [array2[index]];
    }
    context.setResult(result).exit();
    return;
  }
  if (commonHead + commonTail === len2) {
    // trivial case, a block (1 or more consecutive items) was removed
    result = result || {
      _t: 'a'
    };
    for (index = commonHead; index < len1 - commonTail; index++) {
      result['_' + index] = [array1[index], 0, 0];
    }
    context.setResult(result).exit();
    return;
  }
  // reset hash cache
  delete matchContext.hashCache1;
  delete matchContext.hashCache2;

  // diff is not trivial, find the LCS (Longest Common Subsequence)
  var trimmed1 = array1.slice(commonHead, len1 - commonTail);
  var trimmed2 = array2.slice(commonHead, len2 - commonTail);
  var seq = lcs.get(
    trimmed1, trimmed2,
    matchItems,
    matchContext
  );
  var removedItems = [];
  result = result || {
    _t: 'a'
  };
  for (index = commonHead; index < len1 - commonTail; index++) {
    if (arrayIndexOf(seq.indices1, index - commonHead) < 0) {
      // removed
      result['_' + index] = [array1[index], 0, 0];
      removedItems.push(index);
    }
  }

  var detectMove = true;
  if (context.options && context.options.arrays && context.options.arrays.detectMove === false) {
    detectMove = false;
  }
  var includeValueOnMove = false;
  if (context.options && context.options.arrays && context.options.arrays.includeValueOnMove) {
    includeValueOnMove = true;
  }

  var removedItemsLength = removedItems.length;
  for (index = commonHead; index < len2 - commonTail; index++) {
    var indexOnArray2 = arrayIndexOf(seq.indices2, index - commonHead);
    if (indexOnArray2 < 0) {
      // added, try to match with a removed item and register as position move
      var isMove = false;
      if (detectMove && removedItemsLength > 0) {
        for (var removeItemIndex1 = 0; removeItemIndex1 < removedItemsLength; removeItemIndex1++) {
          index1 = removedItems[removeItemIndex1];
          if (matchItems(trimmed1, trimmed2, index1 - commonHead,
            index - commonHead, matchContext)) {
            // store position move as: [originalValue, newPosition, ARRAY_MOVE]
            result['_' + index1].splice(1, 2, index, ARRAY_MOVE);
            if (!includeValueOnMove) {
              // don't include moved value on diff, to save bytes
              result['_' + index1][0] = '';
            }

            index2 = index;
            child = new DiffContext(context.left[index1], context.right[index2]);
            context.push(child, index2);
            removedItems.splice(removeItemIndex1, 1);
            isMove = true;
            break;
          }
        }
      }
      if (!isMove) {
        // added
        result[index] = [array2[index]];
      }
    } else {
      // match, do inner diff
      index1 = seq.indices1[indexOnArray2] + commonHead;
      index2 = seq.indices2[indexOnArray2] + commonHead;
      child = new DiffContext(context.left[index1], context.right[index2]);
      context.push(child, index2);
    }
  }

  context.setResult(result).exit();

};
diffFilter.filterName = 'arrays';

var compare = {
  numerically: function(a, b) {
    return a - b;
  },
  numericallyBy: function(name) {
    return function(a, b) {
      return a[name] - b[name];
    };
  }
};

var patchFilter = function nestedPatchFilter(context) {
  if (!context.nested) {
    return;
  }
  if (context.delta._t !== 'a') {
    return;
  }
  var index, index1;

  var delta = context.delta;
  var array = context.left;

  // first, separate removals, insertions and modifications
  var toRemove = [];
  var toInsert = [];
  var toModify = [];
  for (index in delta) {
    if (index !== '_t') {
      if (index[0] === '_') {
        // removed item from original array
        if (delta[index][2] === 0 || delta[index][2] === ARRAY_MOVE) {
          toRemove.push(parseInt(index.slice(1), 10));
        } else {
          throw new Error('only removal or move can be applied at original array indices' +
            ', invalid diff type: ' + delta[index][2]);
        }
      } else {
        if (delta[index].length === 1) {
          // added item at new array
          toInsert.push({
            index: parseInt(index, 10),
            value: delta[index][0]
          });
        } else {
          // modified item at new array
          toModify.push({
            index: parseInt(index, 10),
            delta: delta[index]
          });
        }
      }
    }
  }

  // remove items, in reverse order to avoid sawing our own floor
  toRemove = toRemove.sort(compare.numerically);
  for (index = toRemove.length - 1; index >= 0; index--) {
    index1 = toRemove[index];
    var indexDiff = delta['_' + index1];
    var removedValue = array.splice(index1, 1)[0];
    if (indexDiff[2] === ARRAY_MOVE) {
      // reinsert later
      toInsert.push({
        index: indexDiff[1],
        value: removedValue
      });
    }
  }

  // insert items, in reverse order to avoid moving our own floor
  toInsert = toInsert.sort(compare.numericallyBy('index'));
  var toInsertLength = toInsert.length;
  for (index = 0; index < toInsertLength; index++) {
    var insertion = toInsert[index];
    array.splice(insertion.index, 0, insertion.value);
  }

  // apply modifications
  var toModifyLength = toModify.length;
  var child;
  if (toModifyLength > 0) {
    for (index = 0; index < toModifyLength; index++) {
      var modification = toModify[index];
      child = new PatchContext(context.left[modification.index], modification.delta);
      context.push(child, modification.index);
    }
  }

  if (!context.children) {
    context.setResult(context.left).exit();
    return;
  }
  context.exit();
};
patchFilter.filterName = 'arrays';

var collectChildrenPatchFilter = function collectChildrenPatchFilter(context) {
  if (!context || !context.children) {
    return;
  }
  if (context.delta._t !== 'a') {
    return;
  }
  var length = context.children.length;
  var child;
  for (var index = 0; index < length; index++) {
    child = context.children[index];
    context.left[child.childName] = child.result;
  }
  context.setResult(context.left).exit();
};
collectChildrenPatchFilter.filterName = 'arraysCollectChildren';

var reverseFilter = function arraysReverseFilter(context) {
  if (!context.nested) {
    if (context.delta[2] === ARRAY_MOVE) {
      context.newName = '_' + context.delta[1];
      context.setResult([context.delta[0], parseInt(context.childName.substr(1), 10), ARRAY_MOVE]).exit();
    }
    return;
  }
  if (context.delta._t !== 'a') {
    return;
  }
  var name, child;
  for (name in context.delta) {
    if (name === '_t') {
      continue;
    }
    child = new ReverseContext(context.delta[name]);
    context.push(child, name);
  }
  context.exit();
};
reverseFilter.filterName = 'arrays';

var reverseArrayDeltaIndex = function(delta, index, itemDelta) {
  if (typeof index === 'string' && index[0] === '_') {
    return parseInt(index.substr(1), 10);
  } else if (isArray(itemDelta) && itemDelta[2] === 0) {
    return '_' + index;
  }

  var reverseIndex = +index;
  for (var deltaIndex in delta) {
    var deltaItem = delta[deltaIndex];
    if (isArray(deltaItem)) {
      if (deltaItem[2] === ARRAY_MOVE) {
        var moveFromIndex = parseInt(deltaIndex.substr(1), 10);
        var moveToIndex = deltaItem[1];
        if (moveToIndex === +index) {
          return moveFromIndex;
        }
        if (moveFromIndex <= reverseIndex && moveToIndex > reverseIndex) {
          reverseIndex++;
        } else if (moveFromIndex >= reverseIndex && moveToIndex < reverseIndex) {
          reverseIndex--;
        }
      } else if (deltaItem[2] === 0) {
        var deleteIndex = parseInt(deltaIndex.substr(1), 10);
        if (deleteIndex <= reverseIndex) {
          reverseIndex++;
        }
      } else if (deltaItem.length === 1 && deltaIndex <= reverseIndex) {
        reverseIndex--;
      }
    }
  }

  return reverseIndex;
};

var collectChildrenReverseFilter = function collectChildrenReverseFilter(context) {
  if (!context || !context.children) {
    return;
  }
  if (context.delta._t !== 'a') {
    return;
  }
  var length = context.children.length;
  var child;
  var delta = {
    _t: 'a'
  };

  for (var index = 0; index < length; index++) {
    child = context.children[index];
    var name = child.newName;
    if (typeof name === 'undefined') {
      name = reverseArrayDeltaIndex(context.delta, child.childName, child.result);
    }
    if (delta[name] !== child.result) {
      delta[name] = child.result;
    }
  }
  context.setResult(delta).exit();
};
collectChildrenReverseFilter.filterName = 'arraysCollectChildren';

exports.diffFilter = diffFilter;
exports.patchFilter = patchFilter;
exports.collectChildrenPatchFilter = collectChildrenPatchFilter;
exports.reverseFilter = reverseFilter;
exports.collectChildrenReverseFilter = collectChildrenReverseFilter;

},{"../contexts/diff":"jVyF","../contexts/patch":"lHZV","../contexts/reverse":"hVO5","./lcs":"hetX"}],"ilG6":[function(require,module,exports) {
var diffFilter = function datesDiffFilter(context) {
  if (context.left instanceof Date) {
    if (context.right instanceof Date) {
      if (context.left.getTime() !== context.right.getTime()) {
        context.setResult([context.left, context.right]);
      } else {
        context.setResult(undefined);
      }
    } else {
      context.setResult([context.left, context.right]);
    }
    context.exit();
  } else if (context.right instanceof Date) {
    context.setResult([context.left, context.right]).exit();
  }
};
diffFilter.filterName = 'dates';

exports.diffFilter = diffFilter;

},{}],"l4dQ":[function(require,module,exports) {
/* global diff_match_patch */
var TEXT_DIFF = 2;
var DEFAULT_MIN_LENGTH = 60;
var cachedDiffPatch = null;

var getDiffMatchPatch = function(required) {
  /*jshint camelcase: false */

  if (!cachedDiffPatch) {
    var instance;
    if (typeof diff_match_patch !== 'undefined') {
      // already loaded, probably a browser
      instance = typeof diff_match_patch === 'function' ?
        new diff_match_patch() : new diff_match_patch.diff_match_patch();
    } else if (typeof require === 'function') {
      try {
        var dmpModuleName = 'diff_match_patch_uncompressed';
        var dmp = require('../../public/external/' + dmpModuleName);
        instance = new dmp.diff_match_patch();
      } catch (err) {
        instance = null;
      }
    }
    if (!instance) {
      if (!required) {
        return null;
      }
      var error = new Error('text diff_match_patch library not found');
      error.diff_match_patch_not_found = true;
      throw error;
    }
    cachedDiffPatch = {
      diff: function(txt1, txt2) {
        return instance.patch_toText(instance.patch_make(txt1, txt2));
      },
      patch: function(txt1, patch) {
        var results = instance.patch_apply(instance.patch_fromText(patch), txt1);
        for (var i = 0; i < results[1].length; i++) {
          if (!results[1][i]) {
            var error = new Error('text patch failed');
            error.textPatchFailed = true;
          }
        }
        return results[0];
      }
    };
  }
  return cachedDiffPatch;
};

var diffFilter = function textsDiffFilter(context) {
  if (context.leftType !== 'string') {
    return;
  }
  var minLength = (context.options && context.options.textDiff &&
    context.options.textDiff.minLength) || DEFAULT_MIN_LENGTH;
  if (context.left.length < minLength ||
    context.right.length < minLength) {
    context.setResult([context.left, context.right]).exit();
    return;
  }
  // large text, try to use a text-diff algorithm
  var diffMatchPatch = getDiffMatchPatch();
  if (!diffMatchPatch) {
    // diff-match-patch library not available, fallback to regular string replace
    context.setResult([context.left, context.right]).exit();
    return;
  }
  var diff = diffMatchPatch.diff;
  context.setResult([diff(context.left, context.right), 0, TEXT_DIFF]).exit();
};
diffFilter.filterName = 'texts';

var patchFilter = function textsPatchFilter(context) {
  if (context.nested) {
    return;
  }
  if (context.delta[2] !== TEXT_DIFF) {
    return;
  }

  // text-diff, use a text-patch algorithm
  var patch = getDiffMatchPatch(true).patch;
  context.setResult(patch(context.left, context.delta[0])).exit();
};
patchFilter.filterName = 'texts';

var textDeltaReverse = function(delta) {
  var i, l, lines, line, lineTmp, header = null,
    headerRegex = /^@@ +\-(\d+),(\d+) +\+(\d+),(\d+) +@@$/,
    lineHeader, lineAdd, lineRemove;
  lines = delta.split('\n');
  for (i = 0, l = lines.length; i < l; i++) {
    line = lines[i];
    var lineStart = line.slice(0, 1);
    if (lineStart === '@') {
      header = headerRegex.exec(line);
      lineHeader = i;
      lineAdd = null;
      lineRemove = null;

      // fix header
      lines[lineHeader] = '@@ -' + header[3] + ',' + header[4] + ' +' + header[1] + ',' + header[2] + ' @@';
    } else if (lineStart === '+') {
      lineAdd = i;
      lines[i] = '-' + lines[i].slice(1);
      if (lines[i - 1].slice(0, 1) === '+') {
        // swap lines to keep default order (-+)
        lineTmp = lines[i];
        lines[i] = lines[i - 1];
        lines[i - 1] = lineTmp;
      }
    } else if (lineStart === '-') {
      lineRemove = i;
      lines[i] = '+' + lines[i].slice(1);
    }
  }
  return lines.join('\n');
};

var reverseFilter = function textsReverseFilter(context) {
  if (context.nested) {
    return;
  }
  if (context.delta[2] !== TEXT_DIFF) {
    return;
  }

  // text-diff, use a text-diff algorithm
  context.setResult([textDeltaReverse(context.delta[0]), 0, TEXT_DIFF]).exit();
};
reverseFilter.filterName = 'texts';

exports.diffFilter = diffFilter;
exports.patchFilter = patchFilter;
exports.reverseFilter = reverseFilter;

},{}],"ahiO":[function(require,module,exports) {
var Processor = require('./processor').Processor;
var Pipe = require('./pipe').Pipe;
var DiffContext = require('./contexts/diff').DiffContext;
var PatchContext = require('./contexts/patch').PatchContext;
var ReverseContext = require('./contexts/reverse').ReverseContext;

var clone = require('./clone');

var trivial = require('./filters/trivial');
var nested = require('./filters/nested');
var arrays = require('./filters/arrays');
var dates = require('./filters/dates');
var texts = require('./filters/texts');

var DiffPatcher = function DiffPatcher(options) {
  this.processor = new Processor(options);
  this.processor.pipe(new Pipe('diff').append(
    nested.collectChildrenDiffFilter,
    trivial.diffFilter,
    dates.diffFilter,
    texts.diffFilter,
    nested.objectsDiffFilter,
    arrays.diffFilter
  ).shouldHaveResult());
  this.processor.pipe(new Pipe('patch').append(
    nested.collectChildrenPatchFilter,
    arrays.collectChildrenPatchFilter,
    trivial.patchFilter,
    texts.patchFilter,
    nested.patchFilter,
    arrays.patchFilter
  ).shouldHaveResult());
  this.processor.pipe(new Pipe('reverse').append(
    nested.collectChildrenReverseFilter,
    arrays.collectChildrenReverseFilter,
    trivial.reverseFilter,
    texts.reverseFilter,
    nested.reverseFilter,
    arrays.reverseFilter
  ).shouldHaveResult());
};

DiffPatcher.prototype.options = function() {
  return this.processor.options.apply(this.processor, arguments);
};

DiffPatcher.prototype.diff = function(left, right) {
  return this.processor.process(new DiffContext(left, right));
};

DiffPatcher.prototype.patch = function(left, delta) {
  return this.processor.process(new PatchContext(left, delta));
};

DiffPatcher.prototype.reverse = function(delta) {
  return this.processor.process(new ReverseContext(delta));
};

DiffPatcher.prototype.unpatch = function(right, delta) {
  return this.patch(right, this.reverse(delta));
};

DiffPatcher.prototype.clone = function(value) {
  return clone(value);
};

exports.DiffPatcher = DiffPatcher;

},{"./processor":"u9RV","./pipe":"S41N","./contexts/diff":"jVyF","./contexts/patch":"lHZV","./contexts/reverse":"hVO5","./clone":"ntOD","./filters/trivial":"kYF4","./filters/nested":"EpOW","./filters/arrays":"AM6u","./filters/dates":"ilG6","./filters/texts":"l4dQ"}],"Zfoj":[function(require,module,exports) {
// use as 2nd parameter for JSON.parse to revive Date instances
module.exports = function dateReviver(key, value) {
  var parts;
  if (typeof value === 'string') {
    parts = /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})(?:\.(\d*))?(Z|([+\-])(\d{2}):(\d{2}))$/.exec(value);
    if (parts) {
      return new Date(Date.UTC(+parts[1], +parts[2] - 1, +parts[3], +parts[4], +parts[5], +parts[6], +(parts[7] || 0)));
    }
  }
  return value;
};

},{}],"idyJ":[function(require,module,exports) {

var environment = require('./environment');

var DiffPatcher = require('./diffpatcher').DiffPatcher;
exports.DiffPatcher = DiffPatcher;

exports.create = function(options){
  return new DiffPatcher(options);
};

exports.dateReviver = require('./date-reviver');

var defaultInstance;

exports.diff = function() {
  if (!defaultInstance) {
    defaultInstance = new DiffPatcher();
  }
  return defaultInstance.diff.apply(defaultInstance, arguments);
};

exports.patch = function() {
  if (!defaultInstance) {
    defaultInstance = new DiffPatcher();
  }
  return defaultInstance.patch.apply(defaultInstance, arguments);
};

exports.unpatch = function() {
  if (!defaultInstance) {
    defaultInstance = new DiffPatcher();
  }
  return defaultInstance.unpatch.apply(defaultInstance, arguments);
};

exports.reverse = function() {
  if (!defaultInstance) {
    defaultInstance = new DiffPatcher();
  }
  return defaultInstance.reverse.apply(defaultInstance, arguments);
};

exports.clone = function() {
  if (!defaultInstance) {
    defaultInstance = new DiffPatcher();
  }
  return defaultInstance.clone.apply(defaultInstance, arguments);
};


if (environment.isBrowser) {
  exports.homepage = '{{package-homepage}}';
  exports.version = '{{package-version}}';
} else {
  var packageInfoModuleName = '../package.json';
  var packageInfo = require(packageInfoModuleName);
  exports.homepage = packageInfo.homepage;
  exports.version = packageInfo.version;

  var formatterModuleName = './formatters';
  var formatters = require(formatterModuleName);
  exports.formatters = formatters;
  // shortcut for console
  exports.console = formatters.console;
}

},{"./environment":"HyZG","./diffpatcher":"ahiO","./date-reviver":"Zfoj"}],"HaUq":[function(require,module,exports) {
var isArray = (typeof Array.isArray === 'function') ?
  // use native function
  Array.isArray :
  // use instanceof operator
  function(a) {
    return a instanceof Array;
  };

var getObjectKeys = typeof Object.keys === 'function' ?
  function(obj) {
    return Object.keys(obj);
  } : function(obj) {
    var names = [];
    for (var property in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, property)) {
        names.push(property);
      }
    }
    return names;
  };

var trimUnderscore = function(str) {
  if (str.substr(0, 1) === '_') {
    return str.slice(1);
  }
  return str;
};

var arrayKeyToSortNumber = function(key) {
  if (key === '_t') {
    return -1;
  } else {
    if (key.substr(0, 1) === '_') {
      return parseInt(key.slice(1), 10);
    } else {
      return parseInt(key, 10) + 0.1;
    }
  }
};

var arrayKeyComparer = function(key1, key2) {
  return arrayKeyToSortNumber(key1) - arrayKeyToSortNumber(key2);
};

var BaseFormatter = function BaseFormatter() {};

BaseFormatter.prototype.format = function(delta, left) {
  var context = {};
  this.prepareContext(context);
  this.recurse(context, delta, left);
  return this.finalize(context);
};

BaseFormatter.prototype.prepareContext = function(context) {
  context.buffer = [];
  context.out = function() {
    this.buffer.push.apply(this.buffer, arguments);
  };
};

BaseFormatter.prototype.typeFormattterNotFound = function(context, deltaType) {
  throw new Error('cannot format delta type: ' + deltaType);
};

BaseFormatter.prototype.typeFormattterErrorFormatter = function(context, err) {
  return err.toString();
};

BaseFormatter.prototype.finalize = function(context) {
  if (isArray(context.buffer)) {
    return context.buffer.join('');
  }
};

BaseFormatter.prototype.recurse = function(context, delta, left, key, leftKey, movedFrom, isLast) {

  var useMoveOriginHere = delta && movedFrom;
  var leftValue = useMoveOriginHere ? movedFrom.value : left;

  if (typeof delta === 'undefined' && typeof key === 'undefined') {
    return undefined;
  }

  var type = this.getDeltaType(delta, movedFrom);
  var nodeType = type === 'node' ? (delta._t === 'a' ? 'array' : 'object') : '';

  if (typeof key !== 'undefined') {
    this.nodeBegin(context, key, leftKey, type, nodeType, isLast);
  } else {
    this.rootBegin(context, type, nodeType);
  }

  var typeFormattter;
  try {
    typeFormattter = this['format_' + type] || this.typeFormattterNotFound(context, type);
    typeFormattter.call(this, context, delta, leftValue, key, leftKey, movedFrom);
  } catch (err) {
    this.typeFormattterErrorFormatter(context, err, delta, leftValue, key, leftKey, movedFrom);
    if (typeof console !== 'undefined' && console.error) {
      console.error(err.stack);
    }
  }

  if (typeof key !== 'undefined') {
    this.nodeEnd(context, key, leftKey, type, nodeType, isLast);
  } else {
    this.rootEnd(context, type, nodeType);
  }
};

BaseFormatter.prototype.formatDeltaChildren = function(context, delta, left) {
  var self = this;
  this.forEachDeltaKey(delta, left, function(key, leftKey, movedFrom, isLast) {
    self.recurse(context, delta[key], left ? left[leftKey] : undefined,
      key, leftKey, movedFrom, isLast);
  });
};

BaseFormatter.prototype.forEachDeltaKey = function(delta, left, fn) {
  var keys = getObjectKeys(delta);
  var arrayKeys = delta._t === 'a';
  var moveDestinations = {};
  var name;
  if (typeof left !== 'undefined') {
    for (name in left) {
      if (Object.prototype.hasOwnProperty.call(left, name)) {
        if (typeof delta[name] === 'undefined' &&
          ((!arrayKeys) || typeof delta['_' + name] === 'undefined')) {
          keys.push(name);
        }
      }
    }
  }
  // look for move destinations
  for (name in delta) {
    if (Object.prototype.hasOwnProperty.call(delta, name)) {
      var value = delta[name];
      if (isArray(value) && value[2] === 3) {
        moveDestinations[value[1].toString()] = {
          key: name,
          value: left && left[parseInt(name.substr(1))]
        };
        if (this.includeMoveDestinations !== false) {
          if ((typeof left === 'undefined') &&
            (typeof delta[value[1]] === 'undefined')) {
            keys.push(value[1].toString());
          }
        }
      }
    }
  }
  if (arrayKeys) {
    keys.sort(arrayKeyComparer);
  } else {
    keys.sort();
  }
  for (var index = 0, length = keys.length; index < length; index++) {
    var key = keys[index];
    if (arrayKeys && key === '_t') {
      continue;
    }
    var leftKey = arrayKeys ?
      (typeof key === 'number' ? key : parseInt(trimUnderscore(key), 10)) :
      key;
    var isLast = (index === length - 1);
    fn(key, leftKey, moveDestinations[leftKey], isLast);
  }
};

BaseFormatter.prototype.getDeltaType = function(delta, movedFrom) {
  if (typeof delta === 'undefined') {
    if (typeof movedFrom !== 'undefined') {
      return 'movedestination';
    }
    return 'unchanged';
  }
  if (isArray(delta)) {
    if (delta.length === 1) {
      return 'added';
    }
    if (delta.length === 2) {
      return 'modified';
    }
    if (delta.length === 3 && delta[2] === 0) {
      return 'deleted';
    }
    if (delta.length === 3 && delta[2] === 2) {
      return 'textdiff';
    }
    if (delta.length === 3 && delta[2] === 3) {
      return 'moved';
    }
  } else if (typeof delta === 'object') {
    return 'node';
  }
  return 'unknown';
};

BaseFormatter.prototype.parseTextDiff = function(value) {
  var output = [];
  var lines = value.split('\n@@ ');
  for (var i = 0, l = lines.length; i < l; i++) {
    var line = lines[i];
    var lineOutput = {
      pieces: []
    };
    var location = /^(?:@@ )?[-+]?(\d+),(\d+)/.exec(line).slice(1);
    lineOutput.location = {
      line: location[0],
      chr: location[1]
    };
    var pieces = line.split('\n').slice(1);
    for (var pieceIndex = 0, piecesLength = pieces.length; pieceIndex < piecesLength; pieceIndex++) {
      var piece = pieces[pieceIndex];
      if (!piece.length) {
        continue;
      }
      var pieceOutput = {
        type: 'context'
      };
      if (piece.substr(0, 1) === '+') {
        pieceOutput.type = 'added';
      } else if (piece.substr(0, 1) === '-') {
        pieceOutput.type = 'deleted';
      }
      pieceOutput.text = piece.slice(1);
      lineOutput.pieces.push(pieceOutput);
    }
    output.push(lineOutput);
  }
  return output;
};

exports.BaseFormatter = BaseFormatter;

},{}],"uxiT":[function(require,module,exports) {
var base = require('./base');
var BaseFormatter = base.BaseFormatter;

var HtmlFormatter = function HtmlFormatter() {};

HtmlFormatter.prototype = new BaseFormatter();

function htmlEscape(text) {
  var html = text;
  var replacements = [
    [/&/g, '&amp;'],
    [/</g, '&lt;'],
    [/>/g, '&gt;'],
    [/'/g, '&apos;'],
    [/"/g, '&quot;']
  ];
  for (var i = 0; i < replacements.length; i++) {
    html = html.replace(replacements[i][0], replacements[i][1]);
  }
  return html;
}

HtmlFormatter.prototype.typeFormattterErrorFormatter = function(context, err) {
  context.out('<pre class="jsondiffpatch-error">' + err + '</pre>');
};

HtmlFormatter.prototype.formatValue = function(context, value) {
  context.out('<pre>' + htmlEscape(JSON.stringify(value, null, 2)) + '</pre>');
};

HtmlFormatter.prototype.formatTextDiffString = function(context, value) {
  var lines = this.parseTextDiff(value);
  context.out('<ul class="jsondiffpatch-textdiff">');
  for (var i = 0, l = lines.length; i < l; i++) {
    var line = lines[i];
    context.out('<li>' +
      '<div class="jsondiffpatch-textdiff-location">' +
      '<span class="jsondiffpatch-textdiff-line-number">' +
      line.location.line +
      '</span>' +
      '<span class="jsondiffpatch-textdiff-char">' +
      line.location.chr +
      '</span>' +
      '</div>' +
      '<div class="jsondiffpatch-textdiff-line">');
    var pieces = line.pieces;
    for (var pieceIndex = 0, piecesLength = pieces.length; pieceIndex < piecesLength; pieceIndex++) {
      /* global unescape */
      var piece = pieces[pieceIndex];
      context.out('<span class="jsondiffpatch-textdiff-' + piece.type + '">' +
        htmlEscape(unescape(piece.text)) + '</span>');
    }
    context.out('</div></li>');
  }
  context.out('</ul>');
};

var adjustArrows = function jsondiffpatchHtmlFormatterAdjustArrows(node) {
  node = node || document;
  var getElementText = function(el) {
    return el.textContent || el.innerText;
  };
  var eachByQuery = function(el, query, fn) {
    var elems = el.querySelectorAll(query);
    for (var i = 0, l = elems.length; i < l; i++) {
      fn(elems[i]);
    }
  };
  var eachChildren = function(el, fn) {
    for (var i = 0, l = el.children.length; i < l; i++) {
      fn(el.children[i], i);
    }
  };
  eachByQuery(node, '.jsondiffpatch-arrow', function(arrow) {
    var arrowParent = arrow.parentNode;
    var svg = arrow.children[0],
      path = svg.children[1];
    svg.style.display = 'none';
    var destination = getElementText(arrowParent.querySelector('.jsondiffpatch-moved-destination'));
    var container = arrowParent.parentNode;
    var destinationElem;
    eachChildren(container, function(child) {
      if (child.getAttribute('data-key') === destination) {
        destinationElem = child;
      }
    });
    if (!destinationElem) {
      return;
    }
    try {
      var distance = destinationElem.offsetTop - arrowParent.offsetTop;
      svg.setAttribute('height', Math.abs(distance) + 6);
      arrow.style.top = (-8 + (distance > 0 ? 0 : distance)) + 'px';
      var curve = distance > 0 ?
        'M30,0 Q-10,' + Math.round(distance / 2) + ' 26,' + (distance - 4) :
        'M30,' + (-distance) + ' Q-10,' + Math.round(-distance / 2) + ' 26,4';
      path.setAttribute('d', curve);
      svg.style.display = '';
    } catch (err) {
      return;
    }
  });
};

HtmlFormatter.prototype.rootBegin = function(context, type, nodeType) {
  var nodeClass = 'jsondiffpatch-' + type +
    (nodeType ? ' jsondiffpatch-child-node-type-' + nodeType : '');
  context.out('<div class="jsondiffpatch-delta ' + nodeClass + '">');
};

HtmlFormatter.prototype.rootEnd = function(context) {
  context.out('</div>' + (context.hasArrows ?
    ('<script type="text/javascript">setTimeout(' +
      adjustArrows.toString() +
      ',10);</script>') : ''));
};

HtmlFormatter.prototype.nodeBegin = function(context, key, leftKey, type, nodeType) {
  var nodeClass = 'jsondiffpatch-' + type +
    (nodeType ? ' jsondiffpatch-child-node-type-' + nodeType : '');
  context.out('<li class="' + nodeClass + '" data-key="' + leftKey + '">' +
    '<div class="jsondiffpatch-property-name">' + leftKey + '</div>');
};


HtmlFormatter.prototype.nodeEnd = function(context) {
  context.out('</li>');
};

/* jshint camelcase: false */

HtmlFormatter.prototype.format_unchanged = function(context, delta, left) {
  if (typeof left === 'undefined') {
    return;
  }
  context.out('<div class="jsondiffpatch-value">');
  this.formatValue(context, left);
  context.out('</div>');
};

HtmlFormatter.prototype.format_movedestination = function(context, delta, left) {
  if (typeof left === 'undefined') {
    return;
  }
  context.out('<div class="jsondiffpatch-value">');
  this.formatValue(context, left);
  context.out('</div>');
};

HtmlFormatter.prototype.format_node = function(context, delta, left) {
  // recurse
  var nodeType = (delta._t === 'a') ? 'array' : 'object';
  context.out('<ul class="jsondiffpatch-node jsondiffpatch-node-type-' + nodeType + '">');
  this.formatDeltaChildren(context, delta, left);
  context.out('</ul>');
};

HtmlFormatter.prototype.format_added = function(context, delta) {
  context.out('<div class="jsondiffpatch-value">');
  this.formatValue(context, delta[0]);
  context.out('</div>');
};

HtmlFormatter.prototype.format_modified = function(context, delta) {
  context.out('<div class="jsondiffpatch-value jsondiffpatch-left-value">');
  this.formatValue(context, delta[0]);
  context.out('</div>' +
    '<div class="jsondiffpatch-value jsondiffpatch-right-value">');
  this.formatValue(context, delta[1]);
  context.out('</div>');
};

HtmlFormatter.prototype.format_deleted = function(context, delta) {
  context.out('<div class="jsondiffpatch-value">');
  this.formatValue(context, delta[0]);
  context.out('</div>');
};

HtmlFormatter.prototype.format_moved = function(context, delta) {
  context.out('<div class="jsondiffpatch-value">');
  this.formatValue(context, delta[0]);
  context.out('</div><div class="jsondiffpatch-moved-destination">' + delta[1] + '</div>');

  // draw an SVG arrow from here to move destination
  context.out(
    /*jshint multistr: true */
    '<div class="jsondiffpatch-arrow" style="position: relative; left: -34px;">\
        <svg width="30" height="60" style="position: absolute; display: none;">\
        <defs>\
            <marker id="markerArrow" markerWidth="8" markerHeight="8" refx="2" refy="4"\
                   orient="auto" markerUnits="userSpaceOnUse">\
                <path d="M1,1 L1,7 L7,4 L1,1" style="fill: #339;" />\
            </marker>\
        </defs>\
        <path d="M30,0 Q-10,25 26,50" style="stroke: #88f; stroke-width: 2px; fill: none;\
        stroke-opacity: 0.5; marker-end: url(#markerArrow);"></path>\
        </svg>\
        </div>');
  context.hasArrows = true;
};

HtmlFormatter.prototype.format_textdiff = function(context, delta) {
  context.out('<div class="jsondiffpatch-value">');
  this.formatTextDiffString(context, delta[0]);
  context.out('</div>');
};

/* jshint camelcase: true */

var showUnchanged = function(show, node, delay) {
  var el = node || document.body;
  var prefix = 'jsondiffpatch-unchanged-';
  var classes = {
    showing: prefix + 'showing',
    hiding: prefix + 'hiding',
    visible: prefix + 'visible',
    hidden: prefix + 'hidden',
  };
  var list = el.classList;
  if (!list) {
    return;
  }
  if (!delay) {
    list.remove(classes.showing);
    list.remove(classes.hiding);
    list.remove(classes.visible);
    list.remove(classes.hidden);
    if (show === false) {
      list.add(classes.hidden);
    }
    return;
  }
  if (show === false) {
    list.remove(classes.showing);
    list.add(classes.visible);
    setTimeout(function() {
      list.add(classes.hiding);
    }, 10);
  } else {
    list.remove(classes.hiding);
    list.add(classes.showing);
    list.remove(classes.hidden);
  }
  var intervalId = setInterval(function() {
    adjustArrows(el);
  }, 100);
  setTimeout(function() {
    list.remove(classes.showing);
    list.remove(classes.hiding);
    if (show === false) {
      list.add(classes.hidden);
      list.remove(classes.visible);
    } else {
      list.add(classes.visible);
      list.remove(classes.hidden);
    }
    setTimeout(function() {
      list.remove(classes.visible);
      clearInterval(intervalId);
    }, delay + 400);
  }, delay);
};

var hideUnchanged = function(node, delay) {
  return showUnchanged(false, node, delay);
};

exports.HtmlFormatter = HtmlFormatter;

exports.showUnchanged = showUnchanged;

exports.hideUnchanged = hideUnchanged;

var defaultInstance;

exports.format = function(delta, left) {
  if (!defaultInstance) {
    defaultInstance = new HtmlFormatter();
  }
  return defaultInstance.format(delta, left);
};

},{"./base":"HaUq"}],"Lc6w":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.create = exports.stringify = void 0;

const common = __importStar(require("./common"));

const fs_1 = require("fs");

const jsondiffpatch = require('jsondiffpatch').create({});

const remove__prefixedProperties = (key, value) => key.startsWith("__") ? undefined : value;

const uniqueId = Symbol('uniqueId');
let nextId = 0;
const ignoreProperties = {
  location: true
};

function ignore(property, value) {
  if (value == null) {
    return true;
  }

  return ignoreProperties[property] || property.startsWith("_") || /^\/ion\b/.test(property);
}

function stringify(object, indent = 2) {
  return JSON.stringify(cloneWithJsonReferences(object), null, indent);
}

exports.stringify = stringify;

function cloneWithJsonReferences(object, path = []) {
  let type = typeof object;
  if (object == null || type == 'string' || type == 'number' || type == 'boolean') return object;
  let className = object.constructor.path || object.constructor.name;
  if (object.toJSON) object = object.toJSON();
  let clone = Array.isArray(object) ? [] : className === "Object" ? {} : {
    "": className
  };

  if (object instanceof Map) {
    for (let key of object.keys()) {
      let value = object.get(key);

      if (ignore(key, value)) {
        continue;
      }

      clone[key] = cloneWithJsonReferences(value, path);
    }
  }

  if (object instanceof Set) {
    let index = 0;

    for (let value of object.values()) {
      clone[index++] = cloneWithJsonReferences(value, path);
    }
  } else {
    for (let property in object) {
      let value = object[property];

      if (ignore(property, value)) {
        continue;
      }

      path.push(property);
      clone[property] = cloneWithJsonReferences(value, path);
      path.pop();
    }
  }

  return clone;
}

function format(html) {
  //  replace { "": "TypeName" ... } with TypeName { ... }
  return html.replace(/{\s+&quot;&quot;:\s+&quot;(\w+)&quot;,/gi, "$1 {") //  replace multiline object with a single value as a single line
  .replace(/{\s+([^\n]+)\s+}/gi, "{ $1 }") //  replace line ends with breaks
  .replace(/\\n/g, '<br>');
}

function create(outputPath) {
  let stylePath = require.resolve("jsondiffpatch/public/formatters-styles/html.css");

  let rfs = fs_1.readFileSync; // abstraction to prevent parcel from resolving

  let style = rfs(stylePath); // console.log(style)
  // let outputToStyle = np.relative(np.dirname(outputPath), "node_modules/jsondiffpatch/dist/formatters-styles/html.css")

  let passes = [];
  return function (names, ast) {
    if (names != null) {
      if (!Array.isArray(names)) names = [names];
      passes.push([names, cloneWithJsonReferences(ast)]); // passes.push([names, JSON.parse(JSON.stringify(cloneWithJsonReferences(ast), remove__prefixedProperties))])
    } else {
      // convert to HTML
      let previous = null;
      let html = [`
<html>
    <head>
        <style>
        ${style.toString()}
        </style>
        <style>
        :root {
            --border: solid 1px gray;
        }
        body {
            display: flex;
            flex-direction: row;
            font-size: 12px;
            font-family: Monaco;
        }
        article {
            border: var(--border);
        }
        article {
            border: var(--border);
            padding: 0px;
        }
        article:not(:last-child) {
            border-right: none;
        }
        article header {
            color: rgb(150,150,150);
            background-color: rgb(45,45,45);
            font-weight: bold;
            padding: 8px;
            margin: 0px;
            border-bottom: var(--border);
        }
        article header:hover {
            display: flex;
            flex-direction: column;
        }
        article p {
            padding: 0px 8px;
            white-space: pre;
        }
        ins {
            color: lightgreen;
            text-decoration: none;
        }
        del {
            color: red;
            text-decoration: none;
        }
        </style>
    </head>
    <body onclick="location.reload(true)">
`, ...passes.map(([names, ast]) => {
        if (!Array.isArray(names)) names = [names]; // convert to show refs

        let delta = previous != null ? jsondiffpatch.diff(previous, ast) : null;
        let html;

        if (typeof ast === "string") {
          html = ast;
        } else {
          html = require('jsondiffpatch/src/formatters/html').format(delta || {}, previous || ast);
        }

        previous = ast;
        return `
        <article>
            <header><span>${names.join(', </span><span>')}</span></header>
            <p>${format(html)}</p>
        </article>
    `;
      }), `
    </body>
</html>
`].join('');
      common.write(outputPath, html);
      console.log('debug written to ', outputPath);
    }
  };
}

exports.create = create;
},{"./common":"gPgA","fs":"Zcgp","jsondiffpatch":"idyJ","jsondiffpatch/src/formatters/html":"uxiT"}],"ifyw":[function(require,module,exports) {
"use strict";

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const Assembly_1 = __importDefault(require("../ast/Assembly"));

function parsing(root, options) {
  let modules = new Map();

  for (let name in root) {
    let source = root[name];
    let module = options.parser.parse(source, name);
    modules.set(name, module);
  }

  return new Assembly_1.default({
    modules
  });
}

exports.default = parsing;
},{"../ast/Assembly":"MADx"}],"KZbn":[function(require,module,exports) {
/*
  Copyright (C) 2012-2013 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*jslint vars:false, bitwise:true*/

/*jshint indent:4*/

/*global exports:true*/
(function clone(exports) {
  'use strict';

  var Syntax, VisitorOption, VisitorKeys, BREAK, SKIP, REMOVE;

  function deepCopy(obj) {
    var ret = {},
        key,
        val;

    for (key in obj) {
      if (obj.hasOwnProperty(key)) {
        val = obj[key];

        if (typeof val === 'object' && val !== null) {
          ret[key] = deepCopy(val);
        } else {
          ret[key] = val;
        }
      }
    }

    return ret;
  } // based on LLVM libc++ upper_bound / lower_bound
  // MIT License


  function upperBound(array, func) {
    var diff, len, i, current;
    len = array.length;
    i = 0;

    while (len) {
      diff = len >>> 1;
      current = i + diff;

      if (func(array[current])) {
        len = diff;
      } else {
        i = current + 1;
        len -= diff + 1;
      }
    }

    return i;
  }

  Syntax = {
    AssignmentExpression: 'AssignmentExpression',
    AssignmentPattern: 'AssignmentPattern',
    ArrayExpression: 'ArrayExpression',
    ArrayPattern: 'ArrayPattern',
    ArrowFunctionExpression: 'ArrowFunctionExpression',
    AwaitExpression: 'AwaitExpression',
    // CAUTION: It's deferred to ES7.
    BlockStatement: 'BlockStatement',
    BinaryExpression: 'BinaryExpression',
    BreakStatement: 'BreakStatement',
    CallExpression: 'CallExpression',
    CatchClause: 'CatchClause',
    ChainExpression: 'ChainExpression',
    ClassBody: 'ClassBody',
    ClassDeclaration: 'ClassDeclaration',
    ClassExpression: 'ClassExpression',
    ComprehensionBlock: 'ComprehensionBlock',
    // CAUTION: It's deferred to ES7.
    ComprehensionExpression: 'ComprehensionExpression',
    // CAUTION: It's deferred to ES7.
    ConditionalExpression: 'ConditionalExpression',
    ContinueStatement: 'ContinueStatement',
    DebuggerStatement: 'DebuggerStatement',
    DirectiveStatement: 'DirectiveStatement',
    DoWhileStatement: 'DoWhileStatement',
    EmptyStatement: 'EmptyStatement',
    ExportAllDeclaration: 'ExportAllDeclaration',
    ExportDefaultDeclaration: 'ExportDefaultDeclaration',
    ExportNamedDeclaration: 'ExportNamedDeclaration',
    ExportSpecifier: 'ExportSpecifier',
    ExpressionStatement: 'ExpressionStatement',
    ForStatement: 'ForStatement',
    ForInStatement: 'ForInStatement',
    ForOfStatement: 'ForOfStatement',
    FunctionDeclaration: 'FunctionDeclaration',
    FunctionExpression: 'FunctionExpression',
    GeneratorExpression: 'GeneratorExpression',
    // CAUTION: It's deferred to ES7.
    Identifier: 'Identifier',
    IfStatement: 'IfStatement',
    ImportExpression: 'ImportExpression',
    ImportDeclaration: 'ImportDeclaration',
    ImportDefaultSpecifier: 'ImportDefaultSpecifier',
    ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
    ImportSpecifier: 'ImportSpecifier',
    Literal: 'Literal',
    LabeledStatement: 'LabeledStatement',
    LogicalExpression: 'LogicalExpression',
    MemberExpression: 'MemberExpression',
    MetaProperty: 'MetaProperty',
    MethodDefinition: 'MethodDefinition',
    ModuleSpecifier: 'ModuleSpecifier',
    NewExpression: 'NewExpression',
    ObjectExpression: 'ObjectExpression',
    ObjectPattern: 'ObjectPattern',
    Program: 'Program',
    Property: 'Property',
    RestElement: 'RestElement',
    ReturnStatement: 'ReturnStatement',
    SequenceExpression: 'SequenceExpression',
    SpreadElement: 'SpreadElement',
    Super: 'Super',
    SwitchStatement: 'SwitchStatement',
    SwitchCase: 'SwitchCase',
    TaggedTemplateExpression: 'TaggedTemplateExpression',
    TemplateElement: 'TemplateElement',
    TemplateLiteral: 'TemplateLiteral',
    ThisExpression: 'ThisExpression',
    ThrowStatement: 'ThrowStatement',
    TryStatement: 'TryStatement',
    UnaryExpression: 'UnaryExpression',
    UpdateExpression: 'UpdateExpression',
    VariableDeclaration: 'VariableDeclaration',
    VariableDeclarator: 'VariableDeclarator',
    WhileStatement: 'WhileStatement',
    WithStatement: 'WithStatement',
    YieldExpression: 'YieldExpression'
  };
  VisitorKeys = {
    AssignmentExpression: ['left', 'right'],
    AssignmentPattern: ['left', 'right'],
    ArrayExpression: ['elements'],
    ArrayPattern: ['elements'],
    ArrowFunctionExpression: ['params', 'body'],
    AwaitExpression: ['argument'],
    // CAUTION: It's deferred to ES7.
    BlockStatement: ['body'],
    BinaryExpression: ['left', 'right'],
    BreakStatement: ['label'],
    CallExpression: ['callee', 'arguments'],
    CatchClause: ['param', 'body'],
    ChainExpression: ['expression'],
    ClassBody: ['body'],
    ClassDeclaration: ['id', 'superClass', 'body'],
    ClassExpression: ['id', 'superClass', 'body'],
    ComprehensionBlock: ['left', 'right'],
    // CAUTION: It's deferred to ES7.
    ComprehensionExpression: ['blocks', 'filter', 'body'],
    // CAUTION: It's deferred to ES7.
    ConditionalExpression: ['test', 'consequent', 'alternate'],
    ContinueStatement: ['label'],
    DebuggerStatement: [],
    DirectiveStatement: [],
    DoWhileStatement: ['body', 'test'],
    EmptyStatement: [],
    ExportAllDeclaration: ['source'],
    ExportDefaultDeclaration: ['declaration'],
    ExportNamedDeclaration: ['declaration', 'specifiers', 'source'],
    ExportSpecifier: ['exported', 'local'],
    ExpressionStatement: ['expression'],
    ForStatement: ['init', 'test', 'update', 'body'],
    ForInStatement: ['left', 'right', 'body'],
    ForOfStatement: ['left', 'right', 'body'],
    FunctionDeclaration: ['id', 'params', 'body'],
    FunctionExpression: ['id', 'params', 'body'],
    GeneratorExpression: ['blocks', 'filter', 'body'],
    // CAUTION: It's deferred to ES7.
    Identifier: [],
    IfStatement: ['test', 'consequent', 'alternate'],
    ImportExpression: ['source'],
    ImportDeclaration: ['specifiers', 'source'],
    ImportDefaultSpecifier: ['local'],
    ImportNamespaceSpecifier: ['local'],
    ImportSpecifier: ['imported', 'local'],
    Literal: [],
    LabeledStatement: ['label', 'body'],
    LogicalExpression: ['left', 'right'],
    MemberExpression: ['object', 'property'],
    MetaProperty: ['meta', 'property'],
    MethodDefinition: ['key', 'value'],
    ModuleSpecifier: [],
    NewExpression: ['callee', 'arguments'],
    ObjectExpression: ['properties'],
    ObjectPattern: ['properties'],
    Program: ['body'],
    Property: ['key', 'value'],
    RestElement: ['argument'],
    ReturnStatement: ['argument'],
    SequenceExpression: ['expressions'],
    SpreadElement: ['argument'],
    Super: [],
    SwitchStatement: ['discriminant', 'cases'],
    SwitchCase: ['test', 'consequent'],
    TaggedTemplateExpression: ['tag', 'quasi'],
    TemplateElement: [],
    TemplateLiteral: ['quasis', 'expressions'],
    ThisExpression: [],
    ThrowStatement: ['argument'],
    TryStatement: ['block', 'handler', 'finalizer'],
    UnaryExpression: ['argument'],
    UpdateExpression: ['argument'],
    VariableDeclaration: ['declarations'],
    VariableDeclarator: ['id', 'init'],
    WhileStatement: ['test', 'body'],
    WithStatement: ['object', 'body'],
    YieldExpression: ['argument']
  }; // unique id

  BREAK = {};
  SKIP = {};
  REMOVE = {};
  VisitorOption = {
    Break: BREAK,
    Skip: SKIP,
    Remove: REMOVE
  };

  function Reference(parent, key) {
    this.parent = parent;
    this.key = key;
  }

  Reference.prototype.replace = function replace(node) {
    this.parent[this.key] = node;
  };

  Reference.prototype.remove = function remove() {
    if (Array.isArray(this.parent)) {
      this.parent.splice(this.key, 1);
      return true;
    } else {
      this.replace(null);
      return false;
    }
  };

  function Element(node, path, wrap, ref) {
    this.node = node;
    this.path = path;
    this.wrap = wrap;
    this.ref = ref;
  }

  function Controller() {} // API:
  // return property path array from root to current node


  Controller.prototype.path = function path() {
    var i, iz, j, jz, result, element;

    function addToPath(result, path) {
      if (Array.isArray(path)) {
        for (j = 0, jz = path.length; j < jz; ++j) {
          result.push(path[j]);
        }
      } else {
        result.push(path);
      }
    } // root node


    if (!this.__current.path) {
      return null;
    } // first node is sentinel, second node is root element


    result = [];

    for (i = 2, iz = this.__leavelist.length; i < iz; ++i) {
      element = this.__leavelist[i];
      addToPath(result, element.path);
    }

    addToPath(result, this.__current.path);
    return result;
  }; // API:
  // return type of current node


  Controller.prototype.type = function () {
    var node = this.current();
    return node.type || this.__current.wrap;
  }; // API:
  // return array of parent elements


  Controller.prototype.parents = function parents() {
    var i, iz, result; // first node is sentinel

    result = [];

    for (i = 1, iz = this.__leavelist.length; i < iz; ++i) {
      result.push(this.__leavelist[i].node);
    }

    return result;
  }; // API:
  // return current node


  Controller.prototype.current = function current() {
    return this.__current.node;
  };

  Controller.prototype.__execute = function __execute(callback, element) {
    var previous, result;
    result = undefined;
    previous = this.__current;
    this.__current = element;
    this.__state = null;

    if (callback) {
      result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node);
    }

    this.__current = previous;
    return result;
  }; // API:
  // notify control skip / break


  Controller.prototype.notify = function notify(flag) {
    this.__state = flag;
  }; // API:
  // skip child nodes of current node


  Controller.prototype.skip = function () {
    this.notify(SKIP);
  }; // API:
  // break traversals


  Controller.prototype['break'] = function () {
    this.notify(BREAK);
  }; // API:
  // remove node


  Controller.prototype.remove = function () {
    this.notify(REMOVE);
  };

  Controller.prototype.__initialize = function (root, visitor) {
    this.visitor = visitor;
    this.root = root;
    this.__worklist = [];
    this.__leavelist = [];
    this.__current = null;
    this.__state = null;
    this.__fallback = null;

    if (visitor.fallback === 'iteration') {
      this.__fallback = Object.keys;
    } else if (typeof visitor.fallback === 'function') {
      this.__fallback = visitor.fallback;
    }

    this.__keys = VisitorKeys;

    if (visitor.keys) {
      this.__keys = Object.assign(Object.create(this.__keys), visitor.keys);
    }
  };

  function isNode(node) {
    if (node == null) {
      return false;
    }

    return typeof node === 'object' && typeof node.type === 'string';
  }

  function isProperty(nodeType, key) {
    return (nodeType === Syntax.ObjectExpression || nodeType === Syntax.ObjectPattern) && 'properties' === key;
  }

  function candidateExistsInLeaveList(leavelist, candidate) {
    for (var i = leavelist.length - 1; i >= 0; --i) {
      if (leavelist[i].node === candidate) {
        return true;
      }
    }

    return false;
  }

  Controller.prototype.traverse = function traverse(root, visitor) {
    var worklist, leavelist, element, node, nodeType, ret, key, current, current2, candidates, candidate, sentinel;

    this.__initialize(root, visitor);

    sentinel = {}; // reference

    worklist = this.__worklist;
    leavelist = this.__leavelist; // initialize

    worklist.push(new Element(root, null, null, null));
    leavelist.push(new Element(null, null, null, null));

    while (worklist.length) {
      element = worklist.pop();

      if (element === sentinel) {
        element = leavelist.pop();
        ret = this.__execute(visitor.leave, element);

        if (this.__state === BREAK || ret === BREAK) {
          return;
        }

        continue;
      }

      if (element.node) {
        ret = this.__execute(visitor.enter, element);

        if (this.__state === BREAK || ret === BREAK) {
          return;
        }

        worklist.push(sentinel);
        leavelist.push(element);

        if (this.__state === SKIP || ret === SKIP) {
          continue;
        }

        node = element.node;
        nodeType = node.type || element.wrap;
        candidates = this.__keys[nodeType];

        if (!candidates) {
          if (this.__fallback) {
            candidates = this.__fallback(node);
          } else {
            throw new Error('Unknown node type ' + nodeType + '.');
          }
        }

        current = candidates.length;

        while ((current -= 1) >= 0) {
          key = candidates[current];
          candidate = node[key];

          if (!candidate) {
            continue;
          }

          if (Array.isArray(candidate)) {
            current2 = candidate.length;

            while ((current2 -= 1) >= 0) {
              if (!candidate[current2]) {
                continue;
              }

              if (candidateExistsInLeaveList(leavelist, candidate[current2])) {
                continue;
              }

              if (isProperty(nodeType, candidates[current])) {
                element = new Element(candidate[current2], [key, current2], 'Property', null);
              } else if (isNode(candidate[current2])) {
                element = new Element(candidate[current2], [key, current2], null, null);
              } else {
                continue;
              }

              worklist.push(element);
            }
          } else if (isNode(candidate)) {
            if (candidateExistsInLeaveList(leavelist, candidate)) {
              continue;
            }

            worklist.push(new Element(candidate, key, null, null));
          }
        }
      }
    }
  };

  Controller.prototype.replace = function replace(root, visitor) {
    var worklist, leavelist, node, nodeType, target, element, current, current2, candidates, candidate, sentinel, outer, key;

    function removeElem(element) {
      var i, key, nextElem, parent;

      if (element.ref.remove()) {
        // When the reference is an element of an array.
        key = element.ref.key;
        parent = element.ref.parent; // If removed from array, then decrease following items' keys.

        i = worklist.length;

        while (i--) {
          nextElem = worklist[i];

          if (nextElem.ref && nextElem.ref.parent === parent) {
            if (nextElem.ref.key < key) {
              break;
            }

            --nextElem.ref.key;
          }
        }
      }
    }

    this.__initialize(root, visitor);

    sentinel = {}; // reference

    worklist = this.__worklist;
    leavelist = this.__leavelist; // initialize

    outer = {
      root: root
    };
    element = new Element(root, null, null, new Reference(outer, 'root'));
    worklist.push(element);
    leavelist.push(element);

    while (worklist.length) {
      element = worklist.pop();

      if (element === sentinel) {
        element = leavelist.pop();
        target = this.__execute(visitor.leave, element); // node may be replaced with null,
        // so distinguish between undefined and null in this place

        if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {
          // replace
          element.ref.replace(target);
        }

        if (this.__state === REMOVE || target === REMOVE) {
          removeElem(element);
        }

        if (this.__state === BREAK || target === BREAK) {
          return outer.root;
        }

        continue;
      }

      target = this.__execute(visitor.enter, element); // node may be replaced with null,
      // so distinguish between undefined and null in this place

      if (target !== undefined && target !== BREAK && target !== SKIP && target !== REMOVE) {
        // replace
        element.ref.replace(target);
        element.node = target;
      }

      if (this.__state === REMOVE || target === REMOVE) {
        removeElem(element);
        element.node = null;
      }

      if (this.__state === BREAK || target === BREAK) {
        return outer.root;
      } // node may be null


      node = element.node;

      if (!node) {
        continue;
      }

      worklist.push(sentinel);
      leavelist.push(element);

      if (this.__state === SKIP || target === SKIP) {
        continue;
      }

      nodeType = node.type || element.wrap;
      candidates = this.__keys[nodeType];

      if (!candidates) {
        if (this.__fallback) {
          candidates = this.__fallback(node);
        } else {
          throw new Error('Unknown node type ' + nodeType + '.');
        }
      }

      current = candidates.length;

      while ((current -= 1) >= 0) {
        key = candidates[current];
        candidate = node[key];

        if (!candidate) {
          continue;
        }

        if (Array.isArray(candidate)) {
          current2 = candidate.length;

          while ((current2 -= 1) >= 0) {
            if (!candidate[current2]) {
              continue;
            }

            if (isProperty(nodeType, candidates[current])) {
              element = new Element(candidate[current2], [key, current2], 'Property', new Reference(candidate, current2));
            } else if (isNode(candidate[current2])) {
              element = new Element(candidate[current2], [key, current2], null, new Reference(candidate, current2));
            } else {
              continue;
            }

            worklist.push(element);
          }
        } else if (isNode(candidate)) {
          worklist.push(new Element(candidate, key, null, new Reference(node, key)));
        }
      }
    }

    return outer.root;
  };

  function traverse(root, visitor) {
    var controller = new Controller();
    return controller.traverse(root, visitor);
  }

  function replace(root, visitor) {
    var controller = new Controller();
    return controller.replace(root, visitor);
  }

  function extendCommentRange(comment, tokens) {
    var target;
    target = upperBound(tokens, function search(token) {
      return token.range[0] > comment.range[0];
    });
    comment.extendedRange = [comment.range[0], comment.range[1]];

    if (target !== tokens.length) {
      comment.extendedRange[1] = tokens[target].range[0];
    }

    target -= 1;

    if (target >= 0) {
      comment.extendedRange[0] = tokens[target].range[1];
    }

    return comment;
  }

  function attachComments(tree, providedComments, tokens) {
    // At first, we should calculate extended comment ranges.
    var comments = [],
        comment,
        len,
        i,
        cursor;

    if (!tree.range) {
      throw new Error('attachComments needs range information');
    } // tokens array is empty, we attach comments to tree as 'leadingComments'


    if (!tokens.length) {
      if (providedComments.length) {
        for (i = 0, len = providedComments.length; i < len; i += 1) {
          comment = deepCopy(providedComments[i]);
          comment.extendedRange = [0, tree.range[0]];
          comments.push(comment);
        }

        tree.leadingComments = comments;
      }

      return tree;
    }

    for (i = 0, len = providedComments.length; i < len; i += 1) {
      comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));
    } // This is based on John Freeman's implementation.


    cursor = 0;
    traverse(tree, {
      enter: function (node) {
        var comment;

        while (cursor < comments.length) {
          comment = comments[cursor];

          if (comment.extendedRange[1] > node.range[0]) {
            break;
          }

          if (comment.extendedRange[1] === node.range[0]) {
            if (!node.leadingComments) {
              node.leadingComments = [];
            }

            node.leadingComments.push(comment);
            comments.splice(cursor, 1);
          } else {
            cursor += 1;
          }
        } // already out of owned node


        if (cursor === comments.length) {
          return VisitorOption.Break;
        }

        if (comments[cursor].extendedRange[0] > node.range[1]) {
          return VisitorOption.Skip;
        }
      }
    });
    cursor = 0;
    traverse(tree, {
      leave: function (node) {
        var comment;

        while (cursor < comments.length) {
          comment = comments[cursor];

          if (node.range[1] < comment.extendedRange[0]) {
            break;
          }

          if (node.range[1] === comment.extendedRange[0]) {
            if (!node.trailingComments) {
              node.trailingComments = [];
            }

            node.trailingComments.push(comment);
            comments.splice(cursor, 1);
          } else {
            cursor += 1;
          }
        } // already out of owned node


        if (cursor === comments.length) {
          return VisitorOption.Break;
        }

        if (comments[cursor].extendedRange[0] > node.range[1]) {
          return VisitorOption.Skip;
        }
      }
    });
    return tree;
  }

  exports.Syntax = Syntax;
  exports.traverse = traverse;
  exports.replace = replace;
  exports.attachComments = attachComments;
  exports.VisitorKeys = VisitorKeys;
  exports.VisitorOption = VisitorOption;
  exports.Controller = Controller;

  exports.cloneEnvironment = function () {
    return clone({});
  };

  return exports;
})(exports);
/* vim: set sw=4 ts=4 et tw=80 : */
},{}],"BO5I":[function(require,module,exports) {
/*
  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS'
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
(function () {
  'use strict';

  function isExpression(node) {
    if (node == null) {
      return false;
    }

    switch (node.type) {
      case 'ArrayExpression':
      case 'AssignmentExpression':
      case 'BinaryExpression':
      case 'CallExpression':
      case 'ConditionalExpression':
      case 'FunctionExpression':
      case 'Identifier':
      case 'Literal':
      case 'LogicalExpression':
      case 'MemberExpression':
      case 'NewExpression':
      case 'ObjectExpression':
      case 'SequenceExpression':
      case 'ThisExpression':
      case 'UnaryExpression':
      case 'UpdateExpression':
        return true;
    }

    return false;
  }

  function isIterationStatement(node) {
    if (node == null) {
      return false;
    }

    switch (node.type) {
      case 'DoWhileStatement':
      case 'ForInStatement':
      case 'ForStatement':
      case 'WhileStatement':
        return true;
    }

    return false;
  }

  function isStatement(node) {
    if (node == null) {
      return false;
    }

    switch (node.type) {
      case 'BlockStatement':
      case 'BreakStatement':
      case 'ContinueStatement':
      case 'DebuggerStatement':
      case 'DoWhileStatement':
      case 'EmptyStatement':
      case 'ExpressionStatement':
      case 'ForInStatement':
      case 'ForStatement':
      case 'IfStatement':
      case 'LabeledStatement':
      case 'ReturnStatement':
      case 'SwitchStatement':
      case 'ThrowStatement':
      case 'TryStatement':
      case 'VariableDeclaration':
      case 'WhileStatement':
      case 'WithStatement':
        return true;
    }

    return false;
  }

  function isSourceElement(node) {
    return isStatement(node) || node != null && node.type === 'FunctionDeclaration';
  }

  function trailingStatement(node) {
    switch (node.type) {
      case 'IfStatement':
        if (node.alternate != null) {
          return node.alternate;
        }

        return node.consequent;

      case 'LabeledStatement':
      case 'ForStatement':
      case 'ForInStatement':
      case 'WhileStatement':
      case 'WithStatement':
        return node.body;
    }

    return null;
  }

  function isProblematicIfStatement(node) {
    var current;

    if (node.type !== 'IfStatement') {
      return false;
    }

    if (node.alternate == null) {
      return false;
    }

    current = node.consequent;

    do {
      if (current.type === 'IfStatement') {
        if (current.alternate == null) {
          return true;
        }
      }

      current = trailingStatement(current);
    } while (current);

    return false;
  }

  module.exports = {
    isExpression: isExpression,
    isStatement: isStatement,
    isIterationStatement: isIterationStatement,
    isSourceElement: isSourceElement,
    isProblematicIfStatement: isProblematicIfStatement,
    trailingStatement: trailingStatement
  };
})();
/* vim: set sw=4 ts=4 et tw=80 : */
},{}],"hNKN":[function(require,module,exports) {
/*
  Copyright (C) 2013-2014 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2014 Ivan Nikulin <ifaaan@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
(function () {
  'use strict';

  var ES6Regex, ES5Regex, NON_ASCII_WHITESPACES, IDENTIFIER_START, IDENTIFIER_PART, ch; // See `tools/generate-identifier-regex.js`.

  ES5Regex = {
    // ECMAScript 5.1/Unicode v9.0.0 NonAsciiIdentifierStart:
    NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
    // ECMAScript 5.1/Unicode v9.0.0 NonAsciiIdentifierPart:
    NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/
  };
  ES6Regex = {
    // ECMAScript 6/Unicode v9.0.0 NonAsciiIdentifierStart:
    NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
    // ECMAScript 6/Unicode v9.0.0 NonAsciiIdentifierPart:
    NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
  };

  function isDecimalDigit(ch) {
    return 0x30 <= ch && ch <= 0x39; // 0..9
  }

  function isHexDigit(ch) {
    return 0x30 <= ch && ch <= 0x39 || // 0..9
    0x61 <= ch && ch <= 0x66 || // a..f
    0x41 <= ch && ch <= 0x46; // A..F
  }

  function isOctalDigit(ch) {
    return ch >= 0x30 && ch <= 0x37; // 0..7
  } // 7.2 White Space


  NON_ASCII_WHITESPACES = [0x1680, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF];

  function isWhiteSpace(ch) {
    return ch === 0x20 || ch === 0x09 || ch === 0x0B || ch === 0x0C || ch === 0xA0 || ch >= 0x1680 && NON_ASCII_WHITESPACES.indexOf(ch) >= 0;
  } // 7.3 Line Terminators


  function isLineTerminator(ch) {
    return ch === 0x0A || ch === 0x0D || ch === 0x2028 || ch === 0x2029;
  } // 7.6 Identifier Names and Identifiers


  function fromCodePoint(cp) {
    if (cp <= 0xFFFF) {
      return String.fromCharCode(cp);
    }

    var cu1 = String.fromCharCode(Math.floor((cp - 0x10000) / 0x400) + 0xD800);
    var cu2 = String.fromCharCode((cp - 0x10000) % 0x400 + 0xDC00);
    return cu1 + cu2;
  }

  IDENTIFIER_START = new Array(0x80);

  for (ch = 0; ch < 0x80; ++ch) {
    IDENTIFIER_START[ch] = ch >= 0x61 && ch <= 0x7A || // a..z
    ch >= 0x41 && ch <= 0x5A || // A..Z
    ch === 0x24 || ch === 0x5F; // $ (dollar) and _ (underscore)
  }

  IDENTIFIER_PART = new Array(0x80);

  for (ch = 0; ch < 0x80; ++ch) {
    IDENTIFIER_PART[ch] = ch >= 0x61 && ch <= 0x7A || // a..z
    ch >= 0x41 && ch <= 0x5A || // A..Z
    ch >= 0x30 && ch <= 0x39 || // 0..9
    ch === 0x24 || ch === 0x5F; // $ (dollar) and _ (underscore)
  }

  function isIdentifierStartES5(ch) {
    return ch < 0x80 ? IDENTIFIER_START[ch] : ES5Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));
  }

  function isIdentifierPartES5(ch) {
    return ch < 0x80 ? IDENTIFIER_PART[ch] : ES5Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));
  }

  function isIdentifierStartES6(ch) {
    return ch < 0x80 ? IDENTIFIER_START[ch] : ES6Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));
  }

  function isIdentifierPartES6(ch) {
    return ch < 0x80 ? IDENTIFIER_PART[ch] : ES6Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));
  }

  module.exports = {
    isDecimalDigit: isDecimalDigit,
    isHexDigit: isHexDigit,
    isOctalDigit: isOctalDigit,
    isWhiteSpace: isWhiteSpace,
    isLineTerminator: isLineTerminator,
    isIdentifierStartES5: isIdentifierStartES5,
    isIdentifierPartES5: isIdentifierPartES5,
    isIdentifierStartES6: isIdentifierStartES6,
    isIdentifierPartES6: isIdentifierPartES6
  };
})();
/* vim: set sw=4 ts=4 et tw=80 : */
},{}],"EREB":[function(require,module,exports) {
/*
  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
(function () {
  'use strict';

  var code = require('./code');

  function isStrictModeReservedWordES6(id) {
    switch (id) {
      case 'implements':
      case 'interface':
      case 'package':
      case 'private':
      case 'protected':
      case 'public':
      case 'static':
      case 'let':
        return true;

      default:
        return false;
    }
  }

  function isKeywordES5(id, strict) {
    // yield should not be treated as keyword under non-strict mode.
    if (!strict && id === 'yield') {
      return false;
    }

    return isKeywordES6(id, strict);
  }

  function isKeywordES6(id, strict) {
    if (strict && isStrictModeReservedWordES6(id)) {
      return true;
    }

    switch (id.length) {
      case 2:
        return id === 'if' || id === 'in' || id === 'do';

      case 3:
        return id === 'var' || id === 'for' || id === 'new' || id === 'try';

      case 4:
        return id === 'this' || id === 'else' || id === 'case' || id === 'void' || id === 'with' || id === 'enum';

      case 5:
        return id === 'while' || id === 'break' || id === 'catch' || id === 'throw' || id === 'const' || id === 'yield' || id === 'class' || id === 'super';

      case 6:
        return id === 'return' || id === 'typeof' || id === 'delete' || id === 'switch' || id === 'export' || id === 'import';

      case 7:
        return id === 'default' || id === 'finally' || id === 'extends';

      case 8:
        return id === 'function' || id === 'continue' || id === 'debugger';

      case 10:
        return id === 'instanceof';

      default:
        return false;
    }
  }

  function isReservedWordES5(id, strict) {
    return id === 'null' || id === 'true' || id === 'false' || isKeywordES5(id, strict);
  }

  function isReservedWordES6(id, strict) {
    return id === 'null' || id === 'true' || id === 'false' || isKeywordES6(id, strict);
  }

  function isRestrictedWord(id) {
    return id === 'eval' || id === 'arguments';
  }

  function isIdentifierNameES5(id) {
    var i, iz, ch;

    if (id.length === 0) {
      return false;
    }

    ch = id.charCodeAt(0);

    if (!code.isIdentifierStartES5(ch)) {
      return false;
    }

    for (i = 1, iz = id.length; i < iz; ++i) {
      ch = id.charCodeAt(i);

      if (!code.isIdentifierPartES5(ch)) {
        return false;
      }
    }

    return true;
  }

  function decodeUtf16(lead, trail) {
    return (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
  }

  function isIdentifierNameES6(id) {
    var i, iz, ch, lowCh, check;

    if (id.length === 0) {
      return false;
    }

    check = code.isIdentifierStartES6;

    for (i = 0, iz = id.length; i < iz; ++i) {
      ch = id.charCodeAt(i);

      if (0xD800 <= ch && ch <= 0xDBFF) {
        ++i;

        if (i >= iz) {
          return false;
        }

        lowCh = id.charCodeAt(i);

        if (!(0xDC00 <= lowCh && lowCh <= 0xDFFF)) {
          return false;
        }

        ch = decodeUtf16(ch, lowCh);
      }

      if (!check(ch)) {
        return false;
      }

      check = code.isIdentifierPartES6;
    }

    return true;
  }

  function isIdentifierES5(id, strict) {
    return isIdentifierNameES5(id) && !isReservedWordES5(id, strict);
  }

  function isIdentifierES6(id, strict) {
    return isIdentifierNameES6(id) && !isReservedWordES6(id, strict);
  }

  module.exports = {
    isKeywordES5: isKeywordES5,
    isKeywordES6: isKeywordES6,
    isReservedWordES5: isReservedWordES5,
    isReservedWordES6: isReservedWordES6,
    isRestrictedWord: isRestrictedWord,
    isIdentifierNameES5: isIdentifierNameES5,
    isIdentifierNameES6: isIdentifierNameES6,
    isIdentifierES5: isIdentifierES5,
    isIdentifierES6: isIdentifierES6
  };
})();
/* vim: set sw=4 ts=4 et tw=80 : */
},{"./code":"hNKN"}],"G2Da":[function(require,module,exports) {
/*
  Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
(function () {
  'use strict';

  exports.ast = require('./ast');
  exports.code = require('./code');
  exports.keyword = require('./keyword');
})();
/* vim: set sw=4 ts=4 et tw=80 : */
},{"./ast":"BO5I","./code":"hNKN","./keyword":"EREB"}],"HmDI":[function(require,module,exports) {
/* -*- Mode: js; js-indent-level: 2; -*- */

/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');
/**
 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
 */

exports.encode = function (number) {
  if (0 <= number && number < intToCharMap.length) {
    return intToCharMap[number];
  }

  throw new TypeError("Must be between 0 and 63: " + number);
};
/**
 * Decode a single base 64 character code digit to an integer. Returns -1 on
 * failure.
 */


exports.decode = function (charCode) {
  var bigA = 65; // 'A'

  var bigZ = 90; // 'Z'

  var littleA = 97; // 'a'

  var littleZ = 122; // 'z'

  var zero = 48; // '0'

  var nine = 57; // '9'

  var plus = 43; // '+'

  var slash = 47; // '/'

  var littleOffset = 26;
  var numberOffset = 52; // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ

  if (bigA <= charCode && charCode <= bigZ) {
    return charCode - bigA;
  } // 26 - 51: abcdefghijklmnopqrstuvwxyz


  if (littleA <= charCode && charCode <= littleZ) {
    return charCode - littleA + littleOffset;
  } // 52 - 61: 0123456789


  if (zero <= charCode && charCode <= nine) {
    return charCode - zero + numberOffset;
  } // 62: +


  if (charCode == plus) {
    return 62;
  } // 63: /


  if (charCode == slash) {
    return 63;
  } // Invalid base64 digit.


  return -1;
};
},{}],"cU6c":[function(require,module,exports) {
/* -*- Mode: js; js-indent-level: 2; -*- */

/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
var base64 = require('./base64'); // A single base 64 digit can contain 6 bits of data. For the base 64 variable
// length quantities we use in the source map spec, the first bit is the sign,
// the next four bits are the actual value, and the 6th bit is the
// continuation bit. The continuation bit tells us whether there are more
// digits in this value following this digit.
//
//   Continuation
//   |    Sign
//   |    |
//   V    V
//   101011


var VLQ_BASE_SHIFT = 5; // binary: 100000

var VLQ_BASE = 1 << VLQ_BASE_SHIFT; // binary: 011111

var VLQ_BASE_MASK = VLQ_BASE - 1; // binary: 100000

var VLQ_CONTINUATION_BIT = VLQ_BASE;
/**
 * Converts from a two-complement value to a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
 */

function toVLQSigned(aValue) {
  return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
}
/**
 * Converts to a two-complement value from a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
 */


function fromVLQSigned(aValue) {
  var isNegative = (aValue & 1) === 1;
  var shifted = aValue >> 1;
  return isNegative ? -shifted : shifted;
}
/**
 * Returns the base 64 VLQ encoded value.
 */


exports.encode = function base64VLQ_encode(aValue) {
  var encoded = "";
  var digit;
  var vlq = toVLQSigned(aValue);

  do {
    digit = vlq & VLQ_BASE_MASK;
    vlq >>>= VLQ_BASE_SHIFT;

    if (vlq > 0) {
      // There are still more digits in this value, so we must make sure the
      // continuation bit is marked.
      digit |= VLQ_CONTINUATION_BIT;
    }

    encoded += base64.encode(digit);
  } while (vlq > 0);

  return encoded;
};
/**
 * Decodes the next base 64 VLQ value from the given string and returns the
 * value and the rest of the string via the out parameter.
 */


exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
  var strLen = aStr.length;
  var result = 0;
  var shift = 0;
  var continuation, digit;

  do {
    if (aIndex >= strLen) {
      throw new Error("Expected more digits in base 64 VLQ value.");
    }

    digit = base64.decode(aStr.charCodeAt(aIndex++));

    if (digit === -1) {
      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
    }

    continuation = !!(digit & VLQ_CONTINUATION_BIT);
    digit &= VLQ_BASE_MASK;
    result = result + (digit << shift);
    shift += VLQ_BASE_SHIFT;
  } while (continuation);

  aOutParam.value = fromVLQSigned(result);
  aOutParam.rest = aIndex;
};
},{"./base64":"HmDI"}],"BhAh":[function(require,module,exports) {
/* -*- Mode: js; js-indent-level: 2; -*- */

/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

/**
 * This is a helper function for getting values from parameter/options
 * objects.
 *
 * @param args The object we are extracting values from
 * @param name The name of the property we are getting.
 * @param defaultValue An optional value to return if the property is missing
 * from the object. If this is not specified and the property is missing, an
 * error will be thrown.
 */
function getArg(aArgs, aName, aDefaultValue) {
  if (aName in aArgs) {
    return aArgs[aName];
  } else if (arguments.length === 3) {
    return aDefaultValue;
  } else {
    throw new Error('"' + aName + '" is a required argument.');
  }
}

exports.getArg = getArg;
var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
var dataUrlRegexp = /^data:.+\,.+$/;

function urlParse(aUrl) {
  var match = aUrl.match(urlRegexp);

  if (!match) {
    return null;
  }

  return {
    scheme: match[1],
    auth: match[2],
    host: match[3],
    port: match[4],
    path: match[5]
  };
}

exports.urlParse = urlParse;

function urlGenerate(aParsedUrl) {
  var url = '';

  if (aParsedUrl.scheme) {
    url += aParsedUrl.scheme + ':';
  }

  url += '//';

  if (aParsedUrl.auth) {
    url += aParsedUrl.auth + '@';
  }

  if (aParsedUrl.host) {
    url += aParsedUrl.host;
  }

  if (aParsedUrl.port) {
    url += ":" + aParsedUrl.port;
  }

  if (aParsedUrl.path) {
    url += aParsedUrl.path;
  }

  return url;
}

exports.urlGenerate = urlGenerate;
/**
 * Normalizes a path, or the path portion of a URL:
 *
 * - Replaces consecutive slashes with one slash.
 * - Removes unnecessary '.' parts.
 * - Removes unnecessary '<dir>/..' parts.
 *
 * Based on code in the Node.js 'path' core module.
 *
 * @param aPath The path or url to normalize.
 */

function normalize(aPath) {
  var path = aPath;
  var url = urlParse(aPath);

  if (url) {
    if (!url.path) {
      return aPath;
    }

    path = url.path;
  }

  var isAbsolute = exports.isAbsolute(path);
  var parts = path.split(/\/+/);

  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
    part = parts[i];

    if (part === '.') {
      parts.splice(i, 1);
    } else if (part === '..') {
      up++;
    } else if (up > 0) {
      if (part === '') {
        // The first part is blank if the path is absolute. Trying to go
        // above the root is a no-op. Therefore we can remove all '..' parts
        // directly after the root.
        parts.splice(i + 1, up);
        up = 0;
      } else {
        parts.splice(i, 2);
        up--;
      }
    }
  }

  path = parts.join('/');

  if (path === '') {
    path = isAbsolute ? '/' : '.';
  }

  if (url) {
    url.path = path;
    return urlGenerate(url);
  }

  return path;
}

exports.normalize = normalize;
/**
 * Joins two paths/URLs.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be joined with the root.
 *
 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
 *   first.
 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
 *   is updated with the result and aRoot is returned. Otherwise the result
 *   is returned.
 *   - If aPath is absolute, the result is aPath.
 *   - Otherwise the two paths are joined with a slash.
 * - Joining for example 'http://' and 'www.example.com' is also supported.
 */

function join(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }

  if (aPath === "") {
    aPath = ".";
  }

  var aPathUrl = urlParse(aPath);
  var aRootUrl = urlParse(aRoot);

  if (aRootUrl) {
    aRoot = aRootUrl.path || '/';
  } // `join(foo, '//www.example.org')`


  if (aPathUrl && !aPathUrl.scheme) {
    if (aRootUrl) {
      aPathUrl.scheme = aRootUrl.scheme;
    }

    return urlGenerate(aPathUrl);
  }

  if (aPathUrl || aPath.match(dataUrlRegexp)) {
    return aPath;
  } // `join('http://', 'www.example.com')`


  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
    aRootUrl.host = aPath;
    return urlGenerate(aRootUrl);
  }

  var joined = aPath.charAt(0) === '/' ? aPath : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

  if (aRootUrl) {
    aRootUrl.path = joined;
    return urlGenerate(aRootUrl);
  }

  return joined;
}

exports.join = join;

exports.isAbsolute = function (aPath) {
  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
};
/**
 * Make a path relative to a URL or another path.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be made relative to aRoot.
 */


function relative(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }

  aRoot = aRoot.replace(/\/$/, ''); // It is possible for the path to be above the root. In this case, simply
  // checking whether the root is a prefix of the path won't work. Instead, we
  // need to remove components from the root one by one, until either we find
  // a prefix that fits, or we run out of components to remove.

  var level = 0;

  while (aPath.indexOf(aRoot + '/') !== 0) {
    var index = aRoot.lastIndexOf("/");

    if (index < 0) {
      return aPath;
    } // If the only part of the root that is left is the scheme (i.e. http://,
    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
    // have exhausted all components, so the path is not relative to the root.


    aRoot = aRoot.slice(0, index);

    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
      return aPath;
    }

    ++level;
  } // Make sure we add a "../" for each component we removed from the root.


  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
}

exports.relative = relative;

var supportsNullProto = function () {
  var obj = Object.create(null);
  return !('__proto__' in obj);
}();

function identity(s) {
  return s;
}
/**
 * Because behavior goes wacky when you set `__proto__` on objects, we
 * have to prefix all the strings in our set with an arbitrary character.
 *
 * See https://github.com/mozilla/source-map/pull/31 and
 * https://github.com/mozilla/source-map/issues/30
 *
 * @param String aStr
 */


function toSetString(aStr) {
  if (isProtoString(aStr)) {
    return '$' + aStr;
  }

  return aStr;
}

exports.toSetString = supportsNullProto ? identity : toSetString;

function fromSetString(aStr) {
  if (isProtoString(aStr)) {
    return aStr.slice(1);
  }

  return aStr;
}

exports.fromSetString = supportsNullProto ? identity : fromSetString;

function isProtoString(s) {
  if (!s) {
    return false;
  }

  var length = s.length;

  if (length < 9
  /* "__proto__".length */
  ) {
      return false;
    }

  if (s.charCodeAt(length - 1) !== 95
  /* '_' */
  || s.charCodeAt(length - 2) !== 95
  /* '_' */
  || s.charCodeAt(length - 3) !== 111
  /* 'o' */
  || s.charCodeAt(length - 4) !== 116
  /* 't' */
  || s.charCodeAt(length - 5) !== 111
  /* 'o' */
  || s.charCodeAt(length - 6) !== 114
  /* 'r' */
  || s.charCodeAt(length - 7) !== 112
  /* 'p' */
  || s.charCodeAt(length - 8) !== 95
  /* '_' */
  || s.charCodeAt(length - 9) !== 95
  /* '_' */
  ) {
      return false;
    }

  for (var i = length - 10; i >= 0; i--) {
    if (s.charCodeAt(i) !== 36
    /* '$' */
    ) {
        return false;
      }
  }

  return true;
}
/**
 * Comparator between two mappings where the original positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same original source/line/column, but different generated
 * line and column the same. Useful when searching for a mapping with a
 * stubbed out mapping.
 */


function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
  var cmp = strcmp(mappingA.source, mappingB.source);

  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;

  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;

  if (cmp !== 0 || onlyCompareOriginal) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;

  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedLine - mappingB.generatedLine;

  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}

exports.compareByOriginalPositions = compareByOriginalPositions;
/**
 * Comparator between two mappings with deflated source and name indices where
 * the generated positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same generated line and column, but different
 * source/name/original line and column the same. Useful when searching for a
 * mapping with a stubbed out mapping.
 */

function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;

  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;

  if (cmp !== 0 || onlyCompareGenerated) {
    return cmp;
  }

  cmp = strcmp(mappingA.source, mappingB.source);

  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;

  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;

  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}

exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

function strcmp(aStr1, aStr2) {
  if (aStr1 === aStr2) {
    return 0;
  }

  if (aStr1 === null) {
    return 1; // aStr2 !== null
  }

  if (aStr2 === null) {
    return -1; // aStr1 !== null
  }

  if (aStr1 > aStr2) {
    return 1;
  }

  return -1;
}
/**
 * Comparator between two mappings with inflated source and name strings where
 * the generated positions are compared.
 */


function compareByGeneratedPositionsInflated(mappingA, mappingB) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;

  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;

  if (cmp !== 0) {
    return cmp;
  }

  cmp = strcmp(mappingA.source, mappingB.source);

  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;

  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;

  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}

exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
/**
 * Strip any JSON XSSI avoidance prefix from the string (as documented
 * in the source maps specification), and then parse the string as
 * JSON.
 */

function parseSourceMapInput(str) {
  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
}

exports.parseSourceMapInput = parseSourceMapInput;
/**
 * Compute the URL of a source given the the source root, the source's
 * URL, and the source map's URL.
 */

function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
  sourceURL = sourceURL || '';

  if (sourceRoot) {
    // This follows what Chrome does.
    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
      sourceRoot += '/';
    } // The spec says:
    //   Line 4: An optional source root, useful for relocating source
    //   files on a server or removing repeated values in the
    //   sources entry.  This value is prepended to the individual
    //   entries in the source field.


    sourceURL = sourceRoot + sourceURL;
  } // Historically, SourceMapConsumer did not take the sourceMapURL as
  // a parameter.  This mode is still somewhat supported, which is why
  // this code block is conditional.  However, it's preferable to pass
  // the source map URL to SourceMapConsumer, so that this function
  // can implement the source URL resolution algorithm as outlined in
  // the spec.  This block is basically the equivalent of:
  //    new URL(sourceURL, sourceMapURL).toString()
  // ... except it avoids using URL, which wasn't available in the
  // older releases of node still supported by this library.
  //
  // The spec says:
  //   If the sources are not absolute URLs after prepending of the
  //   sourceRoot, the sources are resolved relative to the
  //   SourceMap (like resolving script src in a html document).


  if (sourceMapURL) {
    var parsed = urlParse(sourceMapURL);

    if (!parsed) {
      throw new Error("sourceMapURL could not be parsed");
    }

    if (parsed.path) {
      // Strip the last path component, but keep the "/".
      var index = parsed.path.lastIndexOf('/');

      if (index >= 0) {
        parsed.path = parsed.path.substring(0, index + 1);
      }
    }

    sourceURL = join(urlGenerate(parsed), sourceURL);
  }

  return normalize(sourceURL);
}

exports.computeSourceURL = computeSourceURL;
},{}],"MUWy":[function(require,module,exports) {
/* -*- Mode: js; js-indent-level: 2; -*- */

/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
var util = require('./util');

var has = Object.prototype.hasOwnProperty;
var hasNativeMap = typeof Map !== "undefined";
/**
 * A data structure which is a combination of an array and a set. Adding a new
 * member is O(1), testing for membership is O(1), and finding the index of an
 * element is O(1). Removing elements from the set is not supported. Only
 * strings are supported for membership.
 */

function ArraySet() {
  this._array = [];
  this._set = hasNativeMap ? new Map() : Object.create(null);
}
/**
 * Static method for creating ArraySet instances from an existing array.
 */


ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
  var set = new ArraySet();

  for (var i = 0, len = aArray.length; i < len; i++) {
    set.add(aArray[i], aAllowDuplicates);
  }

  return set;
};
/**
 * Return how many unique items are in this ArraySet. If duplicates have been
 * added, than those do not count towards the size.
 *
 * @returns Number
 */


ArraySet.prototype.size = function ArraySet_size() {
  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
};
/**
 * Add the given string to this set.
 *
 * @param String aStr
 */


ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
  var idx = this._array.length;

  if (!isDuplicate || aAllowDuplicates) {
    this._array.push(aStr);
  }

  if (!isDuplicate) {
    if (hasNativeMap) {
      this._set.set(aStr, idx);
    } else {
      this._set[sStr] = idx;
    }
  }
};
/**
 * Is the given string a member of this set?
 *
 * @param String aStr
 */


ArraySet.prototype.has = function ArraySet_has(aStr) {
  if (hasNativeMap) {
    return this._set.has(aStr);
  } else {
    var sStr = util.toSetString(aStr);
    return has.call(this._set, sStr);
  }
};
/**
 * What is the index of the given string in the array?
 *
 * @param String aStr
 */


ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
  if (hasNativeMap) {
    var idx = this._set.get(aStr);

    if (idx >= 0) {
      return idx;
    }
  } else {
    var sStr = util.toSetString(aStr);

    if (has.call(this._set, sStr)) {
      return this._set[sStr];
    }
  }

  throw new Error('"' + aStr + '" is not in the set.');
};
/**
 * What is the element at the given index?
 *
 * @param Number aIdx
 */


ArraySet.prototype.at = function ArraySet_at(aIdx) {
  if (aIdx >= 0 && aIdx < this._array.length) {
    return this._array[aIdx];
  }

  throw new Error('No element indexed by ' + aIdx);
};
/**
 * Returns the array representation of this set (which has the proper indices
 * indicated by indexOf). Note that this is a copy of the internal array used
 * for storing the members so that no one can mess with internal state.
 */


ArraySet.prototype.toArray = function ArraySet_toArray() {
  return this._array.slice();
};

exports.ArraySet = ArraySet;
},{"./util":"BhAh"}],"LNU8":[function(require,module,exports) {
/* -*- Mode: js; js-indent-level: 2; -*- */

/*
 * Copyright 2014 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
var util = require('./util');
/**
 * Determine whether mappingB is after mappingA with respect to generated
 * position.
 */


function generatedPositionAfter(mappingA, mappingB) {
  // Optimized for most common case
  var lineA = mappingA.generatedLine;
  var lineB = mappingB.generatedLine;
  var columnA = mappingA.generatedColumn;
  var columnB = mappingB.generatedColumn;
  return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
}
/**
 * A data structure to provide a sorted view of accumulated mappings in a
 * performance conscious manner. It trades a neglibable overhead in general
 * case for a large speedup in case of mappings being added in order.
 */


function MappingList() {
  this._array = [];
  this._sorted = true; // Serves as infimum

  this._last = {
    generatedLine: -1,
    generatedColumn: 0
  };
}
/**
 * Iterate through internal items. This method takes the same arguments that
 * `Array.prototype.forEach` takes.
 *
 * NOTE: The order of the mappings is NOT guaranteed.
 */


MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
  this._array.forEach(aCallback, aThisArg);
};
/**
 * Add the given source mapping.
 *
 * @param Object aMapping
 */


MappingList.prototype.add = function MappingList_add(aMapping) {
  if (generatedPositionAfter(this._last, aMapping)) {
    this._last = aMapping;

    this._array.push(aMapping);
  } else {
    this._sorted = false;

    this._array.push(aMapping);
  }
};
/**
 * Returns the flat, sorted array of mappings. The mappings are sorted by
 * generated position.
 *
 * WARNING: This method returns internal data without copying, for
 * performance. The return value must NOT be mutated, and should be treated as
 * an immutable borrow. If you want to take ownership, you must make your own
 * copy.
 */


MappingList.prototype.toArray = function MappingList_toArray() {
  if (!this._sorted) {
    this._array.sort(util.compareByGeneratedPositionsInflated);

    this._sorted = true;
  }

  return this._array;
};

exports.MappingList = MappingList;
},{"./util":"BhAh"}],"YuZZ":[function(require,module,exports) {
/* -*- Mode: js; js-indent-level: 2; -*- */

/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
var base64VLQ = require('./base64-vlq');

var util = require('./util');

var ArraySet = require('./array-set').ArraySet;

var MappingList = require('./mapping-list').MappingList;
/**
 * An instance of the SourceMapGenerator represents a source map which is
 * being built incrementally. You may pass an object with the following
 * properties:
 *
 *   - file: The filename of the generated source.
 *   - sourceRoot: A root for all relative URLs in this source map.
 */


function SourceMapGenerator(aArgs) {
  if (!aArgs) {
    aArgs = {};
  }

  this._file = util.getArg(aArgs, 'file', null);
  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
  this._sources = new ArraySet();
  this._names = new ArraySet();
  this._mappings = new MappingList();
  this._sourcesContents = null;
}

SourceMapGenerator.prototype._version = 3;
/**
 * Creates a new SourceMapGenerator based on a SourceMapConsumer
 *
 * @param aSourceMapConsumer The SourceMap.
 */

SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
  var sourceRoot = aSourceMapConsumer.sourceRoot;
  var generator = new SourceMapGenerator({
    file: aSourceMapConsumer.file,
    sourceRoot: sourceRoot
  });
  aSourceMapConsumer.eachMapping(function (mapping) {
    var newMapping = {
      generated: {
        line: mapping.generatedLine,
        column: mapping.generatedColumn
      }
    };

    if (mapping.source != null) {
      newMapping.source = mapping.source;

      if (sourceRoot != null) {
        newMapping.source = util.relative(sourceRoot, newMapping.source);
      }

      newMapping.original = {
        line: mapping.originalLine,
        column: mapping.originalColumn
      };

      if (mapping.name != null) {
        newMapping.name = mapping.name;
      }
    }

    generator.addMapping(newMapping);
  });
  aSourceMapConsumer.sources.forEach(function (sourceFile) {
    var sourceRelative = sourceFile;

    if (sourceRoot !== null) {
      sourceRelative = util.relative(sourceRoot, sourceFile);
    }

    if (!generator._sources.has(sourceRelative)) {
      generator._sources.add(sourceRelative);
    }

    var content = aSourceMapConsumer.sourceContentFor(sourceFile);

    if (content != null) {
      generator.setSourceContent(sourceFile, content);
    }
  });
  return generator;
};
/**
 * Add a single mapping from original source line and column to the generated
 * source's line and column for this source map being created. The mapping
 * object should have the following properties:
 *
 *   - generated: An object with the generated line and column positions.
 *   - original: An object with the original line and column positions.
 *   - source: The original source file (relative to the sourceRoot).
 *   - name: An optional original token name for this mapping.
 */


SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
  var generated = util.getArg(aArgs, 'generated');
  var original = util.getArg(aArgs, 'original', null);
  var source = util.getArg(aArgs, 'source', null);
  var name = util.getArg(aArgs, 'name', null);

  if (!this._skipValidation) {
    this._validateMapping(generated, original, source, name);
  }

  if (source != null) {
    source = String(source);

    if (!this._sources.has(source)) {
      this._sources.add(source);
    }
  }

  if (name != null) {
    name = String(name);

    if (!this._names.has(name)) {
      this._names.add(name);
    }
  }

  this._mappings.add({
    generatedLine: generated.line,
    generatedColumn: generated.column,
    originalLine: original != null && original.line,
    originalColumn: original != null && original.column,
    source: source,
    name: name
  });
};
/**
 * Set the source content for a source file.
 */


SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
  var source = aSourceFile;

  if (this._sourceRoot != null) {
    source = util.relative(this._sourceRoot, source);
  }

  if (aSourceContent != null) {
    // Add the source content to the _sourcesContents map.
    // Create a new _sourcesContents map if the property is null.
    if (!this._sourcesContents) {
      this._sourcesContents = Object.create(null);
    }

    this._sourcesContents[util.toSetString(source)] = aSourceContent;
  } else if (this._sourcesContents) {
    // Remove the source file from the _sourcesContents map.
    // If the _sourcesContents map is empty, set the property to null.
    delete this._sourcesContents[util.toSetString(source)];

    if (Object.keys(this._sourcesContents).length === 0) {
      this._sourcesContents = null;
    }
  }
};
/**
 * Applies the mappings of a sub-source-map for a specific source file to the
 * source map being generated. Each mapping to the supplied source file is
 * rewritten using the supplied source map. Note: The resolution for the
 * resulting mappings is the minimium of this map and the supplied map.
 *
 * @param aSourceMapConsumer The source map to be applied.
 * @param aSourceFile Optional. The filename of the source file.
 *        If omitted, SourceMapConsumer's file property will be used.
 * @param aSourceMapPath Optional. The dirname of the path to the source map
 *        to be applied. If relative, it is relative to the SourceMapConsumer.
 *        This parameter is needed when the two source maps aren't in the same
 *        directory, and the source map to be applied contains relative source
 *        paths. If so, those relative source paths need to be rewritten
 *        relative to the SourceMapGenerator.
 */


SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
  var sourceFile = aSourceFile; // If aSourceFile is omitted, we will use the file property of the SourceMap

  if (aSourceFile == null) {
    if (aSourceMapConsumer.file == null) {
      throw new Error('SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' + 'or the source map\'s "file" property. Both were omitted.');
    }

    sourceFile = aSourceMapConsumer.file;
  }

  var sourceRoot = this._sourceRoot; // Make "sourceFile" relative if an absolute Url is passed.

  if (sourceRoot != null) {
    sourceFile = util.relative(sourceRoot, sourceFile);
  } // Applying the SourceMap can add and remove items from the sources and
  // the names array.


  var newSources = new ArraySet();
  var newNames = new ArraySet(); // Find mappings for the "sourceFile"

  this._mappings.unsortedForEach(function (mapping) {
    if (mapping.source === sourceFile && mapping.originalLine != null) {
      // Check if it can be mapped by the source map, then update the mapping.
      var original = aSourceMapConsumer.originalPositionFor({
        line: mapping.originalLine,
        column: mapping.originalColumn
      });

      if (original.source != null) {
        // Copy mapping
        mapping.source = original.source;

        if (aSourceMapPath != null) {
          mapping.source = util.join(aSourceMapPath, mapping.source);
        }

        if (sourceRoot != null) {
          mapping.source = util.relative(sourceRoot, mapping.source);
        }

        mapping.originalLine = original.line;
        mapping.originalColumn = original.column;

        if (original.name != null) {
          mapping.name = original.name;
        }
      }
    }

    var source = mapping.source;

    if (source != null && !newSources.has(source)) {
      newSources.add(source);
    }

    var name = mapping.name;

    if (name != null && !newNames.has(name)) {
      newNames.add(name);
    }
  }, this);

  this._sources = newSources;
  this._names = newNames; // Copy sourcesContents of applied map.

  aSourceMapConsumer.sources.forEach(function (sourceFile) {
    var content = aSourceMapConsumer.sourceContentFor(sourceFile);

    if (content != null) {
      if (aSourceMapPath != null) {
        sourceFile = util.join(aSourceMapPath, sourceFile);
      }

      if (sourceRoot != null) {
        sourceFile = util.relative(sourceRoot, sourceFile);
      }

      this.setSourceContent(sourceFile, content);
    }
  }, this);
};
/**
 * A mapping can have one of the three levels of data:
 *
 *   1. Just the generated position.
 *   2. The Generated position, original position, and original source.
 *   3. Generated and original position, original source, as well as a name
 *      token.
 *
 * To maintain consistency, we validate that any new mapping being added falls
 * in to one of these categories.
 */


SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
  // When aOriginal is truthy but has empty values for .line and .column,
  // it is most likely a programmer error. In this case we throw a very
  // specific error message to try to guide them the right way.
  // For example: https://github.com/Polymer/polymer-bundler/pull/519
  if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
    throw new Error('original.line and original.column are not numbers -- you probably meant to omit ' + 'the original mapping entirely and only map the generated position. If so, pass ' + 'null for the original mapping instead of an object with empty or null values.');
  }

  if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
    // Case 1.
    return;
  } else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aOriginal && 'line' in aOriginal && 'column' in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
    // Cases 2 and 3.
    return;
  } else {
    throw new Error('Invalid mapping: ' + JSON.stringify({
      generated: aGenerated,
      source: aSource,
      original: aOriginal,
      name: aName
    }));
  }
};
/**
 * Serialize the accumulated mappings in to the stream of base 64 VLQs
 * specified by the source map format.
 */


SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
  var previousGeneratedColumn = 0;
  var previousGeneratedLine = 1;
  var previousOriginalColumn = 0;
  var previousOriginalLine = 0;
  var previousName = 0;
  var previousSource = 0;
  var result = '';
  var next;
  var mapping;
  var nameIdx;
  var sourceIdx;

  var mappings = this._mappings.toArray();

  for (var i = 0, len = mappings.length; i < len; i++) {
    mapping = mappings[i];
    next = '';

    if (mapping.generatedLine !== previousGeneratedLine) {
      previousGeneratedColumn = 0;

      while (mapping.generatedLine !== previousGeneratedLine) {
        next += ';';
        previousGeneratedLine++;
      }
    } else {
      if (i > 0) {
        if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
          continue;
        }

        next += ',';
      }
    }

    next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
    previousGeneratedColumn = mapping.generatedColumn;

    if (mapping.source != null) {
      sourceIdx = this._sources.indexOf(mapping.source);
      next += base64VLQ.encode(sourceIdx - previousSource);
      previousSource = sourceIdx; // lines are stored 0-based in SourceMap spec version 3

      next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
      previousOriginalLine = mapping.originalLine - 1;
      next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
      previousOriginalColumn = mapping.originalColumn;

      if (mapping.name != null) {
        nameIdx = this._names.indexOf(mapping.name);
        next += base64VLQ.encode(nameIdx - previousName);
        previousName = nameIdx;
      }
    }

    result += next;
  }

  return result;
};

SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
  return aSources.map(function (source) {
    if (!this._sourcesContents) {
      return null;
    }

    if (aSourceRoot != null) {
      source = util.relative(aSourceRoot, source);
    }

    var key = util.toSetString(source);
    return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
  }, this);
};
/**
 * Externalize the source map.
 */


SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
  var map = {
    version: this._version,
    sources: this._sources.toArray(),
    names: this._names.toArray(),
    mappings: this._serializeMappings()
  };

  if (this._file != null) {
    map.file = this._file;
  }

  if (this._sourceRoot != null) {
    map.sourceRoot = this._sourceRoot;
  }

  if (this._sourcesContents) {
    map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
  }

  return map;
};
/**
 * Render the source map being generated to a string.
 */


SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
  return JSON.stringify(this.toJSON());
};

exports.SourceMapGenerator = SourceMapGenerator;
},{"./base64-vlq":"cU6c","./util":"BhAh","./array-set":"MUWy","./mapping-list":"LNU8"}],"XvAR":[function(require,module,exports) {
/* -*- Mode: js; js-indent-level: 2; -*- */

/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
exports.GREATEST_LOWER_BOUND = 1;
exports.LEAST_UPPER_BOUND = 2;
/**
 * Recursive implementation of binary search.
 *
 * @param aLow Indices here and lower do not contain the needle.
 * @param aHigh Indices here and higher do not contain the needle.
 * @param aNeedle The element being searched for.
 * @param aHaystack The non-empty array being searched.
 * @param aCompare Function which takes two elements and returns -1, 0, or 1.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 */

function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
  // This function terminates when one of the following is true:
  //
  //   1. We find the exact element we are looking for.
  //
  //   2. We did not find the exact element, but we can return the index of
  //      the next-closest element.
  //
  //   3. We did not find the exact element, and there is no next-closest
  //      element than the one we are searching for, so we return -1.
  var mid = Math.floor((aHigh - aLow) / 2) + aLow;
  var cmp = aCompare(aNeedle, aHaystack[mid], true);

  if (cmp === 0) {
    // Found the element we are looking for.
    return mid;
  } else if (cmp > 0) {
    // Our needle is greater than aHaystack[mid].
    if (aHigh - mid > 1) {
      // The element is in the upper half.
      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
    } // The exact needle element was not found in this haystack. Determine if
    // we are in termination case (3) or (2) and return the appropriate thing.


    if (aBias == exports.LEAST_UPPER_BOUND) {
      return aHigh < aHaystack.length ? aHigh : -1;
    } else {
      return mid;
    }
  } else {
    // Our needle is less than aHaystack[mid].
    if (mid - aLow > 1) {
      // The element is in the lower half.
      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
    } // we are in termination case (3) or (2) and return the appropriate thing.


    if (aBias == exports.LEAST_UPPER_BOUND) {
      return mid;
    } else {
      return aLow < 0 ? -1 : aLow;
    }
  }
}
/**
 * This is an implementation of binary search which will always try and return
 * the index of the closest element if there is no exact hit. This is because
 * mappings between original and generated line/col pairs are single points,
 * and there is an implicit region between each of them, so a miss just means
 * that you aren't on the very start of a region.
 *
 * @param aNeedle The element you are looking for.
 * @param aHaystack The array that is being searched.
 * @param aCompare A function which takes the needle and an element in the
 *     array and returns -1, 0, or 1 depending on whether the needle is less
 *     than, equal to, or greater than the element, respectively.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
 */


exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
  if (aHaystack.length === 0) {
    return -1;
  }

  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports.GREATEST_LOWER_BOUND);

  if (index < 0) {
    return -1;
  } // We have found either the exact element, or the next-closest element than
  // the one we are searching for. However, there may be more than one such
  // element. Make sure we always return the smallest of these.


  while (index - 1 >= 0) {
    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
      break;
    }

    --index;
  }

  return index;
};
},{}],"fNKZ":[function(require,module,exports) {
/* -*- Mode: js; js-indent-level: 2; -*- */

/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
// It turns out that some (most?) JavaScript engines don't self-host
// `Array.prototype.sort`. This makes sense because C++ will likely remain
// faster than JS when doing raw CPU-intensive sorting. However, when using a
// custom comparator function, calling back and forth between the VM's C++ and
// JIT'd JS is rather slow *and* loses JIT type information, resulting in
// worse generated code for the comparator function than would be optimal. In
// fact, when sorting with a comparator, these costs outweigh the benefits of
// sorting in C++. By using our own JS-implemented Quick Sort (below), we get
// a ~3500ms mean speed-up in `bench/bench.html`.

/**
 * Swap the elements indexed by `x` and `y` in the array `ary`.
 *
 * @param {Array} ary
 *        The array.
 * @param {Number} x
 *        The index of the first item.
 * @param {Number} y
 *        The index of the second item.
 */
function swap(ary, x, y) {
  var temp = ary[x];
  ary[x] = ary[y];
  ary[y] = temp;
}
/**
 * Returns a random integer within the range `low .. high` inclusive.
 *
 * @param {Number} low
 *        The lower bound on the range.
 * @param {Number} high
 *        The upper bound on the range.
 */


function randomIntInRange(low, high) {
  return Math.round(low + Math.random() * (high - low));
}
/**
 * The Quick Sort algorithm.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 * @param {Number} p
 *        Start index of the array
 * @param {Number} r
 *        End index of the array
 */


function doQuickSort(ary, comparator, p, r) {
  // If our lower bound is less than our upper bound, we (1) partition the
  // array into two pieces and (2) recurse on each half. If it is not, this is
  // the empty array and our base case.
  if (p < r) {
    // (1) Partitioning.
    //
    // The partitioning chooses a pivot between `p` and `r` and moves all
    // elements that are less than or equal to the pivot to the before it, and
    // all the elements that are greater than it after it. The effect is that
    // once partition is done, the pivot is in the exact place it will be when
    // the array is put in sorted order, and it will not need to be moved
    // again. This runs in O(n) time.
    // Always choose a random pivot so that an input array which is reverse
    // sorted does not cause O(n^2) running time.
    var pivotIndex = randomIntInRange(p, r);
    var i = p - 1;
    swap(ary, pivotIndex, r);
    var pivot = ary[r]; // Immediately after `j` is incremented in this loop, the following hold
    // true:
    //
    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
    //
    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.

    for (var j = p; j < r; j++) {
      if (comparator(ary[j], pivot) <= 0) {
        i += 1;
        swap(ary, i, j);
      }
    }

    swap(ary, i + 1, j);
    var q = i + 1; // (2) Recurse on each half.

    doQuickSort(ary, comparator, p, q - 1);
    doQuickSort(ary, comparator, q + 1, r);
  }
}
/**
 * Sort the given array in-place with the given comparator function.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 */


exports.quickSort = function (ary, comparator) {
  doQuickSort(ary, comparator, 0, ary.length - 1);
};
},{}],"cBLU":[function(require,module,exports) {
/* -*- Mode: js; js-indent-level: 2; -*- */

/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
var util = require('./util');

var binarySearch = require('./binary-search');

var ArraySet = require('./array-set').ArraySet;

var base64VLQ = require('./base64-vlq');

var quickSort = require('./quick-sort').quickSort;

function SourceMapConsumer(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;

  if (typeof aSourceMap === 'string') {
    sourceMap = util.parseSourceMapInput(aSourceMap);
  }

  return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
}

SourceMapConsumer.fromSourceMap = function (aSourceMap, aSourceMapURL) {
  return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
};
/**
 * The version of the source mapping spec that we are consuming.
 */


SourceMapConsumer.prototype._version = 3; // `__generatedMappings` and `__originalMappings` are arrays that hold the
// parsed mapping coordinates from the source map's "mappings" attribute. They
// are lazily instantiated, accessed via the `_generatedMappings` and
// `_originalMappings` getters respectively, and we only parse the mappings
// and create these arrays once queried for a source location. We jump through
// these hoops because there can be many thousands of mappings, and parsing
// them is expensive, so we only want to do it if we must.
//
// Each object in the arrays is of the form:
//
//     {
//       generatedLine: The line number in the generated code,
//       generatedColumn: The column number in the generated code,
//       source: The path to the original source file that generated this
//               chunk of code,
//       originalLine: The line number in the original source that
//                     corresponds to this chunk of generated code,
//       originalColumn: The column number in the original source that
//                       corresponds to this chunk of generated code,
//       name: The name of the original symbol which generated this chunk of
//             code.
//     }
//
// All properties except for `generatedLine` and `generatedColumn` can be
// `null`.
//
// `_generatedMappings` is ordered by the generated positions.
//
// `_originalMappings` is ordered by the original positions.

SourceMapConsumer.prototype.__generatedMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
  configurable: true,
  enumerable: true,
  get: function () {
    if (!this.__generatedMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__generatedMappings;
  }
});
SourceMapConsumer.prototype.__originalMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
  configurable: true,
  enumerable: true,
  get: function () {
    if (!this.__originalMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__originalMappings;
  }
});

SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
  var c = aStr.charAt(index);
  return c === ";" || c === ",";
};
/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */


SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
  throw new Error("Subclasses must implement _parseMappings");
};

SourceMapConsumer.GENERATED_ORDER = 1;
SourceMapConsumer.ORIGINAL_ORDER = 2;
SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
SourceMapConsumer.LEAST_UPPER_BOUND = 2;
/**
 * Iterate over each mapping between an original source/line/column and a
 * generated line/column in this source map.
 *
 * @param Function aCallback
 *        The function that is called with each mapping.
 * @param Object aContext
 *        Optional. If specified, this object will be the value of `this` every
 *        time that `aCallback` is called.
 * @param aOrder
 *        Either `SourceMapConsumer.GENERATED_ORDER` or
 *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
 *        iterate over the mappings sorted by the generated file's line/column
 *        order or the original's source/line/column order, respectively. Defaults to
 *        `SourceMapConsumer.GENERATED_ORDER`.
 */

SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
  var context = aContext || null;
  var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
  var mappings;

  switch (order) {
    case SourceMapConsumer.GENERATED_ORDER:
      mappings = this._generatedMappings;
      break;

    case SourceMapConsumer.ORIGINAL_ORDER:
      mappings = this._originalMappings;
      break;

    default:
      throw new Error("Unknown order of iteration.");
  }

  var sourceRoot = this.sourceRoot;
  mappings.map(function (mapping) {
    var source = mapping.source === null ? null : this._sources.at(mapping.source);
    source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
    return {
      source: source,
      generatedLine: mapping.generatedLine,
      generatedColumn: mapping.generatedColumn,
      originalLine: mapping.originalLine,
      originalColumn: mapping.originalColumn,
      name: mapping.name === null ? null : this._names.at(mapping.name)
    };
  }, this).forEach(aCallback, context);
};
/**
 * Returns all generated line and column information for the original source,
 * line, and column provided. If no column is provided, returns all mappings
 * corresponding to a either the line we are searching for or the next
 * closest line that has any mappings. Otherwise, returns all mappings
 * corresponding to the given line and either the column we are searching for
 * or the next closest column that has any offsets.
 *
 * The only argument is an object with the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number is 1-based.
 *   - column: Optional. the column number in the original source.
 *    The column number is 0-based.
 *
 * and an array of objects is returned, each with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *    line number is 1-based.
 *   - column: The column number in the generated source, or null.
 *    The column number is 0-based.
 */


SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
  var line = util.getArg(aArgs, 'line'); // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
  // returns the index of the closest mapping less than the needle. By
  // setting needle.originalColumn to 0, we thus find the last mapping for
  // the given line, provided such a mapping exists.

  var needle = {
    source: util.getArg(aArgs, 'source'),
    originalLine: line,
    originalColumn: util.getArg(aArgs, 'column', 0)
  };
  needle.source = this._findSourceIndex(needle.source);

  if (needle.source < 0) {
    return [];
  }

  var mappings = [];

  var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, binarySearch.LEAST_UPPER_BOUND);

  if (index >= 0) {
    var mapping = this._originalMappings[index];

    if (aArgs.column === undefined) {
      var originalLine = mapping.originalLine; // Iterate until either we run out of mappings, or we run into
      // a mapping for a different line than the one we found. Since
      // mappings are sorted, this is guaranteed to find all mappings for
      // the line we found.

      while (mapping && mapping.originalLine === originalLine) {
        mappings.push({
          line: util.getArg(mapping, 'generatedLine', null),
          column: util.getArg(mapping, 'generatedColumn', null),
          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
        });
        mapping = this._originalMappings[++index];
      }
    } else {
      var originalColumn = mapping.originalColumn; // Iterate until either we run out of mappings, or we run into
      // a mapping for a different line than the one we were searching for.
      // Since mappings are sorted, this is guaranteed to find all mappings for
      // the line we are searching for.

      while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
        mappings.push({
          line: util.getArg(mapping, 'generatedLine', null),
          column: util.getArg(mapping, 'generatedColumn', null),
          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
        });
        mapping = this._originalMappings[++index];
      }
    }
  }

  return mappings;
};

exports.SourceMapConsumer = SourceMapConsumer;
/**
 * A BasicSourceMapConsumer instance represents a parsed source map which we can
 * query for information about the original file positions by giving it a file
 * position in the generated source.
 *
 * The first parameter is the raw source map (either as a JSON string, or
 * already parsed to an object). According to the spec, source maps have the
 * following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - sources: An array of URLs to the original source files.
 *   - names: An array of identifiers which can be referrenced by individual mappings.
 *   - sourceRoot: Optional. The URL root from which all sources are relative.
 *   - sourcesContent: Optional. An array of contents of the original source files.
 *   - mappings: A string of base64 VLQs which contain the actual mappings.
 *   - file: Optional. The generated file this source map is associated with.
 *
 * Here is an example source map, taken from the source map spec[0]:
 *
 *     {
 *       version : 3,
 *       file: "out.js",
 *       sourceRoot : "",
 *       sources: ["foo.js", "bar.js"],
 *       names: ["src", "maps", "are", "fun"],
 *       mappings: "AA,AB;;ABCDE;"
 *     }
 *
 * The second parameter, if given, is a string whose value is the URL
 * at which the source map was found.  This URL is used to compute the
 * sources array.
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
 */

function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;

  if (typeof aSourceMap === 'string') {
    sourceMap = util.parseSourceMapInput(aSourceMap);
  }

  var version = util.getArg(sourceMap, 'version');
  var sources = util.getArg(sourceMap, 'sources'); // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
  // requires the array) to play nice here.

  var names = util.getArg(sourceMap, 'names', []);
  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
  var mappings = util.getArg(sourceMap, 'mappings');
  var file = util.getArg(sourceMap, 'file', null); // Once again, Sass deviates from the spec and supplies the version as a
  // string rather than a number, so we use loose equality checking here.

  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }

  if (sourceRoot) {
    sourceRoot = util.normalize(sourceRoot);
  }

  sources = sources.map(String) // Some source maps produce relative source paths like "./foo.js" instead of
  // "foo.js".  Normalize these first so that future comparisons will succeed.
  // See bugzil.la/1090768.
  .map(util.normalize) // Always ensure that absolute sources are internally stored relative to
  // the source root, if the source root is absolute. Not doing this would
  // be particularly problematic when the source root is a prefix of the
  // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
  .map(function (source) {
    return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;
  }); // Pass `true` below to allow duplicate names and sources. While source maps
  // are intended to be compressed and deduplicated, the TypeScript compiler
  // sometimes generates source maps with duplicates in them. See Github issue
  // #72 and bugzil.la/889492.

  this._names = ArraySet.fromArray(names.map(String), true);
  this._sources = ArraySet.fromArray(sources, true);
  this._absoluteSources = this._sources.toArray().map(function (s) {
    return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
  });
  this.sourceRoot = sourceRoot;
  this.sourcesContent = sourcesContent;
  this._mappings = mappings;
  this._sourceMapURL = aSourceMapURL;
  this.file = file;
}

BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
/**
 * Utility function to find the index of a source.  Returns -1 if not
 * found.
 */

BasicSourceMapConsumer.prototype._findSourceIndex = function (aSource) {
  var relativeSource = aSource;

  if (this.sourceRoot != null) {
    relativeSource = util.relative(this.sourceRoot, relativeSource);
  }

  if (this._sources.has(relativeSource)) {
    return this._sources.indexOf(relativeSource);
  } // Maybe aSource is an absolute URL as returned by |sources|.  In
  // this case we can't simply undo the transform.


  var i;

  for (i = 0; i < this._absoluteSources.length; ++i) {
    if (this._absoluteSources[i] == aSource) {
      return i;
    }
  }

  return -1;
};
/**
 * Create a BasicSourceMapConsumer from a SourceMapGenerator.
 *
 * @param SourceMapGenerator aSourceMap
 *        The source map that will be consumed.
 * @param String aSourceMapURL
 *        The URL at which the source map can be found (optional)
 * @returns BasicSourceMapConsumer
 */


BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
  var smc = Object.create(BasicSourceMapConsumer.prototype);
  var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
  var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
  smc.sourceRoot = aSourceMap._sourceRoot;
  smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);
  smc.file = aSourceMap._file;
  smc._sourceMapURL = aSourceMapURL;
  smc._absoluteSources = smc._sources.toArray().map(function (s) {
    return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
  }); // Because we are modifying the entries (by converting string sources and
  // names to indices into the sources and names ArraySets), we have to make
  // a copy of the entry or else bad things happen. Shared mutable state
  // strikes again! See github issue #191.

  var generatedMappings = aSourceMap._mappings.toArray().slice();

  var destGeneratedMappings = smc.__generatedMappings = [];
  var destOriginalMappings = smc.__originalMappings = [];

  for (var i = 0, length = generatedMappings.length; i < length; i++) {
    var srcMapping = generatedMappings[i];
    var destMapping = new Mapping();
    destMapping.generatedLine = srcMapping.generatedLine;
    destMapping.generatedColumn = srcMapping.generatedColumn;

    if (srcMapping.source) {
      destMapping.source = sources.indexOf(srcMapping.source);
      destMapping.originalLine = srcMapping.originalLine;
      destMapping.originalColumn = srcMapping.originalColumn;

      if (srcMapping.name) {
        destMapping.name = names.indexOf(srcMapping.name);
      }

      destOriginalMappings.push(destMapping);
    }

    destGeneratedMappings.push(destMapping);
  }

  quickSort(smc.__originalMappings, util.compareByOriginalPositions);
  return smc;
};
/**
 * The version of the source mapping spec that we are consuming.
 */


BasicSourceMapConsumer.prototype._version = 3;
/**
 * The list of original sources.
 */

Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
  get: function () {
    return this._absoluteSources.slice();
  }
});
/**
 * Provide the JIT with a nice shape / hidden class.
 */

function Mapping() {
  this.generatedLine = 0;
  this.generatedColumn = 0;
  this.source = null;
  this.originalLine = null;
  this.originalColumn = null;
  this.name = null;
}
/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */


BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
  var generatedLine = 1;
  var previousGeneratedColumn = 0;
  var previousOriginalLine = 0;
  var previousOriginalColumn = 0;
  var previousSource = 0;
  var previousName = 0;
  var length = aStr.length;
  var index = 0;
  var cachedSegments = {};
  var temp = {};
  var originalMappings = [];
  var generatedMappings = [];
  var mapping, str, segment, end, value;

  while (index < length) {
    if (aStr.charAt(index) === ';') {
      generatedLine++;
      index++;
      previousGeneratedColumn = 0;
    } else if (aStr.charAt(index) === ',') {
      index++;
    } else {
      mapping = new Mapping();
      mapping.generatedLine = generatedLine; // Because each offset is encoded relative to the previous one,
      // many segments often have the same encoding. We can exploit this
      // fact by caching the parsed variable length fields of each segment,
      // allowing us to avoid a second parse if we encounter the same
      // segment again.

      for (end = index; end < length; end++) {
        if (this._charIsMappingSeparator(aStr, end)) {
          break;
        }
      }

      str = aStr.slice(index, end);
      segment = cachedSegments[str];

      if (segment) {
        index += str.length;
      } else {
        segment = [];

        while (index < end) {
          base64VLQ.decode(aStr, index, temp);
          value = temp.value;
          index = temp.rest;
          segment.push(value);
        }

        if (segment.length === 2) {
          throw new Error('Found a source, but no line and column');
        }

        if (segment.length === 3) {
          throw new Error('Found a source and line, but no column');
        }

        cachedSegments[str] = segment;
      } // Generated column.


      mapping.generatedColumn = previousGeneratedColumn + segment[0];
      previousGeneratedColumn = mapping.generatedColumn;

      if (segment.length > 1) {
        // Original source.
        mapping.source = previousSource + segment[1];
        previousSource += segment[1]; // Original line.

        mapping.originalLine = previousOriginalLine + segment[2];
        previousOriginalLine = mapping.originalLine; // Lines are stored 0-based

        mapping.originalLine += 1; // Original column.

        mapping.originalColumn = previousOriginalColumn + segment[3];
        previousOriginalColumn = mapping.originalColumn;

        if (segment.length > 4) {
          // Original name.
          mapping.name = previousName + segment[4];
          previousName += segment[4];
        }
      }

      generatedMappings.push(mapping);

      if (typeof mapping.originalLine === 'number') {
        originalMappings.push(mapping);
      }
    }
  }

  quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
  this.__generatedMappings = generatedMappings;
  quickSort(originalMappings, util.compareByOriginalPositions);
  this.__originalMappings = originalMappings;
};
/**
 * Find the mapping that best matches the hypothetical "needle" mapping that
 * we are searching for in the given "haystack" of mappings.
 */


BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
  // To return the position we are searching for, we must first find the
  // mapping for the given position and then return the opposite position it
  // points to. Because the mappings are sorted, we can use binary search to
  // find the best mapping.
  if (aNeedle[aLineName] <= 0) {
    throw new TypeError('Line must be greater than or equal to 1, got ' + aNeedle[aLineName]);
  }

  if (aNeedle[aColumnName] < 0) {
    throw new TypeError('Column must be greater than or equal to 0, got ' + aNeedle[aColumnName]);
  }

  return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
};
/**
 * Compute the last column for each generated mapping. The last column is
 * inclusive.
 */


BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
  for (var index = 0; index < this._generatedMappings.length; ++index) {
    var mapping = this._generatedMappings[index]; // Mappings do not contain a field for the last generated columnt. We
    // can come up with an optimistic estimate, however, by assuming that
    // mappings are contiguous (i.e. given two consecutive mappings, the
    // first mapping ends where the second one starts).

    if (index + 1 < this._generatedMappings.length) {
      var nextMapping = this._generatedMappings[index + 1];

      if (mapping.generatedLine === nextMapping.generatedLine) {
        mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
        continue;
      }
    } // The last mapping for each line spans the entire line.


    mapping.lastGeneratedColumn = Infinity;
  }
};
/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.  The line number
 *     is 1-based.
 *   - column: The column number in the generated source.  The column
 *     number is 0-based.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the original source, or null.  The
 *     column number is 0-based.
 *   - name: The original identifier, or null.
 */


BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
  var needle = {
    generatedLine: util.getArg(aArgs, 'line'),
    generatedColumn: util.getArg(aArgs, 'column')
  };

  var index = this._findMapping(needle, this._generatedMappings, "generatedLine", "generatedColumn", util.compareByGeneratedPositionsDeflated, util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND));

  if (index >= 0) {
    var mapping = this._generatedMappings[index];

    if (mapping.generatedLine === needle.generatedLine) {
      var source = util.getArg(mapping, 'source', null);

      if (source !== null) {
        source = this._sources.at(source);
        source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
      }

      var name = util.getArg(mapping, 'name', null);

      if (name !== null) {
        name = this._names.at(name);
      }

      return {
        source: source,
        line: util.getArg(mapping, 'originalLine', null),
        column: util.getArg(mapping, 'originalColumn', null),
        name: name
      };
    }
  }

  return {
    source: null,
    line: null,
    column: null,
    name: null
  };
};
/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */


BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
  if (!this.sourcesContent) {
    return false;
  }

  return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function (sc) {
    return sc == null;
  });
};
/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */


BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
  if (!this.sourcesContent) {
    return null;
  }

  var index = this._findSourceIndex(aSource);

  if (index >= 0) {
    return this.sourcesContent[index];
  }

  var relativeSource = aSource;

  if (this.sourceRoot != null) {
    relativeSource = util.relative(this.sourceRoot, relativeSource);
  }

  var url;

  if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {
    // XXX: file:// URIs and absolute paths lead to unexpected behavior for
    // many users. We can help them out when they expect file:// URIs to
    // behave like it would if they were running a local HTTP server. See
    // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
    var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");

    if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
      return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
    }

    if ((!url.path || url.path == "/") && this._sources.has("/" + relativeSource)) {
      return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
    }
  } // This function is used recursively from
  // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
  // don't want to throw if we can't find the source - we just want to
  // return null, so we provide a flag to exit gracefully.


  if (nullOnMissing) {
    return null;
  } else {
    throw new Error('"' + relativeSource + '" is not in the SourceMap.');
  }
};
/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number
 *     is 1-based.
 *   - column: The column number in the original source.  The column
 *     number is 0-based.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the generated source, or null.
 *     The column number is 0-based.
 */


BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
  var source = util.getArg(aArgs, 'source');
  source = this._findSourceIndex(source);

  if (source < 0) {
    return {
      line: null,
      column: null,
      lastColumn: null
    };
  }

  var needle = {
    source: source,
    originalLine: util.getArg(aArgs, 'line'),
    originalColumn: util.getArg(aArgs, 'column')
  };

  var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND));

  if (index >= 0) {
    var mapping = this._originalMappings[index];

    if (mapping.source === needle.source) {
      return {
        line: util.getArg(mapping, 'generatedLine', null),
        column: util.getArg(mapping, 'generatedColumn', null),
        lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
      };
    }
  }

  return {
    line: null,
    column: null,
    lastColumn: null
  };
};

exports.BasicSourceMapConsumer = BasicSourceMapConsumer;
/**
 * An IndexedSourceMapConsumer instance represents a parsed source map which
 * we can query for information. It differs from BasicSourceMapConsumer in
 * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
 * input.
 *
 * The first parameter is a raw source map (either as a JSON string, or already
 * parsed to an object). According to the spec for indexed source maps, they
 * have the following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - file: Optional. The generated file this source map is associated with.
 *   - sections: A list of section definitions.
 *
 * Each value under the "sections" field has two fields:
 *   - offset: The offset into the original specified at which this section
 *       begins to apply, defined as an object with a "line" and "column"
 *       field.
 *   - map: A source map definition. This source map could also be indexed,
 *       but doesn't have to be.
 *
 * Instead of the "map" field, it's also possible to have a "url" field
 * specifying a URL to retrieve a source map from, but that's currently
 * unsupported.
 *
 * Here's an example source map, taken from the source map spec[0], but
 * modified to omit a section which uses the "url" field.
 *
 *  {
 *    version : 3,
 *    file: "app.js",
 *    sections: [{
 *      offset: {line:100, column:10},
 *      map: {
 *        version : 3,
 *        file: "section.js",
 *        sources: ["foo.js", "bar.js"],
 *        names: ["src", "maps", "are", "fun"],
 *        mappings: "AAAA,E;;ABCDE;"
 *      }
 *    }],
 *  }
 *
 * The second parameter, if given, is a string whose value is the URL
 * at which the source map was found.  This URL is used to compute the
 * sources array.
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
 */

function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;

  if (typeof aSourceMap === 'string') {
    sourceMap = util.parseSourceMapInput(aSourceMap);
  }

  var version = util.getArg(sourceMap, 'version');
  var sections = util.getArg(sourceMap, 'sections');

  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }

  this._sources = new ArraySet();
  this._names = new ArraySet();
  var lastOffset = {
    line: -1,
    column: 0
  };
  this._sections = sections.map(function (s) {
    if (s.url) {
      // The url field will require support for asynchronicity.
      // See https://github.com/mozilla/source-map/issues/16
      throw new Error('Support for url field in sections not implemented.');
    }

    var offset = util.getArg(s, 'offset');
    var offsetLine = util.getArg(offset, 'line');
    var offsetColumn = util.getArg(offset, 'column');

    if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
      throw new Error('Section offsets must be ordered and non-overlapping.');
    }

    lastOffset = offset;
    return {
      generatedOffset: {
        // The offset fields are 0-based, but we use 1-based indices when
        // encoding/decoding from VLQ.
        generatedLine: offsetLine + 1,
        generatedColumn: offsetColumn + 1
      },
      consumer: new SourceMapConsumer(util.getArg(s, 'map'), aSourceMapURL)
    };
  });
}

IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
/**
 * The version of the source mapping spec that we are consuming.
 */

IndexedSourceMapConsumer.prototype._version = 3;
/**
 * The list of original sources.
 */

Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
  get: function () {
    var sources = [];

    for (var i = 0; i < this._sections.length; i++) {
      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
        sources.push(this._sections[i].consumer.sources[j]);
      }
    }

    return sources;
  }
});
/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.  The line number
 *     is 1-based.
 *   - column: The column number in the generated source.  The column
 *     number is 0-based.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the original source, or null.  The
 *     column number is 0-based.
 *   - name: The original identifier, or null.
 */

IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
  var needle = {
    generatedLine: util.getArg(aArgs, 'line'),
    generatedColumn: util.getArg(aArgs, 'column')
  }; // Find the section containing the generated position we're trying to map
  // to an original position.

  var sectionIndex = binarySearch.search(needle, this._sections, function (needle, section) {
    var cmp = needle.generatedLine - section.generatedOffset.generatedLine;

    if (cmp) {
      return cmp;
    }

    return needle.generatedColumn - section.generatedOffset.generatedColumn;
  });
  var section = this._sections[sectionIndex];

  if (!section) {
    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  }

  return section.consumer.originalPositionFor({
    line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
    column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
    bias: aArgs.bias
  });
};
/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */


IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
  return this._sections.every(function (s) {
    return s.consumer.hasContentsOfAllSources();
  });
};
/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */


IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
  for (var i = 0; i < this._sections.length; i++) {
    var section = this._sections[i];
    var content = section.consumer.sourceContentFor(aSource, true);

    if (content) {
      return content;
    }
  }

  if (nullOnMissing) {
    return null;
  } else {
    throw new Error('"' + aSource + '" is not in the SourceMap.');
  }
};
/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number
 *     is 1-based.
 *   - column: The column number in the original source.  The column
 *     number is 0-based.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *     line number is 1-based. 
 *   - column: The column number in the generated source, or null.
 *     The column number is 0-based.
 */


IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
  for (var i = 0; i < this._sections.length; i++) {
    var section = this._sections[i]; // Only consider this section if the requested source is in the list of
    // sources of the consumer.

    if (section.consumer._findSourceIndex(util.getArg(aArgs, 'source')) === -1) {
      continue;
    }

    var generatedPosition = section.consumer.generatedPositionFor(aArgs);

    if (generatedPosition) {
      var ret = {
        line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
        column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
      };
      return ret;
    }
  }

  return {
    line: null,
    column: null
  };
};
/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */


IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
  this.__generatedMappings = [];
  this.__originalMappings = [];

  for (var i = 0; i < this._sections.length; i++) {
    var section = this._sections[i];
    var sectionMappings = section.consumer._generatedMappings;

    for (var j = 0; j < sectionMappings.length; j++) {
      var mapping = sectionMappings[j];

      var source = section.consumer._sources.at(mapping.source);

      source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);

      this._sources.add(source);

      source = this._sources.indexOf(source);
      var name = null;

      if (mapping.name) {
        name = section.consumer._names.at(mapping.name);

        this._names.add(name);

        name = this._names.indexOf(name);
      } // The mappings coming from the consumer for the section have
      // generated positions relative to the start of the section, so we
      // need to offset them to be relative to the start of the concatenated
      // generated file.


      var adjustedMapping = {
        source: source,
        generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
        generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
        originalLine: mapping.originalLine,
        originalColumn: mapping.originalColumn,
        name: name
      };

      this.__generatedMappings.push(adjustedMapping);

      if (typeof adjustedMapping.originalLine === 'number') {
        this.__originalMappings.push(adjustedMapping);
      }
    }
  }

  quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
  quickSort(this.__originalMappings, util.compareByOriginalPositions);
};

exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
},{"./util":"BhAh","./binary-search":"XvAR","./array-set":"MUWy","./base64-vlq":"cU6c","./quick-sort":"fNKZ"}],"ICOl":[function(require,module,exports) {
/* -*- Mode: js; js-indent-level: 2; -*- */

/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
var SourceMapGenerator = require('./source-map-generator').SourceMapGenerator;

var util = require('./util'); // Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
// operating systems these days (capturing the result).


var REGEX_NEWLINE = /(\r?\n)/; // Newline character code for charCodeAt() comparisons

var NEWLINE_CODE = 10; // Private symbol for identifying `SourceNode`s when multiple versions of
// the source-map library are loaded. This MUST NOT CHANGE across
// versions!

var isSourceNode = "$$$isSourceNode$$$";
/**
 * SourceNodes provide a way to abstract over interpolating/concatenating
 * snippets of generated JavaScript source code while maintaining the line and
 * column information associated with the original source code.
 *
 * @param aLine The original line number.
 * @param aColumn The original column number.
 * @param aSource The original source's filename.
 * @param aChunks Optional. An array of strings which are snippets of
 *        generated JS, or other SourceNodes.
 * @param aName The original identifier.
 */

function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
  this.children = [];
  this.sourceContents = {};
  this.line = aLine == null ? null : aLine;
  this.column = aColumn == null ? null : aColumn;
  this.source = aSource == null ? null : aSource;
  this.name = aName == null ? null : aName;
  this[isSourceNode] = true;
  if (aChunks != null) this.add(aChunks);
}
/**
 * Creates a SourceNode from generated code and a SourceMapConsumer.
 *
 * @param aGeneratedCode The generated code
 * @param aSourceMapConsumer The SourceMap for the generated code
 * @param aRelativePath Optional. The path that relative sources in the
 *        SourceMapConsumer should be relative to.
 */


SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
  // The SourceNode we want to fill with the generated code
  // and the SourceMap
  var node = new SourceNode(); // All even indices of this array are one line of the generated code,
  // while all odd indices are the newlines between two adjacent lines
  // (since `REGEX_NEWLINE` captures its match).
  // Processed fragments are accessed by calling `shiftNextLine`.

  var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
  var remainingLinesIndex = 0;

  var shiftNextLine = function () {
    var lineContents = getNextLine(); // The last line of a file might not have a newline.

    var newLine = getNextLine() || "";
    return lineContents + newLine;

    function getNextLine() {
      return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : undefined;
    }
  }; // We need to remember the position of "remainingLines"


  var lastGeneratedLine = 1,
      lastGeneratedColumn = 0; // The generate SourceNodes we need a code range.
  // To extract it current and last mapping is used.
  // Here we store the last mapping.

  var lastMapping = null;
  aSourceMapConsumer.eachMapping(function (mapping) {
    if (lastMapping !== null) {
      // We add the code from "lastMapping" to "mapping":
      // First check if there is a new line in between.
      if (lastGeneratedLine < mapping.generatedLine) {
        // Associate first line with "lastMapping"
        addMappingWithCode(lastMapping, shiftNextLine());
        lastGeneratedLine++;
        lastGeneratedColumn = 0; // The remaining code is added without mapping
      } else {
        // There is no new line in between.
        // Associate the code between "lastGeneratedColumn" and
        // "mapping.generatedColumn" with "lastMapping"
        var nextLine = remainingLines[remainingLinesIndex] || '';
        var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
        lastGeneratedColumn = mapping.generatedColumn;
        addMappingWithCode(lastMapping, code); // No more remaining code, continue

        lastMapping = mapping;
        return;
      }
    } // We add the generated code until the first mapping
    // to the SourceNode without any mapping.
    // Each line is added as separate string.


    while (lastGeneratedLine < mapping.generatedLine) {
      node.add(shiftNextLine());
      lastGeneratedLine++;
    }

    if (lastGeneratedColumn < mapping.generatedColumn) {
      var nextLine = remainingLines[remainingLinesIndex] || '';
      node.add(nextLine.substr(0, mapping.generatedColumn));
      remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
      lastGeneratedColumn = mapping.generatedColumn;
    }

    lastMapping = mapping;
  }, this); // We have processed all mappings.

  if (remainingLinesIndex < remainingLines.length) {
    if (lastMapping) {
      // Associate the remaining code in the current line with "lastMapping"
      addMappingWithCode(lastMapping, shiftNextLine());
    } // and add the remaining lines without any mapping


    node.add(remainingLines.splice(remainingLinesIndex).join(""));
  } // Copy sourcesContent into SourceNode


  aSourceMapConsumer.sources.forEach(function (sourceFile) {
    var content = aSourceMapConsumer.sourceContentFor(sourceFile);

    if (content != null) {
      if (aRelativePath != null) {
        sourceFile = util.join(aRelativePath, sourceFile);
      }

      node.setSourceContent(sourceFile, content);
    }
  });
  return node;

  function addMappingWithCode(mapping, code) {
    if (mapping === null || mapping.source === undefined) {
      node.add(code);
    } else {
      var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
      node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));
    }
  }
};
/**
 * Add a chunk of generated JS to this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */


SourceNode.prototype.add = function SourceNode_add(aChunk) {
  if (Array.isArray(aChunk)) {
    aChunk.forEach(function (chunk) {
      this.add(chunk);
    }, this);
  } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
    if (aChunk) {
      this.children.push(aChunk);
    }
  } else {
    throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
  }

  return this;
};
/**
 * Add a chunk of generated JS to the beginning of this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */


SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
  if (Array.isArray(aChunk)) {
    for (var i = aChunk.length - 1; i >= 0; i--) {
      this.prepend(aChunk[i]);
    }
  } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
    this.children.unshift(aChunk);
  } else {
    throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
  }

  return this;
};
/**
 * Walk over the tree of JS snippets in this node and its children. The
 * walking function is called once for each snippet of JS and is passed that
 * snippet and the its original associated source's line/column location.
 *
 * @param aFn The traversal function.
 */


SourceNode.prototype.walk = function SourceNode_walk(aFn) {
  var chunk;

  for (var i = 0, len = this.children.length; i < len; i++) {
    chunk = this.children[i];

    if (chunk[isSourceNode]) {
      chunk.walk(aFn);
    } else {
      if (chunk !== '') {
        aFn(chunk, {
          source: this.source,
          line: this.line,
          column: this.column,
          name: this.name
        });
      }
    }
  }
};
/**
 * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
 * each of `this.children`.
 *
 * @param aSep The separator.
 */


SourceNode.prototype.join = function SourceNode_join(aSep) {
  var newChildren;
  var i;
  var len = this.children.length;

  if (len > 0) {
    newChildren = [];

    for (i = 0; i < len - 1; i++) {
      newChildren.push(this.children[i]);
      newChildren.push(aSep);
    }

    newChildren.push(this.children[i]);
    this.children = newChildren;
  }

  return this;
};
/**
 * Call String.prototype.replace on the very right-most source snippet. Useful
 * for trimming whitespace from the end of a source node, etc.
 *
 * @param aPattern The pattern to replace.
 * @param aReplacement The thing to replace the pattern with.
 */


SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
  var lastChild = this.children[this.children.length - 1];

  if (lastChild[isSourceNode]) {
    lastChild.replaceRight(aPattern, aReplacement);
  } else if (typeof lastChild === 'string') {
    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
  } else {
    this.children.push(''.replace(aPattern, aReplacement));
  }

  return this;
};
/**
 * Set the source content for a source file. This will be added to the SourceMapGenerator
 * in the sourcesContent field.
 *
 * @param aSourceFile The filename of the source file
 * @param aSourceContent The content of the source file
 */


SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
  this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
};
/**
 * Walk over the tree of SourceNodes. The walking function is called for each
 * source file content and is passed the filename and source content.
 *
 * @param aFn The traversal function.
 */


SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
  for (var i = 0, len = this.children.length; i < len; i++) {
    if (this.children[i][isSourceNode]) {
      this.children[i].walkSourceContents(aFn);
    }
  }

  var sources = Object.keys(this.sourceContents);

  for (var i = 0, len = sources.length; i < len; i++) {
    aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
  }
};
/**
 * Return the string representation of this source node. Walks over the tree
 * and concatenates all the various snippets together to one string.
 */


SourceNode.prototype.toString = function SourceNode_toString() {
  var str = "";
  this.walk(function (chunk) {
    str += chunk;
  });
  return str;
};
/**
 * Returns the string representation of this source node along with a source
 * map.
 */


SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
  var generated = {
    code: "",
    line: 1,
    column: 0
  };
  var map = new SourceMapGenerator(aArgs);
  var sourceMappingActive = false;
  var lastOriginalSource = null;
  var lastOriginalLine = null;
  var lastOriginalColumn = null;
  var lastOriginalName = null;
  this.walk(function (chunk, original) {
    generated.code += chunk;

    if (original.source !== null && original.line !== null && original.column !== null) {
      if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
        map.addMapping({
          source: original.source,
          original: {
            line: original.line,
            column: original.column
          },
          generated: {
            line: generated.line,
            column: generated.column
          },
          name: original.name
        });
      }

      lastOriginalSource = original.source;
      lastOriginalLine = original.line;
      lastOriginalColumn = original.column;
      lastOriginalName = original.name;
      sourceMappingActive = true;
    } else if (sourceMappingActive) {
      map.addMapping({
        generated: {
          line: generated.line,
          column: generated.column
        }
      });
      lastOriginalSource = null;
      sourceMappingActive = false;
    }

    for (var idx = 0, length = chunk.length; idx < length; idx++) {
      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
        generated.line++;
        generated.column = 0; // Mappings end at eol

        if (idx + 1 === length) {
          lastOriginalSource = null;
          sourceMappingActive = false;
        } else if (sourceMappingActive) {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }
      } else {
        generated.column++;
      }
    }
  });
  this.walkSourceContents(function (sourceFile, sourceContent) {
    map.setSourceContent(sourceFile, sourceContent);
  });
  return {
    code: generated.code,
    map: map
  };
};

exports.SourceNode = SourceNode;
},{"./source-map-generator":"YuZZ","./util":"BhAh"}],"jJWO":[function(require,module,exports) {
/*
 * Copyright 2009-2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE.txt or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
exports.SourceMapGenerator = require('./lib/source-map-generator').SourceMapGenerator;
exports.SourceMapConsumer = require('./lib/source-map-consumer').SourceMapConsumer;
exports.SourceNode = require('./lib/source-node').SourceNode;
},{"./lib/source-map-generator":"YuZZ","./lib/source-map-consumer":"cBLU","./lib/source-node":"ICOl"}],"RyXu":[function(require,module,exports) {
module.exports = {
  "name": "escodegen",
  "description": "ECMAScript code generator",
  "homepage": "http://github.com/estools/escodegen",
  "main": "escodegen.js",
  "bin": {
    "esgenerate": "./bin/esgenerate.js",
    "escodegen": "./bin/escodegen.js"
  },
  "files": ["LICENSE.BSD", "README.md", "bin", "escodegen.js", "package.json"],
  "version": "2.0.0",
  "engines": {
    "node": ">=6.0"
  },
  "maintainers": [{
    "name": "Yusuke Suzuki",
    "email": "utatane.tea@gmail.com",
    "web": "http://github.com/Constellation"
  }],
  "repository": {
    "type": "git",
    "url": "http://github.com/estools/escodegen.git"
  },
  "dependencies": {
    "estraverse": "^5.2.0",
    "esutils": "^2.0.2",
    "esprima": "^4.0.1",
    "optionator": "^0.8.1"
  },
  "optionalDependencies": {
    "source-map": "~0.6.1"
  },
  "devDependencies": {
    "acorn": "^7.3.1",
    "bluebird": "^3.4.7",
    "bower-registry-client": "^1.0.0",
    "chai": "^4.2.0",
    "chai-exclude": "^2.0.2",
    "commonjs-everywhere": "^0.9.7",
    "gulp": "^3.8.10",
    "gulp-eslint": "^3.0.1",
    "gulp-mocha": "^3.0.1",
    "semver": "^5.1.0"
  },
  "license": "BSD-2-Clause",
  "scripts": {
    "test": "gulp travis",
    "unit-test": "gulp test",
    "lint": "gulp lint",
    "release": "node tools/release.js",
    "build-min": "./node_modules/.bin/cjsify -ma path: tools/entry-point.js > escodegen.browser.min.js",
    "build": "./node_modules/.bin/cjsify -a path: tools/entry-point.js > escodegen.browser.js"
  }
};
},{}],"vqOD":[function(require,module,exports) {
var global = arguments[3];
/*
  Copyright (C) 2012-2014 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2015 Ingvar Stepanyan <me@rreverser.com>
  Copyright (C) 2014 Ivan Nikulin <ifaaan@gmail.com>
  Copyright (C) 2012-2013 Michael Ficarra <escodegen.copyright@michael.ficarra.me>
  Copyright (C) 2012-2013 Mathias Bynens <mathias@qiwi.be>
  Copyright (C) 2013 Irakli Gozalishvili <rfobic@gmail.com>
  Copyright (C) 2012 Robert Gust-Bardon <donate@robert.gust-bardon.org>
  Copyright (C) 2012 John Freeman <jfreeman08@gmail.com>
  Copyright (C) 2011-2012 Ariya Hidayat <ariya.hidayat@gmail.com>
  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>
  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>
  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

/*global exports:true, require:true, global:true*/
(function () {
  'use strict';

  var Syntax, Precedence, BinaryPrecedence, SourceNode, estraverse, esutils, base, indent, json, renumber, hexadecimal, quotes, escapeless, newline, space, parentheses, semicolons, safeConcatenation, directive, extra, parse, sourceMap, sourceCode, preserveBlankLines, FORMAT_MINIFY, FORMAT_DEFAULTS;
  estraverse = require('estraverse');
  esutils = require('esutils');
  Syntax = estraverse.Syntax; // Generation is done by generateExpression.

  function isExpression(node) {
    return CodeGenerator.Expression.hasOwnProperty(node.type);
  } // Generation is done by generateStatement.


  function isStatement(node) {
    return CodeGenerator.Statement.hasOwnProperty(node.type);
  }

  Precedence = {
    Sequence: 0,
    Yield: 1,
    Assignment: 1,
    Conditional: 2,
    ArrowFunction: 2,
    LogicalOR: 3,
    LogicalAND: 4,
    BitwiseOR: 5,
    BitwiseXOR: 6,
    BitwiseAND: 7,
    Equality: 8,
    Relational: 9,
    BitwiseSHIFT: 10,
    Additive: 11,
    Multiplicative: 12,
    Exponentiation: 13,
    Await: 14,
    Unary: 14,
    Postfix: 15,
    OptionalChaining: 16,
    Call: 17,
    New: 18,
    TaggedTemplate: 19,
    Member: 20,
    Primary: 21
  };
  BinaryPrecedence = {
    '||': Precedence.LogicalOR,
    '&&': Precedence.LogicalAND,
    '|': Precedence.BitwiseOR,
    '^': Precedence.BitwiseXOR,
    '&': Precedence.BitwiseAND,
    '==': Precedence.Equality,
    '!=': Precedence.Equality,
    '===': Precedence.Equality,
    '!==': Precedence.Equality,
    'is': Precedence.Equality,
    'isnt': Precedence.Equality,
    '<': Precedence.Relational,
    '>': Precedence.Relational,
    '<=': Precedence.Relational,
    '>=': Precedence.Relational,
    'in': Precedence.Relational,
    'instanceof': Precedence.Relational,
    '<<': Precedence.BitwiseSHIFT,
    '>>': Precedence.BitwiseSHIFT,
    '>>>': Precedence.BitwiseSHIFT,
    '+': Precedence.Additive,
    '-': Precedence.Additive,
    '*': Precedence.Multiplicative,
    '%': Precedence.Multiplicative,
    '/': Precedence.Multiplicative,
    '**': Precedence.Exponentiation
  }; //Flags

  var F_ALLOW_IN = 1,
      F_ALLOW_CALL = 1 << 1,
      F_ALLOW_UNPARATH_NEW = 1 << 2,
      F_FUNC_BODY = 1 << 3,
      F_DIRECTIVE_CTX = 1 << 4,
      F_SEMICOLON_OPT = 1 << 5; //Expression flag sets
  //NOTE: Flag order:
  // F_ALLOW_IN
  // F_ALLOW_CALL
  // F_ALLOW_UNPARATH_NEW

  var E_FTT = F_ALLOW_CALL | F_ALLOW_UNPARATH_NEW,
      E_TTF = F_ALLOW_IN | F_ALLOW_CALL,
      E_TTT = F_ALLOW_IN | F_ALLOW_CALL | F_ALLOW_UNPARATH_NEW,
      E_TFF = F_ALLOW_IN,
      E_FFT = F_ALLOW_UNPARATH_NEW,
      E_TFT = F_ALLOW_IN | F_ALLOW_UNPARATH_NEW; //Statement flag sets
  //NOTE: Flag order:
  // F_ALLOW_IN
  // F_FUNC_BODY
  // F_DIRECTIVE_CTX
  // F_SEMICOLON_OPT

  var S_TFFF = F_ALLOW_IN,
      S_TFFT = F_ALLOW_IN | F_SEMICOLON_OPT,
      S_FFFF = 0x00,
      S_TFTF = F_ALLOW_IN | F_DIRECTIVE_CTX,
      S_TTFF = F_ALLOW_IN | F_FUNC_BODY;

  function getDefaultOptions() {
    // default options
    return {
      indent: null,
      base: null,
      parse: null,
      comment: false,
      format: {
        indent: {
          style: '    ',
          base: 0,
          adjustMultilineComment: false
        },
        newline: '\n',
        space: ' ',
        json: false,
        renumber: false,
        hexadecimal: false,
        quotes: 'single',
        escapeless: false,
        compact: false,
        parentheses: true,
        semicolons: true,
        safeConcatenation: false,
        preserveBlankLines: false
      },
      moz: {
        comprehensionExpressionStartsWithAssignment: false,
        starlessGenerator: false
      },
      sourceMap: null,
      sourceMapRoot: null,
      sourceMapWithCode: false,
      directive: false,
      raw: true,
      verbatim: null,
      sourceCode: null
    };
  }

  function stringRepeat(str, num) {
    var result = '';

    for (num |= 0; num > 0; num >>>= 1, str += str) {
      if (num & 1) {
        result += str;
      }
    }

    return result;
  }

  function hasLineTerminator(str) {
    return /[\r\n]/g.test(str);
  }

  function endsWithLineTerminator(str) {
    var len = str.length;
    return len && esutils.code.isLineTerminator(str.charCodeAt(len - 1));
  }

  function merge(target, override) {
    var key;

    for (key in override) {
      if (override.hasOwnProperty(key)) {
        target[key] = override[key];
      }
    }

    return target;
  }

  function updateDeeply(target, override) {
    var key, val;

    function isHashObject(target) {
      return typeof target === 'object' && target instanceof Object && !(target instanceof RegExp);
    }

    for (key in override) {
      if (override.hasOwnProperty(key)) {
        val = override[key];

        if (isHashObject(val)) {
          if (isHashObject(target[key])) {
            updateDeeply(target[key], val);
          } else {
            target[key] = updateDeeply({}, val);
          }
        } else {
          target[key] = val;
        }
      }
    }

    return target;
  }

  function generateNumber(value) {
    var result, point, temp, exponent, pos;

    if (value !== value) {
      throw new Error('Numeric literal whose value is NaN');
    }

    if (value < 0 || value === 0 && 1 / value < 0) {
      throw new Error('Numeric literal whose value is negative');
    }

    if (value === 1 / 0) {
      return json ? 'null' : renumber ? '1e400' : '1e+400';
    }

    result = '' + value;

    if (!renumber || result.length < 3) {
      return result;
    }

    point = result.indexOf('.');

    if (!json && result.charCodeAt(0) === 0x30
    /* 0 */
    && point === 1) {
      point = 0;
      result = result.slice(1);
    }

    temp = result;
    result = result.replace('e+', 'e');
    exponent = 0;

    if ((pos = temp.indexOf('e')) > 0) {
      exponent = +temp.slice(pos + 1);
      temp = temp.slice(0, pos);
    }

    if (point >= 0) {
      exponent -= temp.length - point - 1;
      temp = +(temp.slice(0, point) + temp.slice(point + 1)) + '';
    }

    pos = 0;

    while (temp.charCodeAt(temp.length + pos - 1) === 0x30
    /* 0 */
    ) {
      --pos;
    }

    if (pos !== 0) {
      exponent -= pos;
      temp = temp.slice(0, pos);
    }

    if (exponent !== 0) {
      temp += 'e' + exponent;
    }

    if ((temp.length < result.length || hexadecimal && value > 1e12 && Math.floor(value) === value && (temp = '0x' + value.toString(16)).length < result.length) && +temp === value) {
      result = temp;
    }

    return result;
  } // Generate valid RegExp expression.
  // This function is based on https://github.com/Constellation/iv Engine


  function escapeRegExpCharacter(ch, previousIsBackslash) {
    // not handling '\' and handling \u2028 or \u2029 to unicode escape sequence
    if ((ch & ~1) === 0x2028) {
      return (previousIsBackslash ? 'u' : '\\u') + (ch === 0x2028 ? '2028' : '2029');
    } else if (ch === 10 || ch === 13) {
      // \n, \r
      return (previousIsBackslash ? '' : '\\') + (ch === 10 ? 'n' : 'r');
    }

    return String.fromCharCode(ch);
  }

  function generateRegExp(reg) {
    var match, result, flags, i, iz, ch, characterInBrack, previousIsBackslash;
    result = reg.toString();

    if (reg.source) {
      // extract flag from toString result
      match = result.match(/\/([^/]*)$/);

      if (!match) {
        return result;
      }

      flags = match[1];
      result = '';
      characterInBrack = false;
      previousIsBackslash = false;

      for (i = 0, iz = reg.source.length; i < iz; ++i) {
        ch = reg.source.charCodeAt(i);

        if (!previousIsBackslash) {
          if (characterInBrack) {
            if (ch === 93) {
              // ]
              characterInBrack = false;
            }
          } else {
            if (ch === 47) {
              // /
              result += '\\';
            } else if (ch === 91) {
              // [
              characterInBrack = true;
            }
          }

          result += escapeRegExpCharacter(ch, previousIsBackslash);
          previousIsBackslash = ch === 92; // \
        } else {
          // if new RegExp("\\\n') is provided, create /\n/
          result += escapeRegExpCharacter(ch, previousIsBackslash); // prevent like /\\[/]/

          previousIsBackslash = false;
        }
      }

      return '/' + result + '/' + flags;
    }

    return result;
  }

  function escapeAllowedCharacter(code, next) {
    var hex;

    if (code === 0x08
    /* \b */
    ) {
        return '\\b';
      }

    if (code === 0x0C
    /* \f */
    ) {
        return '\\f';
      }

    if (code === 0x09
    /* \t */
    ) {
        return '\\t';
      }

    hex = code.toString(16).toUpperCase();

    if (json || code > 0xFF) {
      return '\\u' + '0000'.slice(hex.length) + hex;
    } else if (code === 0x0000 && !esutils.code.isDecimalDigit(next)) {
      return '\\0';
    } else if (code === 0x000B
    /* \v */
    ) {
        // '\v'
        return '\\x0B';
      } else {
      return '\\x' + '00'.slice(hex.length) + hex;
    }
  }

  function escapeDisallowedCharacter(code) {
    if (code === 0x5C
    /* \ */
    ) {
        return '\\\\';
      }

    if (code === 0x0A
    /* \n */
    ) {
        return '\\n';
      }

    if (code === 0x0D
    /* \r */
    ) {
        return '\\r';
      }

    if (code === 0x2028) {
      return '\\u2028';
    }

    if (code === 0x2029) {
      return '\\u2029';
    }

    throw new Error('Incorrectly classified character');
  }

  function escapeDirective(str) {
    var i, iz, code, quote;
    quote = quotes === 'double' ? '"' : '\'';

    for (i = 0, iz = str.length; i < iz; ++i) {
      code = str.charCodeAt(i);

      if (code === 0x27
      /* ' */
      ) {
          quote = '"';
          break;
        } else if (code === 0x22
      /* " */
      ) {
          quote = '\'';
          break;
        } else if (code === 0x5C
      /* \ */
      ) {
          ++i;
        }
    }

    return quote + str + quote;
  }

  function escapeString(str) {
    var result = '',
        i,
        len,
        code,
        singleQuotes = 0,
        doubleQuotes = 0,
        single,
        quote;

    for (i = 0, len = str.length; i < len; ++i) {
      code = str.charCodeAt(i);

      if (code === 0x27
      /* ' */
      ) {
          ++singleQuotes;
        } else if (code === 0x22
      /* " */
      ) {
          ++doubleQuotes;
        } else if (code === 0x2F
      /* / */
      && json) {
        result += '\\';
      } else if (esutils.code.isLineTerminator(code) || code === 0x5C
      /* \ */
      ) {
          result += escapeDisallowedCharacter(code);
          continue;
        } else if (!esutils.code.isIdentifierPartES5(code) && (json && code < 0x20
      /* SP */
      || !json && !escapeless && (code < 0x20
      /* SP */
      || code > 0x7E
      /* ~ */
      ))) {
        result += escapeAllowedCharacter(code, str.charCodeAt(i + 1));
        continue;
      }

      result += String.fromCharCode(code);
    }

    single = !(quotes === 'double' || quotes === 'auto' && doubleQuotes < singleQuotes);
    quote = single ? '\'' : '"';

    if (!(single ? singleQuotes : doubleQuotes)) {
      return quote + result + quote;
    }

    str = result;
    result = quote;

    for (i = 0, len = str.length; i < len; ++i) {
      code = str.charCodeAt(i);

      if (code === 0x27
      /* ' */
      && single || code === 0x22
      /* " */
      && !single) {
        result += '\\';
      }

      result += String.fromCharCode(code);
    }

    return result + quote;
  }
  /**
   * flatten an array to a string, where the array can contain
   * either strings or nested arrays
   */


  function flattenToString(arr) {
    var i,
        iz,
        elem,
        result = '';

    for (i = 0, iz = arr.length; i < iz; ++i) {
      elem = arr[i];
      result += Array.isArray(elem) ? flattenToString(elem) : elem;
    }

    return result;
  }
  /**
   * convert generated to a SourceNode when source maps are enabled.
   */


  function toSourceNodeWhenNeeded(generated, node) {
    if (!sourceMap) {
      // with no source maps, generated is either an
      // array or a string.  if an array, flatten it.
      // if a string, just return it
      if (Array.isArray(generated)) {
        return flattenToString(generated);
      } else {
        return generated;
      }
    }

    if (node == null) {
      if (generated instanceof SourceNode) {
        return generated;
      } else {
        node = {};
      }
    }

    if (node.loc == null) {
      return new SourceNode(null, null, sourceMap, generated, node.name || null);
    }

    return new SourceNode(node.loc.start.line, node.loc.start.column, sourceMap === true ? node.loc.source || null : sourceMap, generated, node.name || null);
  }

  function noEmptySpace() {
    return space ? space : ' ';
  }

  function join(left, right) {
    var leftSource, rightSource, leftCharCode, rightCharCode;
    leftSource = toSourceNodeWhenNeeded(left).toString();

    if (leftSource.length === 0) {
      return [right];
    }

    rightSource = toSourceNodeWhenNeeded(right).toString();

    if (rightSource.length === 0) {
      return [left];
    }

    leftCharCode = leftSource.charCodeAt(leftSource.length - 1);
    rightCharCode = rightSource.charCodeAt(0);

    if ((leftCharCode === 0x2B
    /* + */
    || leftCharCode === 0x2D
    /* - */
    ) && leftCharCode === rightCharCode || esutils.code.isIdentifierPartES5(leftCharCode) && esutils.code.isIdentifierPartES5(rightCharCode) || leftCharCode === 0x2F
    /* / */
    && rightCharCode === 0x69
    /* i */
    ) {
        // infix word operators all start with `i`
        return [left, noEmptySpace(), right];
      } else if (esutils.code.isWhiteSpace(leftCharCode) || esutils.code.isLineTerminator(leftCharCode) || esutils.code.isWhiteSpace(rightCharCode) || esutils.code.isLineTerminator(rightCharCode)) {
      return [left, right];
    }

    return [left, space, right];
  }

  function addIndent(stmt) {
    return [base, stmt];
  }

  function withIndent(fn) {
    var previousBase;
    previousBase = base;
    base += indent;
    fn(base);
    base = previousBase;
  }

  function calculateSpaces(str) {
    var i;

    for (i = str.length - 1; i >= 0; --i) {
      if (esutils.code.isLineTerminator(str.charCodeAt(i))) {
        break;
      }
    }

    return str.length - 1 - i;
  }

  function adjustMultilineComment(value, specialBase) {
    var array, i, len, line, j, spaces, previousBase, sn;
    array = value.split(/\r\n|[\r\n]/);
    spaces = Number.MAX_VALUE; // first line doesn't have indentation

    for (i = 1, len = array.length; i < len; ++i) {
      line = array[i];
      j = 0;

      while (j < line.length && esutils.code.isWhiteSpace(line.charCodeAt(j))) {
        ++j;
      }

      if (spaces > j) {
        spaces = j;
      }
    }

    if (typeof specialBase !== 'undefined') {
      // pattern like
      // {
      //   var t = 20;  /*
      //                 * this is comment
      //                 */
      // }
      previousBase = base;

      if (array[1][spaces] === '*') {
        specialBase += ' ';
      }

      base = specialBase;
    } else {
      if (spaces & 1) {
        // /*
        //  *
        //  */
        // If spaces are odd number, above pattern is considered.
        // We waste 1 space.
        --spaces;
      }

      previousBase = base;
    }

    for (i = 1, len = array.length; i < len; ++i) {
      sn = toSourceNodeWhenNeeded(addIndent(array[i].slice(spaces)));
      array[i] = sourceMap ? sn.join('') : sn;
    }

    base = previousBase;
    return array.join('\n');
  }

  function generateComment(comment, specialBase) {
    if (comment.type === 'Line') {
      if (endsWithLineTerminator(comment.value)) {
        return '//' + comment.value;
      } else {
        // Always use LineTerminator
        var result = '//' + comment.value;

        if (!preserveBlankLines) {
          result += '\n';
        }

        return result;
      }
    }

    if (extra.format.indent.adjustMultilineComment && /[\n\r]/.test(comment.value)) {
      return adjustMultilineComment('/*' + comment.value + '*/', specialBase);
    }

    return '/*' + comment.value + '*/';
  }

  function addComments(stmt, result) {
    var i, len, comment, save, tailingToStatement, specialBase, fragment, extRange, range, prevRange, prefix, infix, suffix, count;

    if (stmt.leadingComments && stmt.leadingComments.length > 0) {
      save = result;

      if (preserveBlankLines) {
        comment = stmt.leadingComments[0];
        result = [];
        extRange = comment.extendedRange;
        range = comment.range;
        prefix = sourceCode.substring(extRange[0], range[0]);
        count = (prefix.match(/\n/g) || []).length;

        if (count > 0) {
          result.push(stringRepeat('\n', count));
          result.push(addIndent(generateComment(comment)));
        } else {
          result.push(prefix);
          result.push(generateComment(comment));
        }

        prevRange = range;

        for (i = 1, len = stmt.leadingComments.length; i < len; i++) {
          comment = stmt.leadingComments[i];
          range = comment.range;
          infix = sourceCode.substring(prevRange[1], range[0]);
          count = (infix.match(/\n/g) || []).length;
          result.push(stringRepeat('\n', count));
          result.push(addIndent(generateComment(comment)));
          prevRange = range;
        }

        suffix = sourceCode.substring(range[1], extRange[1]);
        count = (suffix.match(/\n/g) || []).length;
        result.push(stringRepeat('\n', count));
      } else {
        comment = stmt.leadingComments[0];
        result = [];

        if (safeConcatenation && stmt.type === Syntax.Program && stmt.body.length === 0) {
          result.push('\n');
        }

        result.push(generateComment(comment));

        if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
          result.push('\n');
        }

        for (i = 1, len = stmt.leadingComments.length; i < len; ++i) {
          comment = stmt.leadingComments[i];
          fragment = [generateComment(comment)];

          if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
            fragment.push('\n');
          }

          result.push(addIndent(fragment));
        }
      }

      result.push(addIndent(save));
    }

    if (stmt.trailingComments) {
      if (preserveBlankLines) {
        comment = stmt.trailingComments[0];
        extRange = comment.extendedRange;
        range = comment.range;
        prefix = sourceCode.substring(extRange[0], range[0]);
        count = (prefix.match(/\n/g) || []).length;

        if (count > 0) {
          result.push(stringRepeat('\n', count));
          result.push(addIndent(generateComment(comment)));
        } else {
          result.push(prefix);
          result.push(generateComment(comment));
        }
      } else {
        tailingToStatement = !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString());
        specialBase = stringRepeat(' ', calculateSpaces(toSourceNodeWhenNeeded([base, result, indent]).toString()));

        for (i = 0, len = stmt.trailingComments.length; i < len; ++i) {
          comment = stmt.trailingComments[i];

          if (tailingToStatement) {
            // We assume target like following script
            //
            // var t = 20;  /**
            //               * This is comment of t
            //               */
            if (i === 0) {
              // first case
              result = [result, indent];
            } else {
              result = [result, specialBase];
            }

            result.push(generateComment(comment, specialBase));
          } else {
            result = [result, addIndent(generateComment(comment))];
          }

          if (i !== len - 1 && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
            result = [result, '\n'];
          }
        }
      }
    }

    return result;
  }

  function generateBlankLines(start, end, result) {
    var j,
        newlineCount = 0;

    for (j = start; j < end; j++) {
      if (sourceCode[j] === '\n') {
        newlineCount++;
      }
    }

    for (j = 1; j < newlineCount; j++) {
      result.push(newline);
    }
  }

  function parenthesize(text, current, should) {
    if (current < should) {
      return ['(', text, ')'];
    }

    return text;
  }

  function generateVerbatimString(string) {
    var i, iz, result;
    result = string.split(/\r\n|\n/);

    for (i = 1, iz = result.length; i < iz; i++) {
      result[i] = newline + base + result[i];
    }

    return result;
  }

  function generateVerbatim(expr, precedence) {
    var verbatim, result, prec;
    verbatim = expr[extra.verbatim];

    if (typeof verbatim === 'string') {
      result = parenthesize(generateVerbatimString(verbatim), Precedence.Sequence, precedence);
    } else {
      // verbatim is object
      result = generateVerbatimString(verbatim.content);
      prec = verbatim.precedence != null ? verbatim.precedence : Precedence.Sequence;
      result = parenthesize(result, prec, precedence);
    }

    return toSourceNodeWhenNeeded(result, expr);
  }

  function CodeGenerator() {} // Helpers.


  CodeGenerator.prototype.maybeBlock = function (stmt, flags) {
    var result,
        noLeadingComment,
        that = this;
    noLeadingComment = !extra.comment || !stmt.leadingComments;

    if (stmt.type === Syntax.BlockStatement && noLeadingComment) {
      return [space, this.generateStatement(stmt, flags)];
    }

    if (stmt.type === Syntax.EmptyStatement && noLeadingComment) {
      return ';';
    }

    withIndent(function () {
      result = [newline, addIndent(that.generateStatement(stmt, flags))];
    });
    return result;
  };

  CodeGenerator.prototype.maybeBlockSuffix = function (stmt, result) {
    var ends = endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString());

    if (stmt.type === Syntax.BlockStatement && (!extra.comment || !stmt.leadingComments) && !ends) {
      return [result, space];
    }

    if (ends) {
      return [result, base];
    }

    return [result, newline, base];
  };

  function generateIdentifier(node) {
    return toSourceNodeWhenNeeded(node.name, node);
  }

  function generateAsyncPrefix(node, spaceRequired) {
    return node.async ? 'async' + (spaceRequired ? noEmptySpace() : space) : '';
  }

  function generateStarSuffix(node) {
    var isGenerator = node.generator && !extra.moz.starlessGenerator;
    return isGenerator ? '*' + space : '';
  }

  function generateMethodPrefix(prop) {
    var func = prop.value,
        prefix = '';

    if (func.async) {
      prefix += generateAsyncPrefix(func, !prop.computed);
    }

    if (func.generator) {
      // avoid space before method name
      prefix += generateStarSuffix(func) ? '*' : '';
    }

    return prefix;
  }

  CodeGenerator.prototype.generatePattern = function (node, precedence, flags) {
    if (node.type === Syntax.Identifier) {
      return generateIdentifier(node);
    }

    return this.generateExpression(node, precedence, flags);
  };

  CodeGenerator.prototype.generateFunctionParams = function (node) {
    var i, iz, result, hasDefault;
    hasDefault = false;

    if (node.type === Syntax.ArrowFunctionExpression && !node.rest && (!node.defaults || node.defaults.length === 0) && node.params.length === 1 && node.params[0].type === Syntax.Identifier) {
      // arg => { } case
      result = [generateAsyncPrefix(node, true), generateIdentifier(node.params[0])];
    } else {
      result = node.type === Syntax.ArrowFunctionExpression ? [generateAsyncPrefix(node, false)] : [];
      result.push('(');

      if (node.defaults) {
        hasDefault = true;
      }

      for (i = 0, iz = node.params.length; i < iz; ++i) {
        if (hasDefault && node.defaults[i]) {
          // Handle default values.
          result.push(this.generateAssignment(node.params[i], node.defaults[i], '=', Precedence.Assignment, E_TTT));
        } else {
          result.push(this.generatePattern(node.params[i], Precedence.Assignment, E_TTT));
        }

        if (i + 1 < iz) {
          result.push(',' + space);
        }
      }

      if (node.rest) {
        if (node.params.length) {
          result.push(',' + space);
        }

        result.push('...');
        result.push(generateIdentifier(node.rest));
      }

      result.push(')');
    }

    return result;
  };

  CodeGenerator.prototype.generateFunctionBody = function (node) {
    var result, expr;
    result = this.generateFunctionParams(node);

    if (node.type === Syntax.ArrowFunctionExpression) {
      result.push(space);
      result.push('=>');
    }

    if (node.expression) {
      result.push(space);
      expr = this.generateExpression(node.body, Precedence.Assignment, E_TTT);

      if (expr.toString().charAt(0) === '{') {
        expr = ['(', expr, ')'];
      }

      result.push(expr);
    } else {
      result.push(this.maybeBlock(node.body, S_TTFF));
    }

    return result;
  };

  CodeGenerator.prototype.generateIterationForStatement = function (operator, stmt, flags) {
    var result = ['for' + (stmt.await ? noEmptySpace() + 'await' : '') + space + '('],
        that = this;
    withIndent(function () {
      if (stmt.left.type === Syntax.VariableDeclaration) {
        withIndent(function () {
          result.push(stmt.left.kind + noEmptySpace());
          result.push(that.generateStatement(stmt.left.declarations[0], S_FFFF));
        });
      } else {
        result.push(that.generateExpression(stmt.left, Precedence.Call, E_TTT));
      }

      result = join(result, operator);
      result = [join(result, that.generateExpression(stmt.right, Precedence.Assignment, E_TTT)), ')'];
    });
    result.push(this.maybeBlock(stmt.body, flags));
    return result;
  };

  CodeGenerator.prototype.generatePropertyKey = function (expr, computed) {
    var result = [];

    if (computed) {
      result.push('[');
    }

    result.push(this.generateExpression(expr, Precedence.Assignment, E_TTT));

    if (computed) {
      result.push(']');
    }

    return result;
  };

  CodeGenerator.prototype.generateAssignment = function (left, right, operator, precedence, flags) {
    if (Precedence.Assignment < precedence) {
      flags |= F_ALLOW_IN;
    }

    return parenthesize([this.generateExpression(left, Precedence.Call, flags), space + operator + space, this.generateExpression(right, Precedence.Assignment, flags)], Precedence.Assignment, precedence);
  };

  CodeGenerator.prototype.semicolon = function (flags) {
    if (!semicolons && flags & F_SEMICOLON_OPT) {
      return '';
    }

    return ';';
  }; // Statements.


  CodeGenerator.Statement = {
    BlockStatement: function (stmt, flags) {
      var range,
          content,
          result = ['{', newline],
          that = this;
      withIndent(function () {
        // handle functions without any code
        if (stmt.body.length === 0 && preserveBlankLines) {
          range = stmt.range;

          if (range[1] - range[0] > 2) {
            content = sourceCode.substring(range[0] + 1, range[1] - 1);

            if (content[0] === '\n') {
              result = ['{'];
            }

            result.push(content);
          }
        }

        var i, iz, fragment, bodyFlags;
        bodyFlags = S_TFFF;

        if (flags & F_FUNC_BODY) {
          bodyFlags |= F_DIRECTIVE_CTX;
        }

        for (i = 0, iz = stmt.body.length; i < iz; ++i) {
          if (preserveBlankLines) {
            // handle spaces before the first line
            if (i === 0) {
              if (stmt.body[0].leadingComments) {
                range = stmt.body[0].leadingComments[0].extendedRange;
                content = sourceCode.substring(range[0], range[1]);

                if (content[0] === '\n') {
                  result = ['{'];
                }
              }

              if (!stmt.body[0].leadingComments) {
                generateBlankLines(stmt.range[0], stmt.body[0].range[0], result);
              }
            } // handle spaces between lines


            if (i > 0) {
              if (!stmt.body[i - 1].trailingComments && !stmt.body[i].leadingComments) {
                generateBlankLines(stmt.body[i - 1].range[1], stmt.body[i].range[0], result);
              }
            }
          }

          if (i === iz - 1) {
            bodyFlags |= F_SEMICOLON_OPT;
          }

          if (stmt.body[i].leadingComments && preserveBlankLines) {
            fragment = that.generateStatement(stmt.body[i], bodyFlags);
          } else {
            fragment = addIndent(that.generateStatement(stmt.body[i], bodyFlags));
          }

          result.push(fragment);

          if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
            if (preserveBlankLines && i < iz - 1) {
              // don't add a new line if there are leading coments
              // in the next statement
              if (!stmt.body[i + 1].leadingComments) {
                result.push(newline);
              }
            } else {
              result.push(newline);
            }
          }

          if (preserveBlankLines) {
            // handle spaces after the last line
            if (i === iz - 1) {
              if (!stmt.body[i].trailingComments) {
                generateBlankLines(stmt.body[i].range[1], stmt.range[1], result);
              }
            }
          }
        }
      });
      result.push(addIndent('}'));
      return result;
    },
    BreakStatement: function (stmt, flags) {
      if (stmt.label) {
        return 'break ' + stmt.label.name + this.semicolon(flags);
      }

      return 'break' + this.semicolon(flags);
    },
    ContinueStatement: function (stmt, flags) {
      if (stmt.label) {
        return 'continue ' + stmt.label.name + this.semicolon(flags);
      }

      return 'continue' + this.semicolon(flags);
    },
    ClassBody: function (stmt, flags) {
      var result = ['{', newline],
          that = this;
      withIndent(function (indent) {
        var i, iz;

        for (i = 0, iz = stmt.body.length; i < iz; ++i) {
          result.push(indent);
          result.push(that.generateExpression(stmt.body[i], Precedence.Sequence, E_TTT));

          if (i + 1 < iz) {
            result.push(newline);
          }
        }
      });

      if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
        result.push(newline);
      }

      result.push(base);
      result.push('}');
      return result;
    },
    ClassDeclaration: function (stmt, flags) {
      var result, fragment;
      result = ['class'];

      if (stmt.id) {
        result = join(result, this.generateExpression(stmt.id, Precedence.Sequence, E_TTT));
      }

      if (stmt.superClass) {
        fragment = join('extends', this.generateExpression(stmt.superClass, Precedence.Unary, E_TTT));
        result = join(result, fragment);
      }

      result.push(space);
      result.push(this.generateStatement(stmt.body, S_TFFT));
      return result;
    },
    DirectiveStatement: function (stmt, flags) {
      if (extra.raw && stmt.raw) {
        return stmt.raw + this.semicolon(flags);
      }

      return escapeDirective(stmt.directive) + this.semicolon(flags);
    },
    DoWhileStatement: function (stmt, flags) {
      // Because `do 42 while (cond)` is Syntax Error. We need semicolon.
      var result = join('do', this.maybeBlock(stmt.body, S_TFFF));
      result = this.maybeBlockSuffix(stmt.body, result);
      return join(result, ['while' + space + '(', this.generateExpression(stmt.test, Precedence.Sequence, E_TTT), ')' + this.semicolon(flags)]);
    },
    CatchClause: function (stmt, flags) {
      var result,
          that = this;
      withIndent(function () {
        var guard;

        if (stmt.param) {
          result = ['catch' + space + '(', that.generateExpression(stmt.param, Precedence.Sequence, E_TTT), ')'];

          if (stmt.guard) {
            guard = that.generateExpression(stmt.guard, Precedence.Sequence, E_TTT);
            result.splice(2, 0, ' if ', guard);
          }
        } else {
          result = ['catch'];
        }
      });
      result.push(this.maybeBlock(stmt.body, S_TFFF));
      return result;
    },
    DebuggerStatement: function (stmt, flags) {
      return 'debugger' + this.semicolon(flags);
    },
    EmptyStatement: function (stmt, flags) {
      return ';';
    },
    ExportDefaultDeclaration: function (stmt, flags) {
      var result = ['export'],
          bodyFlags;
      bodyFlags = flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF; // export default HoistableDeclaration[Default]
      // export default AssignmentExpression[In] ;

      result = join(result, 'default');

      if (isStatement(stmt.declaration)) {
        result = join(result, this.generateStatement(stmt.declaration, bodyFlags));
      } else {
        result = join(result, this.generateExpression(stmt.declaration, Precedence.Assignment, E_TTT) + this.semicolon(flags));
      }

      return result;
    },
    ExportNamedDeclaration: function (stmt, flags) {
      var result = ['export'],
          bodyFlags,
          that = this;
      bodyFlags = flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF; // export VariableStatement
      // export Declaration[Default]

      if (stmt.declaration) {
        return join(result, this.generateStatement(stmt.declaration, bodyFlags));
      } // export ExportClause[NoReference] FromClause ;
      // export ExportClause ;


      if (stmt.specifiers) {
        if (stmt.specifiers.length === 0) {
          result = join(result, '{' + space + '}');
        } else if (stmt.specifiers[0].type === Syntax.ExportBatchSpecifier) {
          result = join(result, this.generateExpression(stmt.specifiers[0], Precedence.Sequence, E_TTT));
        } else {
          result = join(result, '{');
          withIndent(function (indent) {
            var i, iz;
            result.push(newline);

            for (i = 0, iz = stmt.specifiers.length; i < iz; ++i) {
              result.push(indent);
              result.push(that.generateExpression(stmt.specifiers[i], Precedence.Sequence, E_TTT));

              if (i + 1 < iz) {
                result.push(',' + newline);
              }
            }
          });

          if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
            result.push(newline);
          }

          result.push(base + '}');
        }

        if (stmt.source) {
          result = join(result, ['from' + space, // ModuleSpecifier
          this.generateExpression(stmt.source, Precedence.Sequence, E_TTT), this.semicolon(flags)]);
        } else {
          result.push(this.semicolon(flags));
        }
      }

      return result;
    },
    ExportAllDeclaration: function (stmt, flags) {
      // export * FromClause ;
      return ['export' + space, '*' + space, 'from' + space, // ModuleSpecifier
      this.generateExpression(stmt.source, Precedence.Sequence, E_TTT), this.semicolon(flags)];
    },
    ExpressionStatement: function (stmt, flags) {
      var result, fragment;

      function isClassPrefixed(fragment) {
        var code;

        if (fragment.slice(0, 5) !== 'class') {
          return false;
        }

        code = fragment.charCodeAt(5);
        return code === 0x7B
        /* '{' */
        || esutils.code.isWhiteSpace(code) || esutils.code.isLineTerminator(code);
      }

      function isFunctionPrefixed(fragment) {
        var code;

        if (fragment.slice(0, 8) !== 'function') {
          return false;
        }

        code = fragment.charCodeAt(8);
        return code === 0x28
        /* '(' */
        || esutils.code.isWhiteSpace(code) || code === 0x2A
        /* '*' */
        || esutils.code.isLineTerminator(code);
      }

      function isAsyncPrefixed(fragment) {
        var code, i, iz;

        if (fragment.slice(0, 5) !== 'async') {
          return false;
        }

        if (!esutils.code.isWhiteSpace(fragment.charCodeAt(5))) {
          return false;
        }

        for (i = 6, iz = fragment.length; i < iz; ++i) {
          if (!esutils.code.isWhiteSpace(fragment.charCodeAt(i))) {
            break;
          }
        }

        if (i === iz) {
          return false;
        }

        if (fragment.slice(i, i + 8) !== 'function') {
          return false;
        }

        code = fragment.charCodeAt(i + 8);
        return code === 0x28
        /* '(' */
        || esutils.code.isWhiteSpace(code) || code === 0x2A
        /* '*' */
        || esutils.code.isLineTerminator(code);
      }

      result = [this.generateExpression(stmt.expression, Precedence.Sequence, E_TTT)]; // 12.4 '{', 'function', 'class' is not allowed in this position.
      // wrap expression with parentheses

      fragment = toSourceNodeWhenNeeded(result).toString();

      if (fragment.charCodeAt(0) === 0x7B
      /* '{' */
      || // ObjectExpression
      isClassPrefixed(fragment) || isFunctionPrefixed(fragment) || isAsyncPrefixed(fragment) || directive && flags & F_DIRECTIVE_CTX && stmt.expression.type === Syntax.Literal && typeof stmt.expression.value === 'string') {
        result = ['(', result, ')' + this.semicolon(flags)];
      } else {
        result.push(this.semicolon(flags));
      }

      return result;
    },
    ImportDeclaration: function (stmt, flags) {
      // ES6: 15.2.1 valid import declarations:
      //     - import ImportClause FromClause ;
      //     - import ModuleSpecifier ;
      var result,
          cursor,
          that = this; // If no ImportClause is present,
      // this should be `import ModuleSpecifier` so skip `from`
      // ModuleSpecifier is StringLiteral.

      if (stmt.specifiers.length === 0) {
        // import ModuleSpecifier ;
        return ['import', space, // ModuleSpecifier
        this.generateExpression(stmt.source, Precedence.Sequence, E_TTT), this.semicolon(flags)];
      } // import ImportClause FromClause ;


      result = ['import'];
      cursor = 0; // ImportedBinding

      if (stmt.specifiers[cursor].type === Syntax.ImportDefaultSpecifier) {
        result = join(result, [this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT)]);
        ++cursor;
      }

      if (stmt.specifiers[cursor]) {
        if (cursor !== 0) {
          result.push(',');
        }

        if (stmt.specifiers[cursor].type === Syntax.ImportNamespaceSpecifier) {
          // NameSpaceImport
          result = join(result, [space, this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT)]);
        } else {
          // NamedImports
          result.push(space + '{');

          if (stmt.specifiers.length - cursor === 1) {
            // import { ... } from "...";
            result.push(space);
            result.push(this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT));
            result.push(space + '}' + space);
          } else {
            // import {
            //    ...,
            //    ...,
            // } from "...";
            withIndent(function (indent) {
              var i, iz;
              result.push(newline);

              for (i = cursor, iz = stmt.specifiers.length; i < iz; ++i) {
                result.push(indent);
                result.push(that.generateExpression(stmt.specifiers[i], Precedence.Sequence, E_TTT));

                if (i + 1 < iz) {
                  result.push(',' + newline);
                }
              }
            });

            if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
              result.push(newline);
            }

            result.push(base + '}' + space);
          }
        }
      }

      result = join(result, ['from' + space, // ModuleSpecifier
      this.generateExpression(stmt.source, Precedence.Sequence, E_TTT), this.semicolon(flags)]);
      return result;
    },
    VariableDeclarator: function (stmt, flags) {
      var itemFlags = flags & F_ALLOW_IN ? E_TTT : E_FTT;

      if (stmt.init) {
        return [this.generateExpression(stmt.id, Precedence.Assignment, itemFlags), space, '=', space, this.generateExpression(stmt.init, Precedence.Assignment, itemFlags)];
      }

      return this.generatePattern(stmt.id, Precedence.Assignment, itemFlags);
    },
    VariableDeclaration: function (stmt, flags) {
      // VariableDeclarator is typed as Statement,
      // but joined with comma (not LineTerminator).
      // So if comment is attached to target node, we should specialize.
      var result,
          i,
          iz,
          node,
          bodyFlags,
          that = this;
      result = [stmt.kind];
      bodyFlags = flags & F_ALLOW_IN ? S_TFFF : S_FFFF;

      function block() {
        node = stmt.declarations[0];

        if (extra.comment && node.leadingComments) {
          result.push('\n');
          result.push(addIndent(that.generateStatement(node, bodyFlags)));
        } else {
          result.push(noEmptySpace());
          result.push(that.generateStatement(node, bodyFlags));
        }

        for (i = 1, iz = stmt.declarations.length; i < iz; ++i) {
          node = stmt.declarations[i];

          if (extra.comment && node.leadingComments) {
            result.push(',' + newline);
            result.push(addIndent(that.generateStatement(node, bodyFlags)));
          } else {
            result.push(',' + space);
            result.push(that.generateStatement(node, bodyFlags));
          }
        }
      }

      if (stmt.declarations.length > 1) {
        withIndent(block);
      } else {
        block();
      }

      result.push(this.semicolon(flags));
      return result;
    },
    ThrowStatement: function (stmt, flags) {
      return [join('throw', this.generateExpression(stmt.argument, Precedence.Sequence, E_TTT)), this.semicolon(flags)];
    },
    TryStatement: function (stmt, flags) {
      var result, i, iz, guardedHandlers;
      result = ['try', this.maybeBlock(stmt.block, S_TFFF)];
      result = this.maybeBlockSuffix(stmt.block, result);

      if (stmt.handlers) {
        // old interface
        for (i = 0, iz = stmt.handlers.length; i < iz; ++i) {
          result = join(result, this.generateStatement(stmt.handlers[i], S_TFFF));

          if (stmt.finalizer || i + 1 !== iz) {
            result = this.maybeBlockSuffix(stmt.handlers[i].body, result);
          }
        }
      } else {
        guardedHandlers = stmt.guardedHandlers || [];

        for (i = 0, iz = guardedHandlers.length; i < iz; ++i) {
          result = join(result, this.generateStatement(guardedHandlers[i], S_TFFF));

          if (stmt.finalizer || i + 1 !== iz) {
            result = this.maybeBlockSuffix(guardedHandlers[i].body, result);
          }
        } // new interface


        if (stmt.handler) {
          if (Array.isArray(stmt.handler)) {
            for (i = 0, iz = stmt.handler.length; i < iz; ++i) {
              result = join(result, this.generateStatement(stmt.handler[i], S_TFFF));

              if (stmt.finalizer || i + 1 !== iz) {
                result = this.maybeBlockSuffix(stmt.handler[i].body, result);
              }
            }
          } else {
            result = join(result, this.generateStatement(stmt.handler, S_TFFF));

            if (stmt.finalizer) {
              result = this.maybeBlockSuffix(stmt.handler.body, result);
            }
          }
        }
      }

      if (stmt.finalizer) {
        result = join(result, ['finally', this.maybeBlock(stmt.finalizer, S_TFFF)]);
      }

      return result;
    },
    SwitchStatement: function (stmt, flags) {
      var result,
          fragment,
          i,
          iz,
          bodyFlags,
          that = this;
      withIndent(function () {
        result = ['switch' + space + '(', that.generateExpression(stmt.discriminant, Precedence.Sequence, E_TTT), ')' + space + '{' + newline];
      });

      if (stmt.cases) {
        bodyFlags = S_TFFF;

        for (i = 0, iz = stmt.cases.length; i < iz; ++i) {
          if (i === iz - 1) {
            bodyFlags |= F_SEMICOLON_OPT;
          }

          fragment = addIndent(this.generateStatement(stmt.cases[i], bodyFlags));
          result.push(fragment);

          if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
            result.push(newline);
          }
        }
      }

      result.push(addIndent('}'));
      return result;
    },
    SwitchCase: function (stmt, flags) {
      var result,
          fragment,
          i,
          iz,
          bodyFlags,
          that = this;
      withIndent(function () {
        if (stmt.test) {
          result = [join('case', that.generateExpression(stmt.test, Precedence.Sequence, E_TTT)), ':'];
        } else {
          result = ['default:'];
        }

        i = 0;
        iz = stmt.consequent.length;

        if (iz && stmt.consequent[0].type === Syntax.BlockStatement) {
          fragment = that.maybeBlock(stmt.consequent[0], S_TFFF);
          result.push(fragment);
          i = 1;
        }

        if (i !== iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
          result.push(newline);
        }

        bodyFlags = S_TFFF;

        for (; i < iz; ++i) {
          if (i === iz - 1 && flags & F_SEMICOLON_OPT) {
            bodyFlags |= F_SEMICOLON_OPT;
          }

          fragment = addIndent(that.generateStatement(stmt.consequent[i], bodyFlags));
          result.push(fragment);

          if (i + 1 !== iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
            result.push(newline);
          }
        }
      });
      return result;
    },
    IfStatement: function (stmt, flags) {
      var result,
          bodyFlags,
          semicolonOptional,
          that = this;
      withIndent(function () {
        result = ['if' + space + '(', that.generateExpression(stmt.test, Precedence.Sequence, E_TTT), ')'];
      });
      semicolonOptional = flags & F_SEMICOLON_OPT;
      bodyFlags = S_TFFF;

      if (semicolonOptional) {
        bodyFlags |= F_SEMICOLON_OPT;
      }

      if (stmt.alternate) {
        result.push(this.maybeBlock(stmt.consequent, S_TFFF));
        result = this.maybeBlockSuffix(stmt.consequent, result);

        if (stmt.alternate.type === Syntax.IfStatement) {
          result = join(result, ['else ', this.generateStatement(stmt.alternate, bodyFlags)]);
        } else {
          result = join(result, join('else', this.maybeBlock(stmt.alternate, bodyFlags)));
        }
      } else {
        result.push(this.maybeBlock(stmt.consequent, bodyFlags));
      }

      return result;
    },
    ForStatement: function (stmt, flags) {
      var result,
          that = this;
      withIndent(function () {
        result = ['for' + space + '('];

        if (stmt.init) {
          if (stmt.init.type === Syntax.VariableDeclaration) {
            result.push(that.generateStatement(stmt.init, S_FFFF));
          } else {
            // F_ALLOW_IN becomes false.
            result.push(that.generateExpression(stmt.init, Precedence.Sequence, E_FTT));
            result.push(';');
          }
        } else {
          result.push(';');
        }

        if (stmt.test) {
          result.push(space);
          result.push(that.generateExpression(stmt.test, Precedence.Sequence, E_TTT));
          result.push(';');
        } else {
          result.push(';');
        }

        if (stmt.update) {
          result.push(space);
          result.push(that.generateExpression(stmt.update, Precedence.Sequence, E_TTT));
          result.push(')');
        } else {
          result.push(')');
        }
      });
      result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));
      return result;
    },
    ForInStatement: function (stmt, flags) {
      return this.generateIterationForStatement('in', stmt, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF);
    },
    ForOfStatement: function (stmt, flags) {
      return this.generateIterationForStatement('of', stmt, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF);
    },
    LabeledStatement: function (stmt, flags) {
      return [stmt.label.name + ':', this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF)];
    },
    Program: function (stmt, flags) {
      var result, fragment, i, iz, bodyFlags;
      iz = stmt.body.length;
      result = [safeConcatenation && iz > 0 ? '\n' : ''];
      bodyFlags = S_TFTF;

      for (i = 0; i < iz; ++i) {
        if (!safeConcatenation && i === iz - 1) {
          bodyFlags |= F_SEMICOLON_OPT;
        }

        if (preserveBlankLines) {
          // handle spaces before the first line
          if (i === 0) {
            if (!stmt.body[0].leadingComments) {
              generateBlankLines(stmt.range[0], stmt.body[i].range[0], result);
            }
          } // handle spaces between lines


          if (i > 0) {
            if (!stmt.body[i - 1].trailingComments && !stmt.body[i].leadingComments) {
              generateBlankLines(stmt.body[i - 1].range[1], stmt.body[i].range[0], result);
            }
          }
        }

        fragment = addIndent(this.generateStatement(stmt.body[i], bodyFlags));
        result.push(fragment);

        if (i + 1 < iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
          if (preserveBlankLines) {
            if (!stmt.body[i + 1].leadingComments) {
              result.push(newline);
            }
          } else {
            result.push(newline);
          }
        }

        if (preserveBlankLines) {
          // handle spaces after the last line
          if (i === iz - 1) {
            if (!stmt.body[i].trailingComments) {
              generateBlankLines(stmt.body[i].range[1], stmt.range[1], result);
            }
          }
        }
      }

      return result;
    },
    FunctionDeclaration: function (stmt, flags) {
      return [generateAsyncPrefix(stmt, true), 'function', generateStarSuffix(stmt) || noEmptySpace(), stmt.id ? generateIdentifier(stmt.id) : '', this.generateFunctionBody(stmt)];
    },
    ReturnStatement: function (stmt, flags) {
      if (stmt.argument) {
        return [join('return', this.generateExpression(stmt.argument, Precedence.Sequence, E_TTT)), this.semicolon(flags)];
      }

      return ['return' + this.semicolon(flags)];
    },
    WhileStatement: function (stmt, flags) {
      var result,
          that = this;
      withIndent(function () {
        result = ['while' + space + '(', that.generateExpression(stmt.test, Precedence.Sequence, E_TTT), ')'];
      });
      result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));
      return result;
    },
    WithStatement: function (stmt, flags) {
      var result,
          that = this;
      withIndent(function () {
        result = ['with' + space + '(', that.generateExpression(stmt.object, Precedence.Sequence, E_TTT), ')'];
      });
      result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));
      return result;
    }
  };
  merge(CodeGenerator.prototype, CodeGenerator.Statement); // Expressions.

  CodeGenerator.Expression = {
    SequenceExpression: function (expr, precedence, flags) {
      var result, i, iz;

      if (Precedence.Sequence < precedence) {
        flags |= F_ALLOW_IN;
      }

      result = [];

      for (i = 0, iz = expr.expressions.length; i < iz; ++i) {
        result.push(this.generateExpression(expr.expressions[i], Precedence.Assignment, flags));

        if (i + 1 < iz) {
          result.push(',' + space);
        }
      }

      return parenthesize(result, Precedence.Sequence, precedence);
    },
    AssignmentExpression: function (expr, precedence, flags) {
      return this.generateAssignment(expr.left, expr.right, expr.operator, precedence, flags);
    },
    ArrowFunctionExpression: function (expr, precedence, flags) {
      return parenthesize(this.generateFunctionBody(expr), Precedence.ArrowFunction, precedence);
    },
    ConditionalExpression: function (expr, precedence, flags) {
      if (Precedence.Conditional < precedence) {
        flags |= F_ALLOW_IN;
      }

      return parenthesize([this.generateExpression(expr.test, Precedence.LogicalOR, flags), space + '?' + space, this.generateExpression(expr.consequent, Precedence.Assignment, flags), space + ':' + space, this.generateExpression(expr.alternate, Precedence.Assignment, flags)], Precedence.Conditional, precedence);
    },
    LogicalExpression: function (expr, precedence, flags) {
      return this.BinaryExpression(expr, precedence, flags);
    },
    BinaryExpression: function (expr, precedence, flags) {
      var result, leftPrecedence, rightPrecedence, currentPrecedence, fragment, leftSource;
      currentPrecedence = BinaryPrecedence[expr.operator];
      leftPrecedence = expr.operator === '**' ? Precedence.Postfix : currentPrecedence;
      rightPrecedence = expr.operator === '**' ? currentPrecedence : currentPrecedence + 1;

      if (currentPrecedence < precedence) {
        flags |= F_ALLOW_IN;
      }

      fragment = this.generateExpression(expr.left, leftPrecedence, flags);
      leftSource = fragment.toString();

      if (leftSource.charCodeAt(leftSource.length - 1) === 0x2F
      /* / */
      && esutils.code.isIdentifierPartES5(expr.operator.charCodeAt(0))) {
        result = [fragment, noEmptySpace(), expr.operator];
      } else {
        result = join(fragment, expr.operator);
      }

      fragment = this.generateExpression(expr.right, rightPrecedence, flags);

      if (expr.operator === '/' && fragment.toString().charAt(0) === '/' || expr.operator.slice(-1) === '<' && fragment.toString().slice(0, 3) === '!--') {
        // If '/' concats with '/' or `<` concats with `!--`, it is interpreted as comment start
        result.push(noEmptySpace());
        result.push(fragment);
      } else {
        result = join(result, fragment);
      }

      if (expr.operator === 'in' && !(flags & F_ALLOW_IN)) {
        return ['(', result, ')'];
      }

      return parenthesize(result, currentPrecedence, precedence);
    },
    CallExpression: function (expr, precedence, flags) {
      var result, i, iz; // F_ALLOW_UNPARATH_NEW becomes false.

      result = [this.generateExpression(expr.callee, Precedence.Call, E_TTF)];

      if (expr.optional) {
        result.push('?.');
      }

      result.push('(');

      for (i = 0, iz = expr['arguments'].length; i < iz; ++i) {
        result.push(this.generateExpression(expr['arguments'][i], Precedence.Assignment, E_TTT));

        if (i + 1 < iz) {
          result.push(',' + space);
        }
      }

      result.push(')');

      if (!(flags & F_ALLOW_CALL)) {
        return ['(', result, ')'];
      }

      return parenthesize(result, Precedence.Call, precedence);
    },
    ChainExpression: function (expr, precedence, flags) {
      if (Precedence.OptionalChaining < precedence) {
        flags |= F_ALLOW_CALL;
      }

      var result = this.generateExpression(expr.expression, Precedence.OptionalChaining, flags);
      return parenthesize(result, Precedence.OptionalChaining, precedence);
    },
    NewExpression: function (expr, precedence, flags) {
      var result, length, i, iz, itemFlags;
      length = expr['arguments'].length; // F_ALLOW_CALL becomes false.
      // F_ALLOW_UNPARATH_NEW may become false.

      itemFlags = flags & F_ALLOW_UNPARATH_NEW && !parentheses && length === 0 ? E_TFT : E_TFF;
      result = join('new', this.generateExpression(expr.callee, Precedence.New, itemFlags));

      if (!(flags & F_ALLOW_UNPARATH_NEW) || parentheses || length > 0) {
        result.push('(');

        for (i = 0, iz = length; i < iz; ++i) {
          result.push(this.generateExpression(expr['arguments'][i], Precedence.Assignment, E_TTT));

          if (i + 1 < iz) {
            result.push(',' + space);
          }
        }

        result.push(')');
      }

      return parenthesize(result, Precedence.New, precedence);
    },
    MemberExpression: function (expr, precedence, flags) {
      var result, fragment; // F_ALLOW_UNPARATH_NEW becomes false.

      result = [this.generateExpression(expr.object, Precedence.Call, flags & F_ALLOW_CALL ? E_TTF : E_TFF)];

      if (expr.computed) {
        if (expr.optional) {
          result.push('?.');
        }

        result.push('[');
        result.push(this.generateExpression(expr.property, Precedence.Sequence, flags & F_ALLOW_CALL ? E_TTT : E_TFT));
        result.push(']');
      } else {
        if (!expr.optional && expr.object.type === Syntax.Literal && typeof expr.object.value === 'number') {
          fragment = toSourceNodeWhenNeeded(result).toString(); // When the following conditions are all true,
          //   1. No floating point
          //   2. Don't have exponents
          //   3. The last character is a decimal digit
          //   4. Not hexadecimal OR octal number literal
          // we should add a floating point.

          if (fragment.indexOf('.') < 0 && !/[eExX]/.test(fragment) && esutils.code.isDecimalDigit(fragment.charCodeAt(fragment.length - 1)) && !(fragment.length >= 2 && fragment.charCodeAt(0) === 48) // '0'
          ) {
              result.push(' ');
            }
        }

        result.push(expr.optional ? '?.' : '.');
        result.push(generateIdentifier(expr.property));
      }

      return parenthesize(result, Precedence.Member, precedence);
    },
    MetaProperty: function (expr, precedence, flags) {
      var result;
      result = [];
      result.push(typeof expr.meta === "string" ? expr.meta : generateIdentifier(expr.meta));
      result.push('.');
      result.push(typeof expr.property === "string" ? expr.property : generateIdentifier(expr.property));
      return parenthesize(result, Precedence.Member, precedence);
    },
    UnaryExpression: function (expr, precedence, flags) {
      var result, fragment, rightCharCode, leftSource, leftCharCode;
      fragment = this.generateExpression(expr.argument, Precedence.Unary, E_TTT);

      if (space === '') {
        result = join(expr.operator, fragment);
      } else {
        result = [expr.operator];

        if (expr.operator.length > 2) {
          // delete, void, typeof
          // get `typeof []`, not `typeof[]`
          result = join(result, fragment);
        } else {
          // Prevent inserting spaces between operator and argument if it is unnecessary
          // like, `!cond`
          leftSource = toSourceNodeWhenNeeded(result).toString();
          leftCharCode = leftSource.charCodeAt(leftSource.length - 1);
          rightCharCode = fragment.toString().charCodeAt(0);

          if ((leftCharCode === 0x2B
          /* + */
          || leftCharCode === 0x2D
          /* - */
          ) && leftCharCode === rightCharCode || esutils.code.isIdentifierPartES5(leftCharCode) && esutils.code.isIdentifierPartES5(rightCharCode)) {
            result.push(noEmptySpace());
            result.push(fragment);
          } else {
            result.push(fragment);
          }
        }
      }

      return parenthesize(result, Precedence.Unary, precedence);
    },
    YieldExpression: function (expr, precedence, flags) {
      var result;

      if (expr.delegate) {
        result = 'yield*';
      } else {
        result = 'yield';
      }

      if (expr.argument) {
        result = join(result, this.generateExpression(expr.argument, Precedence.Yield, E_TTT));
      }

      return parenthesize(result, Precedence.Yield, precedence);
    },
    AwaitExpression: function (expr, precedence, flags) {
      var result = join(expr.all ? 'await*' : 'await', this.generateExpression(expr.argument, Precedence.Await, E_TTT));
      return parenthesize(result, Precedence.Await, precedence);
    },
    UpdateExpression: function (expr, precedence, flags) {
      if (expr.prefix) {
        return parenthesize([expr.operator, this.generateExpression(expr.argument, Precedence.Unary, E_TTT)], Precedence.Unary, precedence);
      }

      return parenthesize([this.generateExpression(expr.argument, Precedence.Postfix, E_TTT), expr.operator], Precedence.Postfix, precedence);
    },
    FunctionExpression: function (expr, precedence, flags) {
      var result = [generateAsyncPrefix(expr, true), 'function'];

      if (expr.id) {
        result.push(generateStarSuffix(expr) || noEmptySpace());
        result.push(generateIdentifier(expr.id));
      } else {
        result.push(generateStarSuffix(expr) || space);
      }

      result.push(this.generateFunctionBody(expr));
      return result;
    },
    ArrayPattern: function (expr, precedence, flags) {
      return this.ArrayExpression(expr, precedence, flags, true);
    },
    ArrayExpression: function (expr, precedence, flags, isPattern) {
      var result,
          multiline,
          that = this;

      if (!expr.elements.length) {
        return '[]';
      }

      multiline = isPattern ? false : expr.elements.length > 1;
      result = ['[', multiline ? newline : ''];
      withIndent(function (indent) {
        var i, iz;

        for (i = 0, iz = expr.elements.length; i < iz; ++i) {
          if (!expr.elements[i]) {
            if (multiline) {
              result.push(indent);
            }

            if (i + 1 === iz) {
              result.push(',');
            }
          } else {
            result.push(multiline ? indent : '');
            result.push(that.generateExpression(expr.elements[i], Precedence.Assignment, E_TTT));
          }

          if (i + 1 < iz) {
            result.push(',' + (multiline ? newline : space));
          }
        }
      });

      if (multiline && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
        result.push(newline);
      }

      result.push(multiline ? base : '');
      result.push(']');
      return result;
    },
    RestElement: function (expr, precedence, flags) {
      return '...' + this.generatePattern(expr.argument);
    },
    ClassExpression: function (expr, precedence, flags) {
      var result, fragment;
      result = ['class'];

      if (expr.id) {
        result = join(result, this.generateExpression(expr.id, Precedence.Sequence, E_TTT));
      }

      if (expr.superClass) {
        fragment = join('extends', this.generateExpression(expr.superClass, Precedence.Unary, E_TTT));
        result = join(result, fragment);
      }

      result.push(space);
      result.push(this.generateStatement(expr.body, S_TFFT));
      return result;
    },
    MethodDefinition: function (expr, precedence, flags) {
      var result, fragment;

      if (expr['static']) {
        result = ['static' + space];
      } else {
        result = [];
      }

      if (expr.kind === 'get' || expr.kind === 'set') {
        fragment = [join(expr.kind, this.generatePropertyKey(expr.key, expr.computed)), this.generateFunctionBody(expr.value)];
      } else {
        fragment = [generateMethodPrefix(expr), this.generatePropertyKey(expr.key, expr.computed), this.generateFunctionBody(expr.value)];
      }

      return join(result, fragment);
    },
    Property: function (expr, precedence, flags) {
      if (expr.kind === 'get' || expr.kind === 'set') {
        return [expr.kind, noEmptySpace(), this.generatePropertyKey(expr.key, expr.computed), this.generateFunctionBody(expr.value)];
      }

      if (expr.shorthand) {
        if (expr.value.type === "AssignmentPattern") {
          return this.AssignmentPattern(expr.value, Precedence.Sequence, E_TTT);
        }

        return this.generatePropertyKey(expr.key, expr.computed);
      }

      if (expr.method) {
        return [generateMethodPrefix(expr), this.generatePropertyKey(expr.key, expr.computed), this.generateFunctionBody(expr.value)];
      }

      return [this.generatePropertyKey(expr.key, expr.computed), ':' + space, this.generateExpression(expr.value, Precedence.Assignment, E_TTT)];
    },
    ObjectExpression: function (expr, precedence, flags) {
      var multiline,
          result,
          fragment,
          that = this;

      if (!expr.properties.length) {
        return '{}';
      }

      multiline = expr.properties.length > 1;
      withIndent(function () {
        fragment = that.generateExpression(expr.properties[0], Precedence.Sequence, E_TTT);
      });

      if (!multiline) {
        // issues 4
        // Do not transform from
        //   dejavu.Class.declare({
        //       method2: function () {}
        //   });
        // to
        //   dejavu.Class.declare({method2: function () {
        //       }});
        if (!hasLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
          return ['{', space, fragment, space, '}'];
        }
      }

      withIndent(function (indent) {
        var i, iz;
        result = ['{', newline, indent, fragment];

        if (multiline) {
          result.push(',' + newline);

          for (i = 1, iz = expr.properties.length; i < iz; ++i) {
            result.push(indent);
            result.push(that.generateExpression(expr.properties[i], Precedence.Sequence, E_TTT));

            if (i + 1 < iz) {
              result.push(',' + newline);
            }
          }
        }
      });

      if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
        result.push(newline);
      }

      result.push(base);
      result.push('}');
      return result;
    },
    AssignmentPattern: function (expr, precedence, flags) {
      return this.generateAssignment(expr.left, expr.right, '=', precedence, flags);
    },
    ObjectPattern: function (expr, precedence, flags) {
      var result,
          i,
          iz,
          multiline,
          property,
          that = this;

      if (!expr.properties.length) {
        return '{}';
      }

      multiline = false;

      if (expr.properties.length === 1) {
        property = expr.properties[0];

        if (property.type === Syntax.Property && property.value.type !== Syntax.Identifier) {
          multiline = true;
        }
      } else {
        for (i = 0, iz = expr.properties.length; i < iz; ++i) {
          property = expr.properties[i];

          if (property.type === Syntax.Property && !property.shorthand) {
            multiline = true;
            break;
          }
        }
      }

      result = ['{', multiline ? newline : ''];
      withIndent(function (indent) {
        var i, iz;

        for (i = 0, iz = expr.properties.length; i < iz; ++i) {
          result.push(multiline ? indent : '');
          result.push(that.generateExpression(expr.properties[i], Precedence.Sequence, E_TTT));

          if (i + 1 < iz) {
            result.push(',' + (multiline ? newline : space));
          }
        }
      });

      if (multiline && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
        result.push(newline);
      }

      result.push(multiline ? base : '');
      result.push('}');
      return result;
    },
    ThisExpression: function (expr, precedence, flags) {
      return 'this';
    },
    Super: function (expr, precedence, flags) {
      return 'super';
    },
    Identifier: function (expr, precedence, flags) {
      return generateIdentifier(expr);
    },
    ImportDefaultSpecifier: function (expr, precedence, flags) {
      return generateIdentifier(expr.id || expr.local);
    },
    ImportNamespaceSpecifier: function (expr, precedence, flags) {
      var result = ['*'];
      var id = expr.id || expr.local;

      if (id) {
        result.push(space + 'as' + noEmptySpace() + generateIdentifier(id));
      }

      return result;
    },
    ImportSpecifier: function (expr, precedence, flags) {
      var imported = expr.imported;
      var result = [imported.name];
      var local = expr.local;

      if (local && local.name !== imported.name) {
        result.push(noEmptySpace() + 'as' + noEmptySpace() + generateIdentifier(local));
      }

      return result;
    },
    ExportSpecifier: function (expr, precedence, flags) {
      var local = expr.local;
      var result = [local.name];
      var exported = expr.exported;

      if (exported && exported.name !== local.name) {
        result.push(noEmptySpace() + 'as' + noEmptySpace() + generateIdentifier(exported));
      }

      return result;
    },
    Literal: function (expr, precedence, flags) {
      var raw;

      if (expr.hasOwnProperty('raw') && parse && extra.raw) {
        try {
          raw = parse(expr.raw).body[0].expression;

          if (raw.type === Syntax.Literal) {
            if (raw.value === expr.value) {
              return expr.raw;
            }
          }
        } catch (e) {// not use raw property
        }
      }

      if (expr.regex) {
        return '/' + expr.regex.pattern + '/' + expr.regex.flags;
      }

      if (expr.value === null) {
        return 'null';
      }

      if (typeof expr.value === 'string') {
        return escapeString(expr.value);
      }

      if (typeof expr.value === 'number') {
        return generateNumber(expr.value);
      }

      if (typeof expr.value === 'boolean') {
        return expr.value ? 'true' : 'false';
      }

      return generateRegExp(expr.value);
    },
    GeneratorExpression: function (expr, precedence, flags) {
      return this.ComprehensionExpression(expr, precedence, flags);
    },
    ComprehensionExpression: function (expr, precedence, flags) {
      // GeneratorExpression should be parenthesized with (...), ComprehensionExpression with [...]
      // Due to https://bugzilla.mozilla.org/show_bug.cgi?id=883468 position of expr.body can differ in Spidermonkey and ES6
      var result,
          i,
          iz,
          fragment,
          that = this;
      result = expr.type === Syntax.GeneratorExpression ? ['('] : ['['];

      if (extra.moz.comprehensionExpressionStartsWithAssignment) {
        fragment = this.generateExpression(expr.body, Precedence.Assignment, E_TTT);
        result.push(fragment);
      }

      if (expr.blocks) {
        withIndent(function () {
          for (i = 0, iz = expr.blocks.length; i < iz; ++i) {
            fragment = that.generateExpression(expr.blocks[i], Precedence.Sequence, E_TTT);

            if (i > 0 || extra.moz.comprehensionExpressionStartsWithAssignment) {
              result = join(result, fragment);
            } else {
              result.push(fragment);
            }
          }
        });
      }

      if (expr.filter) {
        result = join(result, 'if' + space);
        fragment = this.generateExpression(expr.filter, Precedence.Sequence, E_TTT);
        result = join(result, ['(', fragment, ')']);
      }

      if (!extra.moz.comprehensionExpressionStartsWithAssignment) {
        fragment = this.generateExpression(expr.body, Precedence.Assignment, E_TTT);
        result = join(result, fragment);
      }

      result.push(expr.type === Syntax.GeneratorExpression ? ')' : ']');
      return result;
    },
    ComprehensionBlock: function (expr, precedence, flags) {
      var fragment;

      if (expr.left.type === Syntax.VariableDeclaration) {
        fragment = [expr.left.kind, noEmptySpace(), this.generateStatement(expr.left.declarations[0], S_FFFF)];
      } else {
        fragment = this.generateExpression(expr.left, Precedence.Call, E_TTT);
      }

      fragment = join(fragment, expr.of ? 'of' : 'in');
      fragment = join(fragment, this.generateExpression(expr.right, Precedence.Sequence, E_TTT));
      return ['for' + space + '(', fragment, ')'];
    },
    SpreadElement: function (expr, precedence, flags) {
      return ['...', this.generateExpression(expr.argument, Precedence.Assignment, E_TTT)];
    },
    TaggedTemplateExpression: function (expr, precedence, flags) {
      var itemFlags = E_TTF;

      if (!(flags & F_ALLOW_CALL)) {
        itemFlags = E_TFF;
      }

      var result = [this.generateExpression(expr.tag, Precedence.Call, itemFlags), this.generateExpression(expr.quasi, Precedence.Primary, E_FFT)];
      return parenthesize(result, Precedence.TaggedTemplate, precedence);
    },
    TemplateElement: function (expr, precedence, flags) {
      // Don't use "cooked". Since tagged template can use raw template
      // representation. So if we do so, it breaks the script semantics.
      return expr.value.raw;
    },
    TemplateLiteral: function (expr, precedence, flags) {
      var result, i, iz;
      result = ['`'];

      for (i = 0, iz = expr.quasis.length; i < iz; ++i) {
        result.push(this.generateExpression(expr.quasis[i], Precedence.Primary, E_TTT));

        if (i + 1 < iz) {
          result.push('${' + space);
          result.push(this.generateExpression(expr.expressions[i], Precedence.Sequence, E_TTT));
          result.push(space + '}');
        }
      }

      result.push('`');
      return result;
    },
    ModuleSpecifier: function (expr, precedence, flags) {
      return this.Literal(expr, precedence, flags);
    },
    ImportExpression: function (expr, precedence, flag) {
      return parenthesize(['import(', this.generateExpression(expr.source, Precedence.Assignment, E_TTT), ')'], Precedence.Call, precedence);
    }
  };
  merge(CodeGenerator.prototype, CodeGenerator.Expression);

  CodeGenerator.prototype.generateExpression = function (expr, precedence, flags) {
    var result, type;
    type = expr.type || Syntax.Property;

    if (extra.verbatim && expr.hasOwnProperty(extra.verbatim)) {
      return generateVerbatim(expr, precedence);
    }

    result = this[type](expr, precedence, flags);

    if (extra.comment) {
      result = addComments(expr, result);
    }

    return toSourceNodeWhenNeeded(result, expr);
  };

  CodeGenerator.prototype.generateStatement = function (stmt, flags) {
    var result, fragment;
    result = this[stmt.type](stmt, flags); // Attach comments

    if (extra.comment) {
      result = addComments(stmt, result);
    }

    fragment = toSourceNodeWhenNeeded(result).toString();

    if (stmt.type === Syntax.Program && !safeConcatenation && newline === '' && fragment.charAt(fragment.length - 1) === '\n') {
      result = sourceMap ? toSourceNodeWhenNeeded(result).replaceRight(/\s+$/, '') : fragment.replace(/\s+$/, '');
    }

    return toSourceNodeWhenNeeded(result, stmt);
  };

  function generateInternal(node) {
    var codegen;
    codegen = new CodeGenerator();

    if (isStatement(node)) {
      return codegen.generateStatement(node, S_TFFF);
    }

    if (isExpression(node)) {
      return codegen.generateExpression(node, Precedence.Sequence, E_TTT);
    }

    throw new Error('Unknown node type: ' + node.type);
  }

  function generate(node, options) {
    var defaultOptions = getDefaultOptions(),
        result,
        pair;

    if (options != null) {
      // Obsolete options
      //
      //   `options.indent`
      //   `options.base`
      //
      // Instead of them, we can use `option.format.indent`.
      if (typeof options.indent === 'string') {
        defaultOptions.format.indent.style = options.indent;
      }

      if (typeof options.base === 'number') {
        defaultOptions.format.indent.base = options.base;
      }

      options = updateDeeply(defaultOptions, options);
      indent = options.format.indent.style;

      if (typeof options.base === 'string') {
        base = options.base;
      } else {
        base = stringRepeat(indent, options.format.indent.base);
      }
    } else {
      options = defaultOptions;
      indent = options.format.indent.style;
      base = stringRepeat(indent, options.format.indent.base);
    }

    json = options.format.json;
    renumber = options.format.renumber;
    hexadecimal = json ? false : options.format.hexadecimal;
    quotes = json ? 'double' : options.format.quotes;
    escapeless = options.format.escapeless;
    newline = options.format.newline;
    space = options.format.space;

    if (options.format.compact) {
      newline = space = indent = base = '';
    }

    parentheses = options.format.parentheses;
    semicolons = options.format.semicolons;
    safeConcatenation = options.format.safeConcatenation;
    directive = options.directive;
    parse = json ? null : options.parse;
    sourceMap = options.sourceMap;
    sourceCode = options.sourceCode;
    preserveBlankLines = options.format.preserveBlankLines && sourceCode !== null;
    extra = options;

    if (sourceMap) {
      if (!exports.browser) {
        // We assume environment is node.js
        // And prevent from including source-map by browserify
        SourceNode = require('source-map').SourceNode;
      } else {
        SourceNode = global.sourceMap.SourceNode;
      }
    }

    result = generateInternal(node);

    if (!sourceMap) {
      pair = {
        code: result.toString(),
        map: null
      };
      return options.sourceMapWithCode ? pair : pair.code;
    }

    pair = result.toStringWithSourceMap({
      file: options.file,
      sourceRoot: options.sourceMapRoot
    });

    if (options.sourceContent) {
      pair.map.setSourceContent(options.sourceMap, options.sourceContent);
    }

    if (options.sourceMapWithCode) {
      return pair;
    }

    return pair.map.toString();
  }

  FORMAT_MINIFY = {
    indent: {
      style: '',
      base: 0
    },
    renumber: true,
    hexadecimal: true,
    quotes: 'auto',
    escapeless: true,
    compact: true,
    parentheses: false,
    semicolons: false
  };
  FORMAT_DEFAULTS = getDefaultOptions().format;
  exports.version = require('./package.json').version;
  exports.generate = generate;
  exports.attachComments = estraverse.attachComments;
  exports.Precedence = updateDeeply({}, Precedence);
  exports.browser = false;
  exports.FORMAT_MINIFY = FORMAT_MINIFY;
  exports.FORMAT_DEFAULTS = FORMAT_DEFAULTS;
})();
/* vim: set sw=4 ts=4 et tw=80 : */
},{"estraverse":"KZbn","esutils":"G2Da","source-map":"jJWO","./package.json":"RyXu"}],"IUmA":[function(require,module,exports) {
"use strict";

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const traverse_1 = require("@glas/traverse");

const escodegen_1 = __importDefault(require("escodegen"));

function codegen(root, options) {
  return traverse_1.traverse(root, {
    enter(node) {
      if (node.type === "Program") {
        return traverse_1.skip;
      }
    },

    leave(node) {
      if (node.type === "Program") {
        return escodegen_1.default.generate(node);
      }
    }

  });
}

exports.default = codegen;
},{"@glas/traverse":"bYRw","escodegen":"vqOD"}],"RhB4":[function(require,module,exports) {
"use strict";

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const traverse_1 = require("@glas/traverse");

const ast_1 = require("../ast");

const Position_1 = __importDefault(require("../ast/Position"));

const VariableDeclaration_1 = __importDefault(require("../ast/VariableDeclaration"));

const MemberExpression_1 = __importDefault(require("../ast/MemberExpression"));

const Expression_1 = __importDefault(require("../ast/Expression"));

const ClassDeclaration_1 = __importDefault(require("../ast/ClassDeclaration"));

const AssignmentStatement_1 = __importDefault(require("../ast/AssignmentStatement"));

const common_1 = require("../common");

const operatorMap = {
  "==": "==="
};

function toEsTree(root, options) {
  return traverse_1.traverse(root, {
    enter(node) {
      if (Position_1.default.is(node)) {
        return traverse_1.skip;
      }
    },

    merge(node, changes, helper) {
      var _a, _b, _c;

      if (ast_1.Node.is(node)) {
        // convert negative literal number to unary negation
        if (ast_1.Literal.is(node) && typeof node.value === "number" && node.value < 0) {
          return {
            type: "UnaryExpression",
            operator: "-",
            prefix: true,
            argument: {
              type: "Literal",
              value: Math.abs(node.value)
            }
          };
        } //  Convert Reference and Declarators to Identifier
        //  (They are both Identifier subclasses)


        if (ast_1.Identifier.is(node)) {
          return {
            type: "Identifier",
            name: node.name
          };
        } // Our VariableDeclarations diverge from ESTree for simplicity so we convert back.


        let result;

        if (VariableDeclaration_1.default.is(node)) {
          let values = { ...node,
            ...changes
          };
          result = {
            type: "VariableDeclaration",
            kind: node.kind === "conditional" ? node.kind : node.kind === "var" ? "let" : "const",
            declarations: [{
              type: "VariableDeclarator",
              id: values.id,
              init: values.value,
              kind: node.kind
            }]
          };
        } else if (AssignmentStatement_1.default.is(node)) {
          let values = { ...node,
            ...changes
          };
          result = {
            type: "ExpressionStatement",
            expression: {
              type: "AssignmentExpression",
              left: values.left,
              operator: values.operator,
              right: values.right
            }
          };
        } else if (ast_1.Parameter.is(node)) {
          if (node.value != null) {
            result = {
              type: "AssignmentPattern",
              left: changes.id,
              right: changes.value
            };
          } else {
            result = changes.id;
          }
        } else if (ast_1.RegularExpression.is(node)) {
          try {
            return {
              type: "Literal",
              value: new RegExp(node.pattern, node.flags)
            };
          } catch (e) {
            throw common_1.SemanticError(e.message, node);
          }
        } else {
          result = { ...node,
            ...changes,
            type: node.constructor.name
          };
        } //  convert UnaryExpressions to UpdateExpressions if they use ++ or --


        if (ast_1.UnaryExpression.is(node) && (node.operator === "++" || node.operator === "--")) {
          result.type = "UpdateExpression";
        } // Add computed to MemberExpressions with Expressions as their property.


        if (MemberExpression_1.default.is(node) && Expression_1.default.is(node.property)) {
          result.computed = true;
        }

        if (ast_1.BinaryExpression.is(node)) {
          result.operator = (_a = operatorMap[node.operator]) !== null && _a !== void 0 ? _a : node.operator;
        }

        if (ast_1.SwitchCase.is(node)) {
          // EsTree SwitchCase.consequent: Array<Statement>
          // Ours is BlockStatement, so we convert to theirs.
          result.consequent = (_c = (_b = result.consequent) === null || _b === void 0 ? void 0 : _b.body) !== null && _c !== void 0 ? _c : [];
        }

        if (ast_1.CallExpression.is(node) && node.new) {
          result.type = "NewExpression";
        }

        if (ClassDeclaration_1.default.is(node)) {
          let values = { ...node,
            ...changes
          };
          let declarations = [...values.instance.declarations, ...values.static];
          let originals = [...node.instance.declarations, ...node.static];
          result = {
            type: "ClassDeclaration",
            id: values.id,
            superClass: values.baseClasses[0],
            body: {
              type: "ClassBody",
              body: declarations.map((v, index) => {
                let original = originals[index];

                if (!ast_1.FunctionExpression.is(original.value)) {
                  return null;
                }

                let d = v.declarations[0];
                return {
                  type: "MethodDefinition",
                  key: d.id,
                  value: d.init,
                  kind: (() => {
                    switch (d.kind) {
                      case "let":
                      case "var":
                        return "method";

                      case "get":
                        return "get";

                      case "set":
                        return "set";
                    }
                  })(),
                  //  calculate if computed or not
                  computed: Expression_1.default.is(original.id),
                  static: original.static
                };
              }).filter(value => value != null)
            }
          };
        } // finally, handle exports


        if (ast_1.Exportable.is(node) && node.export > 0) {
          if (ast_1.ImportDeclaration.is(node)) {
            result = traverse_1.replace({
              type: "ExpressionStatement",
              expression: {
                type: "Literal",
                value: "Fuck"
              }
            }, {
              type: "ExpressionStatement",
              expression: {
                type: "Literal",
                value: "You"
              }
            });
          } else {
            if (node.export === 2) {
              result = {
                type: "ExportDefaultDeclaration",
                declaration: VariableDeclaration_1.default.is(node) ? result.declarations[0].init : result,
                specifiers: [],
                source: null
              };
            } else {
              result = {
                type: "ExportNamedDeclaration",
                declaration: result,
                specifiers: [],
                source: null
              };
            }
          }
        }

        return result;
      }
    }

  });
}

exports.default = toEsTree;
},{"@glas/traverse":"bYRw","../ast":"tHlf","../ast/Position":"CUCB","../ast/VariableDeclaration":"KDXm","../ast/MemberExpression":"Ukrj","../ast/Expression":"zMtI","../ast/ClassDeclaration":"b3SL","../ast/AssignmentStatement":"IblK","../common":"gPgA"}],"eqB6":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

const path_1 = require("path");

const common_1 = require("../common");

function writeFiles(output, options) {
  for (let path of output.modules.keys()) {
    let content = output.modules.get(path);
    common_1.write(path_1.join(options.output, path.slice(options.namespace.length + 1)), content);
  }

  return null;
}

exports.default = writeFiles;
},{"path":"FHml","../common":"gPgA"}],"LRkx":[function(require,module,exports) {
"use strict";

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const traverse_1 = require("@glas/traverse");

const ast_1 = require("../ast");

const ArrowFunctionExpression_1 = __importDefault(require("../ast/ArrowFunctionExpression"));

const PropertyStatement_1 = __importDefault(require("../ast/PropertyStatement"));

const AssignmentStatement_1 = __importDefault(require("../ast/AssignmentStatement"));

const common_1 = require("../common");

function convertExpressionWithNestedStatements(node) {
  const {
    location
  } = node;
  const containerName = "$";
  const containerRef = new ast_1.Reference({
    location,
    name: containerName
  });
  const containerId = new ast_1.Declarator({
    location,
    name: containerName
  });
  const isObjectExpression = ast_1.ObjectExpression.is(node);
  const isMap = isObjectExpression && node.isMap;
  const isArrayExpression = ast_1.ArrayExpression.is(node);
  const isSet = isArrayExpression && node.isSet;

  if (isObjectExpression && node.properties.find(ast_1.Statement.is)) {
    return new ast_1.CallExpression({
      location,
      callee: new ArrowFunctionExpression_1.default({
        params: [new ast_1.Parameter({
          location,
          id: containerId
        })],
        expression: false,
        body: new ast_1.BlockStatement({
          location,
          body: traverse_1.traverse(node.properties, {
            enter(e) {
              //  don't traverse into call expressions
              //  also don't recurse into expressions or expression statements
              //  basically we only want to recurse into control flow statements
              if (ast_1.CallExpression.is(e) || ast_1.Expression.is(e) || ast_1.ExpressionStatement.is(e)) {
                return traverse_1.skip;
              }
            },

            leave(e, ancestors, path) {
              //  if this is an immediate child expression we treat it as a statement
              //  so it gets converted to an ExpressionStatement down below.
              let parent = ancestors[ancestors.length - 1];

              if (PropertyStatement_1.default.is(e)) {
                e = e.property;
              }

              if (ast_1.Property.is(e) && Array.isArray(parent)) {
                if (isMap) {
                  let {
                    key,
                    value
                  } = e;

                  if (ast_1.Identifier.is(key)) {
                    //  keys are always computed for Maps.
                    key = new ast_1.Reference(key);
                  }

                  return new ast_1.ExpressionStatement({
                    expression: new ast_1.CallExpression({
                      location,
                      callee: new ast_1.MemberExpression({
                        location,
                        object: containerRef,
                        property: new ast_1.Identifier({
                          location,
                          name: "set"
                        })
                      }),
                      arguments: [e.key, e.value]
                    })
                  });
                } else {
                  return new AssignmentStatement_1.default({
                    location,
                    left: new ast_1.MemberExpression({
                      location,
                      object: containerRef,
                      property: e.key
                    }),
                    operator: "=",
                    right: e.value
                  });
                }
              }
            }

          }).concat([new ast_1.ReturnStatement({
            location,
            argument: containerRef
          })])
        })
      }),
      arguments: [isMap ? new ast_1.CallExpression({
        location,
        new: true,
        callee: new ast_1.Reference({
          location,
          name: "Map"
        }),
        arguments: []
      }) : new ast_1.ObjectExpression({
        location,
        properties: []
      })]
    });
  } else if (isMap) {
    return new ast_1.CallExpression({
      location,
      new: true,
      callee: new ast_1.Reference({
        location,
        name: "Map"
      }),
      arguments: [new ast_1.ArrayExpression({
        location,
        elements: node.properties.map(({
          key,
          value
        }) => new ast_1.ArrayExpression({
          location,
          elements: [key, value]
        }))
      })]
    });
  } else if (isArrayExpression && node.elements.find(ast_1.Statement.is)) {
    //  TODO: extend ionscript.add to handle Sets and convert to use it.
    const push = new ast_1.Identifier({
      location,
      name: isSet ? "add" : "push"
    });
    const mergePushElementsWithNext = new Array();
    return new ast_1.CallExpression({
      location,
      callee: new ArrowFunctionExpression_1.default({
        location,
        params: [new ast_1.Parameter({
          location,
          id: containerId
        })],
        expression: false,
        body: new ast_1.BlockStatement({
          location,
          body: traverse_1.traverse(node.elements, {
            enter(e) {
              //  don't traverse into call expressions
              //  also don't recurse into expressions or expression statements
              //  basically we only want to recurse into control flow statements
              if (ast_1.CallExpression.is(e) || ast_1.Expression.is(e) || ast_1.ExpressionStatement.is(e)) {
                return traverse_1.skip;
              }
            },

            leave(e, ancestors, path) {
              //  if this is an immediate child expression we treat it as a statement
              //  so it gets converted to an ExpressionStatement down below.
              let parent = ancestors[ancestors.length - 1];
              let statement = parent === node.elements;

              if (ast_1.ExpressionStatement.is(e)) {
                e = e.expression;
                statement = true;
              }

              if ((ast_1.Expression.is(e) || ast_1.SpreadElement.is(e)) && Array.isArray(parent)) {
                // see if the next peer element is an expression or expression statement
                let mergeWithNext = false;

                if (!isSet) {
                  let nextPeer = ancestors[ancestors.length - 1][path[path.length - 1] + 1];
                  if (ast_1.Expression.is(nextPeer) || ast_1.SpreadElement.is(nextPeer) || ast_1.ExpressionStatement.is(nextPeer)) mergeWithNext = true;
                }

                if (mergeWithNext) {
                  mergePushElementsWithNext.push(e);
                  return traverse_1.remove;
                }

                let expression = new ast_1.CallExpression({
                  location,
                  callee: new ast_1.MemberExpression({
                    location,
                    object: containerRef,
                    property: push
                  }),
                  arguments: [...mergePushElementsWithNext, e]
                });
                mergePushElementsWithNext.length = 0;
                return statement ? new ast_1.ExpressionStatement({
                  location,
                  expression
                }) : expression;
              }
            }

          }).concat([new ast_1.ReturnStatement({
            location,
            argument: containerRef
          })])
        })
      }),
      arguments: [isSet ? new ast_1.CallExpression({
        location,
        new: true,
        callee: new ast_1.Reference({
          location,
          name: "Set"
        }),
        arguments: []
      }) : new ast_1.ArrayExpression({
        location,
        elements: []
      })]
    });
  } else if (isSet) {
    return new ast_1.CallExpression({
      location,
      new: true,
      callee: new ast_1.Reference({
        location,
        name: "Set"
      }),
      arguments: [node.patch({
        isSet: false
      })]
    });
  } else if (ast_1.ElementExpression.is(node)) {
    let hasNonPropertyStatements = node.children.find(a => ast_1.Statement.is(a) && !PropertyStatement_1.default.is(a)) != null;
    const propertiesName = "$";
    const childrenName = "$$";
    let kind = node.kind; //  lower case references use strings as they represent elements

    if (ast_1.Reference.is(kind) && kind.name[0] === kind.name[0].toLowerCase()) {
      kind = new ast_1.Literal({
        location,
        value: kind.name
      });
    }

    if (hasNonPropertyStatements) {
      const mergePushElementsWithNext = new Array();
      let addedChildren = false;
      return new ast_1.CallExpression({
        location,
        callee: new ArrowFunctionExpression_1.default({
          location,
          params: [new ast_1.Parameter({
            location,
            id: new ast_1.Declarator({
              location,
              name: propertiesName
            })
          }), new ast_1.Parameter({
            location,
            id: new ast_1.Declarator({
              location,
              name: childrenName
            })
          })],
          expression: false,
          body: new ast_1.BlockStatement({
            location,
            body: traverse_1.traverse(node.children, {
              enter(e) {
                //  don't traverse into call expressions
                //  also don't recurse into expressions or expression statements
                //  basically we only want to recurse into control flow statements
                if (ast_1.CallExpression.is(e) || ast_1.Expression.is(e) || ast_1.ExpressionStatement.is(e)) {
                  return traverse_1.skip;
                }
              },

              leave(e, ancestors, path) {
                //  if this is an immediate child expression we treat it as a statement
                //  so it gets converted to an ExpressionStatement down below.
                let parent = ancestors[ancestors.length - 1];

                if (ast_1.ExpressionStatement.is(e)) {
                  e = e.expression;
                }

                if (PropertyStatement_1.default.is(e)) {
                  e = e.property;
                }

                if (ast_1.Property.is(e) && Array.isArray(parent)) {
                  //  we do NOT allow properties to be set AFTER children have been added
                  //  it would make it difficult to differentiate the properties from the children.
                  if (addedChildren) {
                    throw common_1.SemanticError(`Properties must be set before children`, e);
                  }

                  return new AssignmentStatement_1.default({
                    location,
                    left: new ast_1.MemberExpression({
                      location,
                      object: new ast_1.Reference({
                        location,
                        name: propertiesName
                      }),
                      property: e.key
                    }),
                    operator: "=",
                    right: e.value
                  });
                }

                if ((ast_1.Expression.is(e) || ast_1.SpreadElement.is(e)) && Array.isArray(parent)) {
                  addedChildren = true; // see if the next peer element is an expression or expression statement

                  let mergeWithNext = false;

                  if (!isSet) {
                    let nextPeer = ancestors[ancestors.length - 1][path[path.length - 1] + 1];
                    if (ast_1.Expression.is(nextPeer) || ast_1.SpreadElement.is(nextPeer) || ast_1.ExpressionStatement.is(nextPeer)) mergeWithNext = true;
                  }

                  if (mergeWithNext) {
                    mergePushElementsWithNext.push(e);
                    return traverse_1.remove;
                  }

                  let expression = new ast_1.CallExpression({
                    location,
                    callee: new ast_1.MemberExpression({
                      location,
                      object: new ast_1.Reference({
                        location,
                        name: childrenName
                      }),
                      property: new ast_1.Identifier({
                        location,
                        name: "push"
                      })
                    }),
                    arguments: [...mergePushElementsWithNext, e]
                  });
                  mergePushElementsWithNext.length = 0;
                  return new ast_1.ExpressionStatement({
                    location,
                    expression
                  });
                }
              }

            }).concat([new ast_1.ReturnStatement({
              location,
              argument: new ast_1.CallExpression({
                location,
                callee: new ast_1.Reference({
                  location,
                  name: "createElement"
                }),
                arguments: [kind, new ast_1.Reference({
                  location,
                  name: propertiesName
                }), new ast_1.Reference({
                  location,
                  name: childrenName
                })]
              })
            })])
          })
        }),
        arguments: [new ast_1.ObjectExpression({
          location,
          properties: node.properties
        }), new ast_1.ArrayExpression({
          location,
          elements: []
        })]
      });
    } // we are converting this into a simple createElement(kind, properties, ...children) function call


    let properties = [...node.properties];
    let children = [];

    for (let child of node.children) {
      if (PropertyStatement_1.default.is(child)) {
        properties.push(child.property);
      } else {
        if (!(ast_1.Expression.is(child) || ast_1.SpreadElement.is(child))) {
          throw common_1.SemanticError("Expected Expression or SpreadElement", child);
        }

        children.push(child);
      }
    } //  TODO: We should probably just output JSX


    let args = [kind, properties.length > 0 ? new ast_1.ObjectExpression({
      location,
      properties
    }) : new ast_1.Literal({
      location,
      value: null
    }), ...children];
    return new ast_1.CallExpression({
      location,
      callee: new ast_1.Reference({
        location,
        name: "createElement"
      }),
      arguments: args
    });
  }
}

function controlFlowToExpressions(root, options) {
  return traverse_1.traverse(root, {
    enter(node) {},

    leave(node) {
      var _a;

      let {
        location
      } = node;

      if (ast_1.CallExpression.is(node) && node.arguments.find(ast_1.Statement.is)) {
        return node.patch({
          arguments: [new ast_1.SpreadElement({
            location,
            argument: convertExpressionWithNestedStatements(new ast_1.ArrayExpression({
              location,
              elements: node.arguments
            }))
          })]
        });
      }

      if (ast_1.OutlineOperation.is(node)) {
        let {
          operator
        } = node;
        let operands = new ast_1.ArrayExpression({
          location,
          elements: node.operands
        });
        return new ast_1.CallExpression({
          location,
          callee: new ast_1.MemberExpression({
            location,
            object: (_a = convertExpressionWithNestedStatements(operands)) !== null && _a !== void 0 ? _a : operands,
            property: new ast_1.Identifier({
              location,
              name: "reduce"
            })
          }),
          arguments: [new ArrowFunctionExpression_1.default({
            location,
            params: [new ast_1.Parameter({
              location,
              id: new ast_1.Declarator({
                location,
                name: "a"
              })
            }), new ast_1.Parameter({
              location,
              id: new ast_1.Declarator({
                location,
                name: "c"
              })
            })],
            body: new ast_1.BinaryExpression({
              location,
              left: new ast_1.Reference({
                location,
                name: "a"
              }),
              operator,
              right: new ast_1.Reference({
                location,
                name: "c"
              })
            }),
            expression: true
          })]
        });
      }

      return convertExpressionWithNestedStatements(node);
    }

  });
}

exports.default = controlFlowToExpressions;
},{"@glas/traverse":"bYRw","../ast":"tHlf","../ast/ArrowFunctionExpression":"j5r3","../ast/PropertyStatement":"JB1h","../ast/AssignmentStatement":"IblK","../common":"gPgA"}],"WnvG":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

const ast_1 = require("../ast");

function combineExpressions(expressions, operator = "&&") {
  let result;

  for (let i = expressions.length - 1; i >= 0; i--) {
    let e = expressions[i];

    if (result == null) {
      result = e;
    } else {
      //  we iterate in reverse and add new values to left
      //  so that the array will be left to right and symmetrical with toSubExpressions
      result = new ast_1.BinaryExpression({
        left: e,
        operator,
        right: result
      });
    }
  }

  return result;
}

exports.default = combineExpressions;
},{"../ast":"tHlf"}],"oFJX":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

class Type {
  constructor(name, is) {
    this.name = name;
    this.is = is;
  }

  toString() {
    return name;
  }

}

exports.default = Type;
},{}],"ZMJ5":[function(require,module,exports) {
"use strict";

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const Type_1 = __importDefault(require("./Type"));

exports.default = new Type_1.default("Null", a => a == null);
},{"./Type":"oFJX"}],"djfU":[function(require,module,exports) {
"use strict";

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const Type_1 = __importDefault(require("./Type"));

exports.default = new Type_1.default("Undefined", a => a === undefined);
},{"./Type":"oFJX"}],"vKsU":[function(require,module,exports) {
"use strict";

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getModulePath = exports.isGlobalPath = exports.getGlobalPath = exports.getGlobalReference = void 0;

const Null_1 = __importDefault(require("../Null"));

const Undefined_1 = __importDefault(require("../Undefined")); // // absolute path related functions
// import np from "path"


const ast_1 = require("./ast");

const common_1 = require("./common"); // const ROOT_CHARACTER = ":"
// const PATH_SEPARATOR = "/"
// const EXPORT_SEPARATOR = "#"
// const DEFAULT_EXPORT = "default"


const ionGlobals = new Set([Undefined_1.default.name, Null_1.default.name]);
const globalPrefix = "global:";

function getGlobalReference(node) {
  let {
    location
  } = node; // check if name is exported by ionscript runtime, 

  if (ionGlobals.has(node.name)) {
    return new ast_1.MemberExpression({
      object: new ast_1.Reference({
        location,
        name: common_1.runtimeModuleName
      }),
      property: new ast_1.Identifier({
        location,
        name: node.name
      })
    });
  }

  return node.patch({
    path: getGlobalPath(node.name)
  });
}

exports.getGlobalReference = getGlobalReference;

function getGlobalPath(name) {
  //  check first and see if this name is exported by our runtime module
  //  if so, we import it from there.
  return `${globalPrefix}${name}`;
}

exports.getGlobalPath = getGlobalPath;

function isGlobalPath(path) {
  return path.startsWith(globalPrefix);
}

exports.isGlobalPath = isGlobalPath;

function getModulePath(moduleName, name, location) {
  if (location) {
    return `${moduleName}#${location.start.line}:${location.start.column}:${name}`;
  } else {
    return `${moduleName}#${name}`;
  }
}

exports.getModulePath = getModulePath; // //  path format is
// //  path/to/module#export
// //  url/to/module.js
// //  path/to/module#default => default export
// //  path/to/module => same as * export
// export function isRelative(path: string) {
//     return path.startsWith(".")
// }
// export function isAbsolute(path: string) {
//     return path[0] === ROOT_CHARACTER
// }
// export function join(...steps: Array<string>) {
//     if (steps.length === 0) {
//         return ""
//     }
//     return np.join(...steps).replace(/[\/\\]/g, PATH_SEPARATOR).replace(PATH_SEPARATOR + EXPORT_SEPARATOR, EXPORT_SEPARATOR)
// }
// export function toAbsolute(path) {
//     return isAbsolute(path) ? path : ROOT_CHARACTER + path
// }
// export const root = join()
// export function getModule(path: string) {
//     return getModuleAndExport(path)[0]
// }
// export function getExport(path: string) {
//     return getModuleAndExport(path)[1]
// }
// export function getPath(moduleName: string, exportName = DEFAULT_EXPORT) {
//     return moduleName + EXPORT_SEPARATOR + exportName
// }
// export function getModuleAndExport(path: string) {
//     let index = path.lastIndexOf(EXPORT_SEPARATOR)
//     if (index < 0) {
//         return [path, DEFAULT_EXPORT]
//     }
//     return [path.slice(0, index), path.slice(index + 1)]
// }
// export function getParent(path: string) {
//     let steps = split(path)
//     if (steps.length <= 1) {
//         return root
//     }
//     return join(...steps.slice(0, -1))
// }
// export function split(path: string) {
//     return getModule(path).split(PATH_SEPARATOR)
// }
// export function getLastName(path: string) {
//     let steps = split(path)
//     return steps[steps.length - 1]
// }
// export function getRelative(from: string, to: string) {
//     return join(getParent(from), to)
// }
// // export function sanitize(name: string) {
// //     return name.replace(ROOT_REGEX, '.') //.replace(PATH_REGEX, '.')
// // }
// // export function isParent(parent: string, child: string) {
// //     if (child === parent || !child.startsWith(parent)) {
// //         return false
// //     }
// //     let remainder = parent.length > 0 ? child.slice(parent.length + 1) : child
// //     return remainder.indexOf(PATH_SEPARATOR) < 0
// // }
// // export function getUniqueClientName(name: string) {
// //     return "::" + name.slice(1)
// // }
// // export function absolute(...steps: Array<string | null | undefined>) {
// //     let path = join(...steps)
// //     if (!isAbsolute(path)) {
// //         path = ROOT_CHARACTER + path
// //     }
// //     if (path[1] === PATH_SEPARATOR) {
// //         //  this happens if we concatenate with root for some reason.
// //         path = ROOT_CHARACTER + path.slice(2)
// //     }
// //     // a Type export with same name as module also shares the same path (the Type export IS the module)
// //     let parent = getParent(path)
// //     if (parent && getLastName(parent) === getLastName(path)) {
// //         return parent
// //     }
// //     return path
// // }
},{"../Null":"ZMJ5","../Undefined":"djfU","./ast":"tHlf","./common":"gPgA"}],"xSXH":[function(require,module,exports) {
"use strict";

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isNever = exports.isAny = exports.IntegerTypes = exports.Int32 = exports.UInt32 = exports.Int16 = exports.UInt16 = exports.Int8 = exports.UInt8 = exports.WeakMap = exports.RegExp = exports.Symbol = exports.Undefined = exports.Never = exports.Any = exports.Null = exports.Object = exports.Type = exports.Function = exports.Class = exports.Set = exports.Map = exports.Array = exports.Integer = exports.Number = exports.String = exports.Boolean = void 0;

const combineExpressions_1 = __importDefault(require("./analysis/combineExpressions"));

const ast_1 = require("./ast");

const Reference_1 = __importDefault(require("./ast/Reference"));

const pathFunctions_1 = require("./pathFunctions");

function ref(name) {
  return new Reference_1.default({
    name,
    path: pathFunctions_1.getGlobalPath(name)
  });
}

function number(type, min, max) {
  return combineExpressions_1.default([new ast_1.BinaryExpression({
    left: new ast_1.DotExpression({}),
    operator: "is",
    right: type
  }), new ast_1.BinaryExpression({
    left: new ast_1.DotExpression({}),
    operator: ">=",
    right: new ast_1.Literal({
      value: min
    })
  }), new ast_1.BinaryExpression({
    left: new ast_1.DotExpression({}),
    operator: "<=",
    right: new ast_1.Literal({
      value: max
    })
  })]);
}

exports.Boolean = ref("Boolean");
exports.String = ref("String");
exports.Number = ref("Number");
exports.Integer = ref("Integer");
exports.Array = ref("Array");
exports.Map = ref("Map");
exports.Set = ref("Set");
exports.Class = ref("Class");
exports.Function = ref("Function");
exports.Type = ref("Type");
exports.Object = ref("Object");
exports.Null = ref("Null");
exports.Any = ref("Any");
exports.Never = ref("Never");
exports.Undefined = ref("Undefined");
exports.Symbol = ref("Symbol");
exports.RegExp = ref("RegExp");
exports.WeakMap = ref("WeakMap");
exports.UInt8 = number(exports.Integer, 0, 255);
exports.Int8 = number(exports.Integer, -128, 127);
exports.UInt16 = number(exports.Integer, 0, 65535);
exports.Int16 = number(exports.Integer, -32768, 32767);
exports.UInt32 = number(exports.Integer, 0, 4294967295);
exports.Int32 = number(exports.Integer, -2147483648, 2147483647);
exports.IntegerTypes = {
  UInt8: exports.UInt8,
  Int8: exports.Int8,
  UInt16: exports.UInt16,
  Int16: exports.Int16,
  UInt32: exports.UInt32,
  Int32: exports.Int32
}; // export const EmptyLocation = new Location({ start: new Position(0, 0), end: new Position(0, 0), filename: "inferType.empty" })

function equals(a, b) {
  return a === b || Reference_1.default.is(a) && a.name === b.name;
}

function isAny(node) {
  return equals(node, exports.Any);
}

exports.isAny = isAny;

function isNever(node) {
  return equals(node, exports.Never);
}

exports.isNever = isNever;
},{"./analysis/combineExpressions":"WnvG","./ast":"tHlf","./ast/Reference":"zd4v","./pathFunctions":"vKsU"}],"bGmY":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createIsType = void 0;

const t = __importStar(require("../types")); //  key = type, value = all types implemented by this type


class TypeData {
  constructor(baseType, ...types) {
    this.baseType = baseType.path.toString();
    this.types = new Set(types.map(type => type.path.toString()));
    this.types.add(this.baseType);
  }

} //  type, [baseType], ...otherBaseTypesTheMainTypeImplements


let baseTypes = [[t.Boolean], [t.String], [t.Number], [t.Integer, t.Number], [t.Symbol], [t.Null, t.Null, t.Undefined], [t.Undefined, t.Null, t.Null], [t.Object], [t.Array, t.Array, t.Object], [t.RegExp, t.RegExp, t.Object], [t.Map, t.Map, t.Object], [t.Set, t.Set, t.Object], [t.WeakMap, t.Map, t.Object], [t.Function, t.Function, t.Object], [t.Class, t.Function, t.Type], [t.Type, t.Object]];

function getTypeMap(types) {
  let typeMap = new Map();

  for (let typeArray of types) {
    let [type, baseType = type, ...types] = typeArray;
    typeMap.set(type.path.toString(), new TypeData(baseType, ...types));
  } // now make sure we recursively add subtypes


  function addRecursive(type, types, added = new Set()) {
    var _a;

    if (types) {
      let data = typeMap.get(type);

      for (let addType of types) {
        if (!added.has(addType)) {
          added.add(addType);
          data.types.add(addType);
          addRecursive(type, (_a = typeMap.get(addType)) === null || _a === void 0 ? void 0 : _a.types, added);
        }
      }
    }
  }

  for (let type of typeMap.keys()) {
    addRecursive(type, typeMap.get(type).types);
  }

  return typeMap;
}

function createIsType(types) {
  let typeMap = getTypeMap([...baseTypes, ...types]);
  return (checkIfType, isInstanceOfOtherType) => {
    let checkPath = checkIfType.path.toString();
    let otherPath = isInstanceOfOtherType.path.toString();
    let checkData = typeMap.get(checkPath);
    let otherData = typeMap.get(otherPath);

    if (checkData == null || otherData == null) {
      return null;
    }

    if (checkData.types.has(otherPath)) {
      //  it definitely does implement it
      return true;
    }

    if (checkData.baseType !== otherData.baseType) {
      // if two types have a different base type then they absolutely cannot implement each other
      //  it definitely does NOT implement it
      return false;
    } // it MIGHT implement it


    return null;
  };
}

exports.createIsType = createIsType;
},{"../types":"xSXH"}],"d3NE":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const ast = __importStar(require("./ast"));

const common_1 = require("./common");

const codeToString = {
  Identifier(node) {
    return node.name;
  },

  Declarator(node) {
    return node.name;
  },

  Reference(node) {
    var _a;

    return (_a = node.path) !== null && _a !== void 0 ? _a : node.name;
  },

  TypeExpression(node) {
    return s(node.value);
  },

  DotExpression(node) {
    return ".";
  },

  ThisExpression(node) {
    return "this";
  },

  ObjectExpression(node) {
    return `{ ${node.properties.map(toCodeString).join(', ')} }`;
  },

  ArrayExpression(node) {
    return `[ ${node.elements.map(toCodeString).join(', ')} ]`;
  },

  Program(node) {
    return `program ${node.id.name}`;
  },

  FunctionExpression(node) {
    var _a, _b;

    return `function ${(_b = (_a = node.id) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : ''}(${node.params.map(toCodeString).join(',')})`;
  },

  ArrowFunctionExpression(node) {
    return `(${node.params.map(toCodeString).join(',')}) => {?}`;
  },

  FunctionType(node) {
    return `${node.async ? "async " : ""}(${node.params.map(toCodeString).join(',')}) => ${toCodeString(node.returnType)}`;
  },

  ClassDeclaration(node) {
    return `class ${node.id.name}`;
  },

  Property(node) {
    if (node.key != null) {
      if (ast.Identifier.is(node.key)) {
        return `${s(node.key)}:${s(node.value)}`;
      } else {
        return `[${s(node.key)}]:${s(node.value)}`;
      }
    }

    return `${s(node.value)}`;
  },

  Parameter(node) {
    let value = s(node.id);

    if (node.type) {
      value += `: ${s(node.type)}`;
    }

    if (node.value) {
      value += ` = ${s(node.value)}`;
    }

    return `${value}`;
  },

  Literal(node) {
    return JSON.stringify(node.value);
  },

  BinaryExpression(node) {
    return `(${s(node.left)} ${node.operator} ${s(node.right)})`;
  },

  UnaryExpression(node) {
    return `${node.operator}${s(node.argument)}`;
  },

  MemberExpression(node) {
    if (ast.Identifier.is(node.property)) {
      return `${s(node.object)}.${s(node.property)}`;
    } else {
      return `${s(node.object)}[${s(node.property)}]`;
    }
  },

  CallExpression(node) {
    return `${s(node.callee)}(${node.arguments.map(s).join(', ')})`;
  },

  VariableDeclaration(node) {
    return node.kind + " " + codeToString.Parameter(node);
  },

  IfStatement(node) {
    let result = `(if ${s(node.test)} then ${s(node.consequent)}`;

    if (node.alternate) {
      result += ` else ${s(node.alternate)} end`;
    } else {
      result += ` end)`;
    }

    return result;
  },

  BlockStatement(node) {
    return `{ ${node.body.map(s).join('; ')} }`;
  },

  ReturnStatement(node) {
    return `return ${toCodeString(node.argument)}`;
  },

  SpreadElement(node) {
    return `...${toCodeString(node.argument)}`;
  },

  RestElement(node) {
    return `...${toCodeString(node.argument)}`;
  },

  RegularExpression(node) {
    return `/${node.pattern}/${node.flags}`;
  }

};
const s = common_1.memoize(function (node) {
  let fn = codeToString[node.constructor.name];

  if (fn == null) {
    throw new Error(`codeToString function not found for type: ${node.constructor.name}`);
  }

  return fn(node);
});

function toCodeString(node) {
  if (node == null) {
    return "null";
  }

  return s(node);
}

exports.default = toCodeString;
},{"./ast":"tHlf","./common":"gPgA"}],"inxk":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

const ast_1 = require("../ast");

function* splitExpressions(e, operator = "&&") {
  if (ast_1.BinaryExpression.is(e) && e.operator === operator) {
    yield* splitExpressions(e.left, operator);
    yield* splitExpressions(e.right, operator);
  } else {
    yield e;
  }
}

exports.default = splitExpressions;
},{"../ast":"tHlf"}],"Gu3u":[function(require,module,exports) {
"use strict";

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const ast_1 = require("../ast");

const toCodeString_1 = __importDefault(require("../toCodeString"));

const splitExpressions_1 = __importDefault(require("./splitExpressions")); //  a  \  b |  true   false   null
//  --------------------------------
//  true    |  true   true    true
//  false   |  true   false   null
//  null    |  true   null    null


function max(a, b) {
  if (a === true || b === true) return true;
  if (a == null || b == null) return null;
  return false;
} //  a  \  b |  true   false   null
//  --------------------------------
//  true    |  true   false   null
//  false   |  false  false   false
//  null    |  null   false   null


function min(a, b) {
  if (a === false || b === false) return false;
  if (a == null || b == null) return null;
  return true;
} //  a  \  b |  true   false   null
//  --------------------------------
//  true    |  true   null    null
//  false   |  null   false   null
//  null    |  null   null    null


function same(a, b) {
  return a === b ? a : null;
}
/**
 * Assuming expression 'a' is true then this function returns
 * true if 'b' is necessarily true
 * false if 'b' is necessarily false
 * null if we cannot determine
 */


function isConsequent(a, b, isType = (a, b) => a.path === b.path) {
  if (ast_1.TypeExpression.is(a)) {
    a = a.value;
  }

  if (ast_1.TypeExpression.is(b)) {
    b = b.value;
  }

  if (toCodeString_1.default(a) === toCodeString_1.default(b)) {
    return true;
  }

  if (ast_1.BinaryExpression.is(a)) {
    if (ast_1.BinaryExpression.is(b)) {
      if (toCodeString_1.default(a.left) === toCodeString_1.default(b.left)) {
        if (ast_1.Reference.is(a.right) && ast_1.Reference.is(b.right)) {
          if (a.operator === "is" && b.operator === "is") {
            // use our isType to see if we know that a is b
            return isType(a.right, b.right);
          }
        }

        if (ast_1.Literal.is(a.right) && ast_1.Literal.is(b.right)) {
          let ar = a.right.value;
          let br = b.right.value;

          switch (a.operator) {
            case '>':
              switch (b.operator) {
                case '>=': // > 0 is >= 0, > 1 is >= 0

                case '!=': // > 0 is != 0, > 1 is != 0

                case '>':
                  return ar >= br ? true : null;
                // > 0 is > 0, > 1 is > 0

                case '<=': // > 0 isnt <= 0, > 1 isnt <= 0

                case '==': // > 0 isnt == 0, > 1 isnt == 0

                case '<':
                  return ar >= br ? false : null;
                // > 0 isnt < 0, > 1 isnt < 0
              }

              break;

            case '>=':
              switch (b.operator) {
                case '>=': // >= 1 is >= 0

                case '>':
                  return ar > br ? true : null;
                // >= 1 is > 0

                case '==': // >= 1 isnt == 0

                case '<=':
                  return ar > br ? false : null;
                // >= 1 isnt <= 0

                case '<':
                  return ar >= br ? false : null;
                // >= 0 isnt < 0, >= 1 isnt < 0
              }

              break;

            case '<':
              switch (b.operator) {
                case '<=': // < 0 is <= 0, < -1 is <= 0

                case '!=': // < 0 is != 0, < -1 is != 0

                case '<':
                  return ar <= br ? true : null;
                // < 0 is < 0, < -1 is < 0

                case '>=': // < 0 isnt >= 0, < -1 isnt >= 0

                case '==': // < 0 isnt == 0, < -1 isnt == 0

                case '>':
                  return ar <= br ? false : null;
                // < 0 isnt > 0, < -1 isnt > 0
              }

              break;

            case '<=':
              switch (b.operator) {
                case '<=': // <= -1 is <= 0

                case '<':
                  return ar < br ? true : null;
                // <= -1 is < 0

                case '==': // <= -1 isnt == 0

                case '>=':
                  return ar < br ? false : null;
                // <= -1 isnt >= 0

                case '>':
                  return ar <= br ? false : null;
                // <= 0 isnt > 0, <= -1 isnt > 0
              }

              break;

            case '==':
              switch (b.operator) {
                case '<=':
                  return ar <= br;
                // == 0 is <= 0, == 0 is <= 1

                case '<':
                  return ar < br;
                // == 0 is < 1

                case '==':
                  return ar === br;
                // == 0 is == 0

                case '>=':
                  return ar >= br;
                // == 0 is >= 0

                case '>':
                  return ar > br;
                // == 0 is > -1

                case '!=':
                  return ar != br;
                // == 0 is != 1
              }

              break;
          }
        } else if (toCodeString_1.default(a.right) === toCodeString_1.default(b.right)) {
          // we can still analyze some comparisons if we know the both right hand operators are the same.
          switch (a.operator) {
            case '>':
              switch (b.operator) {
                case '>=':
                case '!=':
                  return true;

                case '<':
                case '<=':
                case '==':
                  return false;
              }

              break;

            case '>=':
              switch (b.operator) {
                case '<':
                  return false;
              }

              break;

            case '<':
              switch (b.operator) {
                case '<=':
                case '!=':
                  return true;

                case '>':
                case '>=':
                case '==':
                  return false;
              }

              break;

            case '<=':
              switch (b.operator) {
                case '>':
                  return false;
              }

              break;

            case '==':
              switch (b.operator) {
                case '>=':
                case '<=':
                  return true;

                case '>':
                case '<':
                case '!=':
                  return false;
              }

              break;

            case '!=':
              switch (b.operator) {
                case '==':
                  return false;
              }

              break;

            case 'is':
              switch (b.operator) {
                case 'isnt':
                  return false;
              }

              break;

            case 'isnt':
              switch (b.operator) {
                case 'is':
                  return false;
              }

              break;
          }
        }
      }
    }
  } //  A & B & C => C & D & E
  //  if any term on the left results in a false on the right then false (not consequent)
  //  if all terms on the right are true based on any term on the left then true (consequent)
  //  otherwise null (unknown)


  if (ast_1.BinaryExpression.is(b) && b.operator === "&&" || ast_1.BinaryExpression.is(a) && a.operator === "&&") {
    let allTrue = true;

    for (let bTerm of splitExpressions_1.default(b, "&&")) {
      let bTermResult = null;

      for (let aTerm of splitExpressions_1.default(a, "&&")) {
        let aTermResult = isConsequent(aTerm, bTerm, isType);

        if (aTermResult === false) {
          return false;
        }

        if (aTermResult === true) {
          bTermResult = true;
          break;
        }
      }

      if (bTermResult !== true) {
        allTrue = false;
      }
    }

    return allTrue || null;
  } //  A & B => C & D


  if (ast_1.BinaryExpression.is(a) && a.operator === "||") {
    return same(isConsequent(a.left, b, isType), isConsequent(a.right, b, isType));
  }

  if (ast_1.BinaryExpression.is(b) && b.operator === "||") {
    return max(isConsequent(a, b.left, isType), isConsequent(a, b.right, isType));
  }

  return null;
}

exports.default = isConsequent;
},{"../ast":"tHlf","../toCodeString":"d3NE","./splitExpressions":"inxk"}],"u957":[function(require,module,exports) {
var global = arguments[3];
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ScopeContext = void 0;

const traverse_1 = require("@glas/traverse");

const common_1 = require("./common");

const ast_1 = require("./ast");

const types = __importStar(require("./types"));

const isType_1 = require("./analysis/isType");

const isConsequent_1 = __importDefault(require("./analysis/isConsequent"));

class ScopeContext {
  constructor(root, isType = false) {
    this.identifiers = new Set();
    this.ancestors = new Map();

    this.isType = () => {
      throw new Error(`set isType in constructor`);
    };

    let _implements = isType ? [] : undefined;

    this.scopes = createScopeMaps(root, {
      identifiers: this.identifiers,
      ancestorsMap: this.ancestors,
      implements: _implements
    });

    if (_implements) {
      this.isType = isType_1.createIsType(_implements);
    }
  }

  isConsequent(a, b) {
    return isConsequent_1.default(a, b, this.isType);
  }

  getParent(node) {
    return this.ancestors.get(node);
  }

  getAncestor(node, predicate) {
    return common_1.getAncestor(node, this.ancestors, predicate);
  }
  /**
   * Returns an array of self and ancestors starting at [self, parent...]
   */


  getAncestorList(node) {
    return common_1.getAncestorsAndSelfList(node, this.ancestors);
  }

  getDeclarator(node, name) {
    var _a, _b;

    if (name == null && ast_1.Reference.is(node)) {
      let result = (_a = this.getScope(node)) === null || _a === void 0 ? void 0 : _a[node.name];

      if (result == null && node.path != null) {
        // check global scope
        let global = this.scopes.get(null);
        result = global[node.path];
      }

      return result;
    }

    if (name == null) {
      throw new Error();
    }

    return (_b = this.getScope(node)) === null || _b === void 0 ? void 0 : _b[name];
  }

  getScope(node) {
    return this.scopes.get(node);
  }

}

exports.ScopeContext = ScopeContext;
/**
 * Returns a Map which will contain a scope object with variable names returning Declarations.
 * scopes.get(null) will return the global scope
 * @param root the ast
 */

function createScopeMaps(root, options = {}) {
  let {
    identifiers = new Set(),
    ancestorsMap
  } = options;
  let map = new Map();
  let global = {// // always add "." to the global namespace so TypeExpressions don't complain
    // ".": new VariableDeclaration({ id: new Identifier({ name: "." }), kind: "const" })
  };
  let scopes = [global];
  map.set(null, global);

  function declare(node) {
    identifiers.add(node.name);
    let scope = scopes[scopes.length - 1];
    scope[node.name] = node;

    if (node.path) {
      // if path, put into global scope
      global[node.path] = node;
    }
  }

  function declarePattern(node) {
    if (ast_1.Declarator.is(node)) {
      declare(node);
    } else {
      traverse_1.traverse(node, {
        enter(node) {
          if (ast_1.Declarator.is(node)) {
            declare(node);
            return traverse_1.skip;
          }
        }

      });
    }
  }

  traverse_1.traverse(root, {
    enter(node, ancestors, path) {
      if (ancestorsMap) {
        let ancestor = null;

        for (let i = ancestors.length - 1; i >= 0; i--) {
          if (ast_1.Node.is(ancestors[i])) {
            ancestor = ancestors[i];
            break;
          }
        }

        ancestorsMap.set(node, ancestor);
      }

      if (options.implements && ast_1.ClassDeclaration.is(node)) {
        options.implements.push([node.id, types.Object, ...node.baseClasses]);
      } //  do nothing on Parameters, they're handled by their containing functions


      if (ast_1.Program.is(node)) {
        // programs declare their id into the global scope, before pushing their own scope
        declarePattern(node.id);
      } //  get the current scope


      let scope = scopes[scopes.length - 1]; //  save a map from this nodes location to it's scope

      map.set(node, scope); // if (pathMap) {
      //     pathMap.set(node, path.slice(0))
      // }

      function pushScope() {
        var _a;

        scopes.push(scope = {
          __proto__: scope,
          __source: node.constructor.name + " => " + JSON.stringify((_a = node.location) !== null && _a !== void 0 ? _a : "NULL")
        });
      }

      if (ast_1.Parameter.is(node)) {
        return;
      } //  if this node is a scope then we push a new scope


      if (ast_1.Scope.is(node)) {
        pushScope(); // console.log('++++')
      } //  declarations set themselves in scope


      if (ast_1.Pattern.is(node)) {
        declarePattern(node);
      } //  functions set their parameters in scope


      if (ast_1.FunctionExpression.is(node)) {
        for (let parameter of node.params) {
          declarePattern(parameter.id);
        }
      }
    },

    leave(node) {
      if (ast_1.Scope.is(node)) {
        // console.log('----')
        scopes.pop();
      }
    }

  });
  return map;
}

exports.default = createScopeMaps;
},{"@glas/traverse":"bYRw","./common":"gPgA","./ast":"tHlf","./types":"xSXH","./analysis/isType":"bGmY","./analysis/isConsequent":"Gu3u"}],"RCa2":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const createScopeMaps_1 = __importDefault(require("../createScopeMaps"));

const traverse_1 = require("@glas/traverse");

const ast_1 = require("../ast");

const common_1 = require("../common");

const pathFunctions_1 = require("../pathFunctions");

const types = __importStar(require("../types"));

function checkReferences(root) {
  let ancestorsMap = new Map();
  let scopes = createScopeMaps_1.default(root, {
    ancestorsMap
  });
  let getName = common_1.memoizeIntern(d => {
    d = common_1.getOriginalDeclarator(d, scopes, ancestorsMap);
    let parent = ancestorsMap.get(d);
    let {
      name
    } = d;
    let location;

    if (ast_1.Program.is(parent)) {
      name = "";
    } else if (ast_1.Exportable.is(parent) && parent.export !== 0) {
      if (parent.export === 2) {
        name = "default";
      }
    } else {
      location = d.location;
    }

    return pathFunctions_1.getModulePath(d.location.filename, name, location);
  });
  return traverse_1.traverse(root, {
    leave(node, ancestors) {
      // we also set variable id onto function expressions if they aren't named already
      if (ast_1.VariableDeclaration.is(node)) {
        if (ast_1.Identifier.is(node.id) && ast_1.FunctionExpression.is(node.value) && node.value.id == null) {
          return node.patch({
            value: node.value.patch({
              id: node.id
            })
          });
        }
      }

      if (ast_1.Declarator.is(node)) {
        return node.patch({
          path: getName(node)
        });
      }

      if (ast_1.Reference.is(node)) {
        let scope = scopes.get(node);

        if (scope == null) {
          //  we might have been mutated by a changed template sub-reference
          //  so we will use our unmutated ancestors scope if needed
          scope = scopes.get(ancestors[ancestors.length - 1]);

          if (scope == null) {
            console.log("scope not found for: ", node);
          }
        }

        let declarator = scope[node.name];

        if (declarator == null) {
          // if we cannot find a declarator then this must be a global reference
          return pathFunctions_1.getGlobalReference(node);
        } else {
          let declaration = ancestors[ancestors.length - 1];

          if (ast_1.VariableDeclaration.is(declaration)) {
            let cls = common_1.getAncestor(declaration, ancestorsMap, ast_1.ClassDeclaration.is);

            if (declaration.instance && cls.instance.declarations.find(d => d.id.name === node.name)) {
              // add implied this. to instance property references
              console.log({
                node
              });
              return new ast_1.MemberExpression({
                object: new ast_1.ThisExpression({}),
                property: new ast_1.Identifier(node)
              });
            } else if (declaration.static && cls.static.find(d => d.id.name === node.name)) {
              //  add implied Class. to static property references
              let classDeclaration = common_1.getAncestor(node, ancestorsMap, ast_1.ClassDeclaration.is); // declaratorAncestors[declaratorAncestors.length - 3] as ClassDeclaration

              return new ast_1.MemberExpression({
                object: new ast_1.Reference(classDeclaration.id),
                property: new ast_1.Identifier(node)
              });
            }
          }

          return node.patch({
            path: getName(declarator)
          });
        }
      } // semantic checks.


      if (ast_1.FunctionExpression.is(node)) {
        // check that only a single RestElement max and is final arg
        for (let i = 0; i < node.params.length; i++) {
          let param = node.params[i];

          if (ast_1.RestElement.is(param.id)) {
            // must be last parameter
            if (i + 1 < node.params.length) {
              throw common_1.SemanticError(`Rest element must be final parameter`, param);
            }

            let {
              type
            } = param;

            if (type) {
              if (!ast_1.Reference.is(type) || type.path !== types.Array.path) {
                throw common_1.SemanticError(`Rest element type must be an Array`, type);
              }
            }
          }
        }
      }
    }

  });
}

exports.default = checkReferences;
},{"../createScopeMaps":"u957","@glas/traverse":"bYRw","../ast":"tHlf","../common":"gPgA","../pathFunctions":"vKsU","../types":"xSXH"}],"uwmd":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.replaceNodes = void 0;

const traverse_1 = require("@glas/traverse");

const ast_1 = require("../ast");

const common_1 = require("../common"); // let Vector_x = Symbol("Vector_x")


function getSymbolName(c, d) {
  return `${c.id.name}_${d.id.name}`;
}

function typeCheckOrThrow(value, type, name) {
  return new ast_1.IfStatement({
    test: new ast_1.UnaryExpression({
      operator: "!",
      argument: new ast_1.BinaryExpression({
        left: value,
        operator: "is",
        right: type
      })
    }),
    consequent: new ast_1.BlockStatement({
      body: [new ast_1.ThrowStatement({
        argument: new ast_1.CallExpression({
          new: true,
          callee: new ast_1.Reference({
            name: "Error"
          }),
          arguments: name ? [new ast_1.Literal({
            value: `Invalid value for ${name}`
          })] : []
        })
      })]
    })
  });
}
/**
 * Replaces nodes but returns original if none were replaced.
 */


function replaceNodes(root, match, replacement) {
  let replaceCount = 0;
  let result = traverse_1.traverse(root, {
    leave(node) {
      if (match(node)) {
        replaceCount++;
        return replacement;
      }
    }

  });
  return replaceCount > 0 ? result : root;
}

exports.replaceNodes = replaceNodes;

function replaceTypedVarsWithProperties(clas, options) {
  return traverse_1.traverse(clas, {
    enter(node) {
      if (!ast_1.ClassDeclaration.is(node) && ast_1.Declaration.is(node)) {
        return traverse_1.skip;
      }
    },

    leave(node, ancestors) {
      if (ast_1.VariableDeclaration.is(node)) {
        if (node.static || node.instance) {
          if (node.kind === "var" && node.type != null) {
            let classDeclaration = common_1.getLast(ancestors, ast_1.ClassDeclaration.is);
            let name = getSymbolName(classDeclaration, node); // can convert to get/set with types here, BUT that would mean suckitude.
            // convert to type and shit

            return traverse_1.replace(new ast_1.VariableDeclaration({
              static: node.static,
              kind: "get",
              id: node.id,
              value: new ast_1.FunctionExpression({
                params: [],
                body: new ast_1.BlockStatement({
                  body: [new ast_1.ReturnStatement({
                    argument: new ast_1.MemberExpression({
                      object: new ast_1.ThisExpression({}),
                      property: new ast_1.Reference({
                        name
                      })
                    })
                  })]
                })
              })
            }), new ast_1.VariableDeclaration({
              static: node.static,
              kind: "set",
              id: node.id,
              value: new ast_1.FunctionExpression({
                params: [new ast_1.Parameter({
                  id: new ast_1.Declarator({
                    name: "value"
                  })
                })],
                body: new ast_1.BlockStatement({
                  body: [typeCheckOrThrow(new ast_1.Reference({
                    name: "value"
                  }), node.type, name.replace('_', ' ')), new ast_1.AssignmentStatement({
                    left: new ast_1.MemberExpression({
                      object: new ast_1.ThisExpression({}),
                      property: new ast_1.Reference({
                        name
                      })
                    }),
                    right: new ast_1.Reference({
                      name: "value"
                    })
                  })]
                })
              })
            }));
          }
        }
      }
    }

  });
} // also adds ion import if there are any references to ion


function runtimeTypeChecking(root, options) {
  if (!options.debug) {
    // skip all automatic runtime type checks if this is a release build
    return root;
  }

  return traverse_1.traverse(root, {
    enter(node) {
      if (ast_1.Program.is(node)) {
        return traverse_1.skip;
      }
    },

    leave(node) {
      if (ast_1.Program.is(node)) {
        // let hasIonReference = false
        let result = traverse_1.traverse(node, {
          enter(node) {
            // if (Reference.is(node) && node.name === runtimeModuleName) {
            //     hasIonReference = true
            // }
            if (ast_1.TypeExpression.is(node)) {
              return traverse_1.skip;
            }
          },

          leave(node, ancestors, path) {
            var _a;

            if (ast_1.VariableDeclaration.is(node)) {
              if (node.kind === "type") {
                return node.patch({
                  kind: "const",
                  value: ast_1.Reference.is(node.value) ? node.value : new ast_1.CallExpression({
                    new: true,
                    callee: new ast_1.MemberExpression({
                      object: new ast_1.Reference({
                        name: common_1.runtimeModuleName
                      }),
                      property: new ast_1.Identifier({
                        name: "Type"
                      })
                    }),
                    arguments: [new ast_1.Literal({
                      value: node.id.name
                    }), new ast_1.FunctionExpression({
                      params: [new ast_1.Parameter({
                        id: new ast_1.Declarator({
                          name: "_"
                        })
                      })],
                      body: new ast_1.BlockStatement({
                        body: [new ast_1.ReturnStatement({
                          argument: replaceNodes((_a = node.value.value) !== null && _a !== void 0 ? _a : node.value, ast_1.DotExpression.is, new ast_1.Reference({
                            name: "_"
                          }))
                        })]
                      })
                    })]
                  })
                });
              }
            }

            if (ast_1.FunctionExpression.is(node)) {
              //  only works without destructuring for now
              let typedParams = node.params.filter(p => p.type != null && ast_1.Identifier.is(p.id));

              if (typedParams != null) {
                return node.patch({
                  body: node.body.patch({
                    body: [...typedParams.map(p => typeCheckOrThrow(new ast_1.Reference(p.id), p.type, p.id.name)), ...node.body.body]
                  })
                });
              }
            }

            if (ast_1.ClassDeclaration.is(node) && !node.isData) {
              // first find any typed vars we need to create symbols for
              //  handle typed variables by adding symbols to use for storing values
              let typedVars = [...node.static, ...node.instance.declarations].filter(d => d.type != null);

              if (typedVars.length > 0) {
                return traverse_1.replace(...typedVars.map(d => {
                  let name = getSymbolName(node, d);
                  return new ast_1.VariableDeclaration({
                    kind: "let",
                    id: new ast_1.Declarator({
                      name
                    }),
                    value: new ast_1.CallExpression({
                      callee: new ast_1.Reference({
                        name: "Symbol"
                      }),
                      arguments: options.debug ? [new ast_1.Literal({
                        value: name
                      })] : []
                    })
                  });
                }), replaceTypedVarsWithProperties(node, options));
              }
            }
          }

        }); // if (hasIonReference) {
        //     result = result.patch({
        //         body: [
        //             new ImportDeclaration({
        //                 specifiers: [
        //                     new ImportNamespaceSpecifier({
        //                         local: new Declarator({ name: runtimeModuleName })
        //                     })
        //                 ],
        //                 source: new Literal({ value: runtimeModuleName }),
        //             }),
        //             ...result.body
        //         ]
        //     })
        // }

        return result;
      }
    }

  });
}

exports.default = runtimeTypeChecking;
},{"@glas/traverse":"bYRw","../ast":"tHlf","../common":"gPgA"}],"cksN":[function(require,module,exports) {
"use strict";

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const toCodeString_1 = __importDefault(require("./toCodeString")); // copied from https://github.com/marcelklehr/toposort/blob/master/index.js

/**
 * Topological sorting function
 *
 * @param {Array} edges
 * @returns {Array}
 */


function default_1(edges) {
  return toposort(uniqueNodes(edges), edges);
}

exports.default = default_1;
exports.array = toposort;

function toposort(nodes, edges) {
  var cursor = nodes.length,
      sorted = new Array(cursor),
      visited = {},
      i = cursor; // try {

  while (i--) {
    if (!visited[i]) visit(nodes[i], i, []);
  } // }
  // catch (e) {
  //   console.log({ nodes, edges, visited })
  // }


  return sorted;

  function visit(node, i, predecessors) {
    if (predecessors.indexOf(node) >= 0) {
      console.log({
        predecessors: predecessors.map(toCodeString_1.default)
      });
      throw new Error('Cyclic dependency: ' + toCodeString_1.default(node));
    }

    if (visited[i]) return;
    visited[i] = true; // outgoing edges

    var outgoing = edges.filter(function (edge) {
      return edge[0] === node;
    });

    if (i = outgoing.length) {
      var preds = predecessors.concat(node);

      do {
        var child = outgoing[--i][1];
        visit(child, nodes.indexOf(child), preds);
      } while (i);
    }

    sorted[--cursor] = node;
  }
}

function uniqueNodes(arr) {
  var res = [];

  for (var i = 0, len = arr.length; i < len; i++) {
    var edge = arr[i];
    if (res.indexOf(edge[0]) < 0) res.push(edge[0]);
    if (res.indexOf(edge[1]) < 0) res.push(edge[1]);
  }

  return res;
}
},{"./toCodeString":"d3NE"}],"oseV":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getPredecessors = exports.getContainingIfTestAndOriginalDeclarator = void 0;

const traverse_1 = require("@glas/traverse");

const toposort_1 = __importDefault(require("../toposort"));

const ast_1 = require("../ast");

const ast = __importStar(require("../ast"));

const common_1 = require("../common");

function getReturnStatements(node) {
  let statements = [];
  traverse_1.traverse(node, {
    enter(node) {
      if (ast_1.CallExpression.is(node)) {
        return traverse_1.skip;
      }
    },

    leave(node) {
      if (ast_1.ReturnStatement.is(node)) {
        statements.push(node);
      }
    }

  });
  return statements;
}

function getContainingIfTestAndOriginalDeclarator(node, scopeMap, ancestorMap) {
  var _a;

  let containingIf = common_1.getAncestor(node, ancestorMap, ast_1.IfStatement.is);
  let containingIfScope = scopeMap.get(containingIf);
  let name = node.id.name;
  let containingVarDeclarator = (_a = containingIfScope[name]) !== null && _a !== void 0 ? _a : null;
  return [containingIf.test, containingVarDeclarator];
}

exports.getContainingIfTestAndOriginalDeclarator = getContainingIfTestAndOriginalDeclarator;

function getPredecessors(node, scopeMap, ancestorMap) {
  return predecessors[node.constructor.name](node, scopeMap, ancestorMap);
}

exports.getPredecessors = getPredecessors;
const predecessors = {
  *ConditionalDeclaration(node, scopeMap, ancestorMap) {
    // the conditional declaration will add it's own local conditional assertion to the variable type
    // from the containing scope, so we are dependent on that variable being resolved first.
    let [containingIfTest, containingVarDeclarator] = getContainingIfTestAndOriginalDeclarator(node, scopeMap, ancestorMap);

    if (containingIfTest) {
      yield containingIfTest;
    }

    if (containingVarDeclarator) {
      yield containingVarDeclarator;
    }
  },

  *ArrayPattern(node) {
    for (let element of node.elements) {
      //  all pattern elements are dependent on this nodes type first.
      //  then their type will be a member of this nodes type
      if (element != null) {
        yield [node, element];
      }
    }
  },

  *ObjectPattern(node) {
    for (let prop of node.properties) {
      //  all object pattern properties are dependent on this nodes type first.
      //  then their type will be a member of this nodes type
      yield [node, prop];
    }
  },

  *BinaryExpression(node) {
    yield node.left;
    yield node.right;
  },

  *UnaryExpression(node) {
    yield node.argument;
  },

  *Declarator(node, scopeMap, ancestorMap) {
    let parent = ancestorMap.get(node);

    if (ast_1.Typed.is(parent)) {
      yield parent;
    }
  },

  *Literal(node, scopeMap, ancestorMap) {
    if (node.type) {
      // we need to know the type for these friggin literals right away.
      yield node.type;
    }
  },

  *ObjectExpression(node) {
    for (let property of node.properties) {
      if (ast_1.Property.is(property)) {
        if (ast_1.Typed.is(property.key)) {
          yield property.key;
        }

        if (ast_1.Expression.is(property.value)) {
          yield property.value;
        }
      } else {
        // SpreadElement
        yield property.argument;
      }
    }
  },

  *ClassDeclaration(node) {
    // this nodes declarator is dependent on this node
    yield [node, node.id];
    yield* node.baseClasses;
    yield* node.static.values();
    yield* node.instance.declarations.values();
  },

  *Variable(node) {
    // make the id pattern dependent on this type
    yield [node, node.id];

    if (node.value) {
      yield node.value;
    }

    if (node.type) {
      yield node.type;
    }
  },

  *Parameter(node, scopeMap, ancestorMap) {
    yield* predecessors.Variable(node, scopeMap, ancestorMap);
  },

  *VariableDeclaration(node, scopeMap, ancestorMap) {
    yield* predecessors.Variable(node, scopeMap, ancestorMap);
  },

  *TypeExpression(node) {
    yield node.value;
  },

  *FunctionExpression(node) {
    // a function depends on it's parameters which means it depends on it's parameter types
    yield* node.params;

    if (node.returnType === null) {
      for (let returnStatement of getReturnStatements(node)) {
        yield returnStatement.argument;
      }
    }
  },

  *Reference(node, scopes) {
    let referencedNode = scopes.get(node)[node.name];

    if (referencedNode != null) {
      yield referencedNode; // we don't throw on unrealized references... we just will consider them type any
      // throw SemanticError("Referenced value not found", node)
    }
  },

  // *TemplateReference(node) {
  //     yield node.reference
  //     yield* node.arguments
  // },
  *MemberExpression(node) {
    yield node.object;

    if (ast_1.Expression.is(node.property)) {
      yield node.property;
    }
  },

  *ArrayExpression(node) {
    for (let element of node.elements) {
      if (ast.SpreadElement.is(element)) {
        yield element.argument;
      } else if (element != null) {
        yield element;
      }
    }
  },

  *CallExpression(node) {
    yield node.callee;

    for (let arg of node.arguments) {
      if (ast.SpreadElement.is(arg)) {
        yield arg.argument;
      } else {
        yield arg;
      }
    }
  }

};

function getSortedTypedNodes(root, scopeMap, ancestorsMap) {
  let sentinel = {};
  let edges = [];

  function push(from, to) {
    if (from == null || to == null) {
      throw new Error("Edge nodes may not be null");
    }

    if (from === to) {
      console.error(from);
      throw new Error("Attempt to add same node as dependency of itself");
    }

    edges.push([from, to]);
  }

  let nodes = new Array();
  traverse_1.traverse(root, {
    leave(node) {
      if (ast_1.Typed.is(node)) {
        nodes.push(node);
      }
    }

  }); // now... we can try to sort the nodes based on what order we think they should be in.
  // the reason for this is that we neeed UFCS functions to be defined before they are called.
  // FunctionExpression depends on parameter types => Classes

  nodes.sort((a, b) => {
    const afunc = ast_1.FunctionExpression.is(a);
    const bfunc = ast_1.FunctionExpression.is(b);

    if (afunc && !bfunc) {
      return -1;
    }

    if (bfunc && !afunc) {
      return +1;
    }

    return 0;
  });

  for (let node of nodes) {
    if (ast_1.BinaryExpression.is(node)) {
      push(node.left, node.right);
    }

    let count = 0;

    if (ast_1.Typed.is(node)) {
      let func = predecessors[node.constructor.name];

      if (func) {
        for (let pred of func(node, scopeMap, ancestorsMap)) {
          count++;

          if (Array.isArray(pred)) {
            push(pred[0], pred[1]);
          } else {
            push(pred, node);
          }
        }
      }

      if (count === 0) {
        push(sentinel, node);
      }
    }
  }

  let sorted = toposort_1.default(edges); //  remove sentinel

  sorted.splice(sorted.indexOf(sentinel), 1);
  return sorted;
}

exports.default = getSortedTypedNodes;
},{"@glas/traverse":"bYRw","../toposort":"cksN","../ast":"tHlf","../common":"gPgA"}],"Mlo2":[function(require,module,exports) {
"use strict";

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.simplifyFunctions = void 0;

const Literal_1 = __importDefault(require("../ast/Literal"));

const binaryOps = {
  "||": (a, b) => a || b,
  "&&": (a, b) => a && b,
  "+": (a, b) => a + b,
  "-": (a, b) => a - b,
  "*": (a, b) => a * b,
  "/": (a, b) => a / b,
  "**": (a, b) => a ** b,
  "^": (a, b) => a ^ b
};
const unaryOps = {
  "!": a => !a,
  "+": a => +a,
  "-": a => -a,
  "~": a => ~a
}; // that is some typescript kung fu right there.

exports.simplifyFunctions = {
  BinaryExpression(node, resolved) {
    let left = resolved.get(node.left);
    let right = resolved.get(node.right);

    if (Literal_1.default.is(left) && Literal_1.default.is(right)) {
      let value = binaryOps[node.operator](left.value, right.value);
      return new Literal_1.default({
        location: node.location,
        value
      });
    }
  },

  UnaryExpression(node) {
    if (Literal_1.default.is(node.argument)) {
      let value = unaryOps[node.operator](node.argument);
      return new Literal_1.default({
        location: node.location,
        value
      });
    }
  },

  Literal(node) {},

  ClassDeclaration(node) {},

  Parameter(node) {},

  VariableDeclaration(node) {},

  FunctionExpression(node) {},

  Reference(node) {},

  MemberExpression(node) {},

  ArrayExpression(node) {},

  CallExpression(node) {}

};

function evaluate(node, resolved, scopes) {
  var _a;

  let func = exports.simplifyFunctions[node.constructor.name];
  return (_a = func === null || func === void 0 ? void 0 : func(node, resolved, scopes)) !== null && _a !== void 0 ? _a : node;
}

exports.default = evaluate;
},{"../ast/Literal":"jxHw"}],"N6PL":[function(require,module,exports) {
"use strict";

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const common_1 = require("../common");

const ast_1 = require("../ast");

const toCodeString_1 = __importDefault(require("../toCodeString"));

const reassociateLeft = {
  "|": true,
  "&": true,
  "||": true,
  "&&": true,
  "+": true,
  "*": true
};
const reflectOperators = {
  "<": ">",
  ">": "<",
  ">=": "<=",
  "<=": ">=",
  "==": "==",
  "!=": "!="
};

function shouldSwapOrder(left, right) {
  if (ast_1.Literal.is(left) && !ast_1.Literal.is(right)) {
    return true;
  }

  return toCodeString_1.default(left).localeCompare(toCodeString_1.default(right)) > 0;
}

const normalize = common_1.memoize(function (e) {
  if (ast_1.BinaryExpression.is(e)) {
    let left = normalize(e.left);
    let right = normalize(e.right);
    let operator = e.operator;

    if (reassociateLeft[e.operator]) {
      if (ast_1.BinaryExpression.is(right) && right.operator === e.operator) {
        left = new ast_1.BinaryExpression({
          location: right.location,
          left: left,
          operator: e.operator,
          right: right.left
        }), right = right.right;
      }
    } // literal values should always be on the right.


    let canSwap = reflectOperators[operator] != null;

    if (canSwap && shouldSwapOrder(left, right)) {
      [left, right] = [right, left];
      operator = reflectOperators[operator];
    }

    if (left !== e.left || right !== e.right || operator !== e.operator) {
      e = e.patch({
        left,
        operator,
        right
      });
    }
  }

  return e;
}, true);
exports.default = normalize;
},{"../common":"gPgA","../ast":"tHlf","../toCodeString":"d3NE"}],"Yrsq":[function(require,module,exports) {
"use strict";

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const ast_1 = require("../ast");

const toCodeString_1 = __importDefault(require("../toCodeString"));

const common_1 = require("../common");

const traverse_1 = require("@glas/traverse");

const normalize_1 = __importDefault(require("./normalize"));

const splitExpressions_1 = __importDefault(require("./splitExpressions"));

function find(items, predicate) {
  for (let item of items) {
    if (predicate(item)) {
      return item;
    }
  }

  return null;
}

function equals(a, b) {
  return toCodeString_1.default(a) === toCodeString_1.default(b);
} // A && B || A => A


const simplify = common_1.memoize(function (e) {
  e = normalize_1.default(e);

  if (ast_1.TypeExpression.is(e)) {
    let value = simplify(e.value);

    if (e.value !== value) {
      e = e.patch({
        value
      });
    }
  }

  if (ast_1.BinaryExpression.is(e)) {
    const left = simplify(e.left);
    const right = simplify(e.right);

    if (equals(left, right)) {
      if (e.operator === "&&" || e.operator == "||" || e.operator === "&" || e.operator == "|") {
        //  A && A => A
        //  A || A => A
        //  A &  A => A
        //  A |  A => A
        return left;
      }
    } else if (e.operator === "||") {
      if (find(splitExpressions_1.default(left, "&&"), c => equals(c, right))) {
        // A && B || A => A
        return right;
      }

      if (find(splitExpressions_1.default(right, "&&"), c => equals(c, left))) {
        //  A || A && B => A
        return left;
      }

      if (find(splitExpressions_1.default(left, "||"), c => equals(c, right))) {
        // (A || B) || A => A || B
        return left;
      }

      if (find(splitExpressions_1.default(right, "||"), c => equals(c, left))) {
        //  A || (A && B) => A || B
        return right;
      }
    } else if (e.operator === "&&") {
      for (let c of splitExpressions_1.default(left, "||")) {
        if (equals(c, right)) {
          // (A || B) && A => A
          return right;
        }

        if (ast_1.UnaryExpression.is(right) && right.operator === "!" && equals(c, right.argument)) {
          //  (A || B) && !A => B
          //  (A || B || C) && !A => B || C
          return traverse_1.traverse(left, {
            // find and remove the impossible clause
            leave(node) {
              if (ast_1.BinaryExpression.is(node) && node.operator === "||") {
                if (equals(node.left, right.argument)) {
                  return node.right;
                }

                if (equals(node.right, right.argument)) {
                  return node.left;
                }
              }
            }

          });
        }
      }

      for (let c of splitExpressions_1.default(right, "||")) {
        if (equals(c, left)) {
          // A && (A || B) => A
          return left;
        }
      }
    } // should be normalized


    if (e.left !== left || e.right !== right) {
      e = e.patch({
        left,
        right
      });
    }
  } else if (ast_1.UnaryExpression.is(e)) {
    let argument = simplify(e.argument);
    if (e.operator === "!") if (e.argument !== argument) {
      e = e.patch({
        argument
      });
    }
  }

  return e;
}, true);
exports.default = simplify;
},{"../ast":"tHlf","../toCodeString":"d3NE","../common":"gPgA","@glas/traverse":"bYRw","./normalize":"N6PL","./splitExpressions":"inxk"}],"AtkL":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

const ast_1 = require("../ast");

function getLeftMostMemberObject(m) {
  while (ast_1.MemberExpression.is(m.object)) {
    m = m.object;
  }

  return m.object;
}

exports.default = getLeftMostMemberObject;
},{"../ast":"tHlf"}],"a9uC":[function(require,module,exports) {
"use strict";

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getMemberExpression = exports.combine = void 0;

const ast_1 = require("../ast");

const toCodeString_1 = __importDefault(require("../toCodeString"));

const combineExpressions_1 = __importDefault(require("./combineExpressions"));

const simplify_1 = __importDefault(require("./simplify"));

const splitExpressions_1 = __importDefault(require("./splitExpressions"));

const traverse_1 = require("@glas/traverse");

function combine(left, operator, right) {
  if (left == null) {
    return right;
  }

  if (right == null) {
    return left;
  }

  return new ast_1.BinaryExpression({
    left,
    operator,
    right
  });
}

exports.combine = combine;

function findAndReplaceMembers(e, member) {
  let count = 0;
  let result = traverse_1.traverse(e, {
    leave(node) {
      if (ast_1.MemberExpression.is(node.left) && ast_1.DotExpression.is(node.left.object)) {
        let dotProperty = node.left.property;

        if (toCodeString_1.default(dotProperty) === toCodeString_1.default(member)) {
          count++; // return the same expression, but remove the member expression so
          //  .foo is Bar => . is Bar

          return node.patch({
            left: node.left.object
          });
        }
      }
    }

  });
  return count > 0 ? result : null;
}

function getMemberExpression(e, member) {
  // must combine all member expression values
  let terms = [...splitExpressions_1.default(e)].map(e => {
    return findAndReplaceMembers(e, member);
  }).filter(e => e != null);
  return combineExpressions_1.default(terms);
}

exports.getMemberExpression = getMemberExpression;

function getMemberTypeExpression(t, member) {
  let e = t.value;
  let value = getMemberExpression(e, member);

  if (value == null) {
    return null;
  }

  value = ast_1.Reference.is(value) ? value : new ast_1.TypeExpression({
    value
  });
  return simplify_1.default(value);
}

exports.default = getMemberTypeExpression;
},{"../ast":"tHlf","../toCodeString":"d3NE","./combineExpressions":"WnvG","./simplify":"Yrsq","./splitExpressions":"inxk","@glas/traverse":"bYRw"}],"CXCz":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

const ast_1 = require("../ast");

function* getFinalStatements(node) {
  if (ast_1.BlockStatement.is(node)) {
    let last = node.body[node.body.length - 1];
    yield* getFinalStatements(last);
  } else if (ast_1.IfStatement.is(node)) {
    yield* getFinalStatements(node.consequent);

    if (node.alternate) {
      yield* getFinalStatements(node.alternate);
    }
  } else {
    yield node;
  }
}

exports.default = getFinalStatements;
},{"../ast":"tHlf"}],"phC5":[function(require,module,exports) {
"use strict";

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.simplifyType = exports.normalizeExpressions = void 0;

const ast_1 = require("../ast");

const simplify_1 = __importDefault(require("./simplify"));

function normalizeExpressions(node) {
  if (ast_1.TypeExpression.is(node)) {
    node = node.value;
  }

  if (ast_1.Reference.is(node)) {
    return new ast_1.BinaryExpression({
      location: node.location,
      left: new ast_1.DotExpression({}),
      operator: "is",
      right: node
    });
  }

  return node;
}

exports.normalizeExpressions = normalizeExpressions;

function simplifyType(type) {
  if (ast_1.Expression.is(type)) {
    type = simplify_1.default(type);
  }

  if (ast_1.TypeExpression.is(type)) {
    let {
      value
    } = type;

    if (ast_1.BinaryExpression.is(value) && ast_1.DotExpression.is(value.left) && value.operator === "is" && (ast_1.Reference.is(value.right) || ast_1.FunctionType.is(value.right))) {
      return value.right;
    }
  } else if (ast_1.Expression.is(type)) {
    type = new ast_1.TypeExpression({
      value: type
    });
  }

  return type;
}

exports.simplifyType = simplifyType;

function and(left, right) {
  if (left == null) {
    return right;
  }

  if (right == null) {
    return left;
  }

  left = simplify_1.default(normalizeExpressions(left));
  right = simplify_1.default(normalizeExpressions(right));
  return simplify_1.default(new ast_1.BinaryExpression({
    left,
    operator: "&&",
    right
  }));
}

exports.default = and;
},{"../ast":"tHlf","./simplify":"Yrsq"}],"CEaR":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

const ast_1 = require("../ast");

const common_1 = require("../common");

const negateOperators = {
  ">": "<=",
  "<": ">=",
  ">=": "<",
  "<=": ">",
  "==": "!=",
  "!=": "=="
}; // const primitiveTypes = {
//     "ion.String:String": true,
//     "ion.String:Number": true,
//     "ion.String:Boolean": true,
//     "ion.String:Array": true
//     "ion.String:Map": true,
//     "ion.String:Set": true,
//     "ion.String:Null": true,
//     "ion.String:Class": true,
//     "ion.String:Function": true,
// }
// // A | B & !A
// // what am I using this for anyways?
// function areTypesReferencesMutuallyExclusive(a: string, b: string): boolean {
//     return a !== b && (primitiveTypes[a] === true || primitiveTypes[b] === true)
// }

const negate = common_1.memoize(function (e) {
  if (ast_1.UnaryExpression.is(e)) {
    //  !!A => A
    if (e.operator === "!") {
      return e.argument;
    }
  }

  if (ast_1.BinaryExpression.is(e)) {
    let newOp = negateOperators[e.operator];

    if (newOp != null) {
      // !(A > B) => A <= B
      // !(A < B) => A >= B
      // !(A >= B) => A < B
      // !(A <= B) => A > B
      // !(A is B) => A isnt B
      // !(A isnt B) => A is B
      return e.patch({
        operator: newOp
      });
    }

    if (e.operator === "&&" || e.operator === "||") {
      // !(A && B) => !A || !B
      // !(A || B) => !A && !B
      return e.patch({
        left: negate(e.left),
        operator: e.operator === "&&" ? "||" : "&&",
        right: negate(e.right)
      });
    }
  } // !(A) => !A


  return new ast_1.UnaryExpression({
    location: e.location,
    operator: "!",
    argument: e
  });
}, true);
exports.default = negate;
},{"../ast":"tHlf","../common":"gPgA"}],"Q2Fc":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.typeProperties = exports.inferType = void 0;

const traverse_1 = require("@glas/traverse");

const ast_1 = require("../ast");

const ast = __importStar(require("../ast"));

const types = __importStar(require("../types"));

const createScopeMaps_1 = require("../createScopeMaps");

const getSortedTypedNodes_1 = __importStar(require("../analysis/getSortedTypedNodes"));

const evaluate_1 = __importDefault(require("../analysis/evaluate"));

const common_1 = require("../common");

const simplify_1 = __importDefault(require("../analysis/simplify"));

const toCodeString_1 = __importDefault(require("../toCodeString"));

const getLeftMostMemberObject_1 = __importDefault(require("../analysis/getLeftMostMemberObject"));

const splitExpressions_1 = __importDefault(require("../analysis/splitExpressions"));

const combineExpressions_1 = __importDefault(require("../analysis/combineExpressions"));

const getMemberTypeExpression_1 = __importDefault(require("../analysis/getMemberTypeExpression"));

const getFinalStatements_1 = __importDefault(require("../analysis/getFinalStatements"));

const combineTypeExpression_1 = __importStar(require("../analysis/combineTypeExpression"));

const negate_1 = __importDefault(require("../analysis/negate"));

const runtimeTypeChecking_1 = require("./runtimeTypeChecking");

const literalTypes = {
  boolean: types.Boolean,
  number: types.Number,
  object: types.Object,
  string: types.String
};
const binaryOperationsType = {
  "<": types.Boolean,
  ">": types.Boolean,
  "<=": types.Boolean,
  ">=": types.Boolean,
  "==": types.Boolean,
  "!=": types.Boolean,
  "is": types.Boolean,
  "&&": types.Boolean,
  "&": types.Number,
  "||": types.Boolean,
  "|": types.Number,
  "^": types.Number,
  "+": types.Number,
  "-": types.Number,
  "*": types.Number,
  "**": types.Number,
  "/": types.Number,
  "%": types.Number
};
const unaryOperationsType = {
  "!": types.Boolean,
  "+": types.Number,
  "-": types.Number
};

function is(type, left = new ast.DotExpression({})) {
  return new ast.BinaryExpression({
    location: type.location,
    left,
    operator: "is",
    right: type
  });
}

function getImpliedType(type, assertion, name) {
  //  we cannot further refine the type of function types or literals
  //  only references and type expressions
  if (ast.FunctionType.is(type) || ast.Literal.is(type)) {
    return type;
  }

  type = toTypeExpression(type);
  let found = 0;
  let assertType = assertion == null ? null : traverse_1.traverse(assertion, {
    leave(node) {
      if (ast.Reference.is(node) && node.name === name) {
        found++;
        return new ast.DotExpression({});
      }
    }

  }); // didn't find any means the expression was irrelevant to the type so we can ignore it

  if (found > 0) {
    type = combineTypeExpression_1.default(type, assertType);
  }

  type = combineTypeExpression_1.simplifyType(type);
  return type;
}
/**
 * Returns any Type object other than References which it will traverse.
 */


function getType(node, c) {
  if (ast.Reference.is(node)) {
    let declarator = getDeclarator(node, c);

    if (declarator != null) {
      let declaration = c.getResolved(c.getParent(declarator));

      if (ast.ClassDeclaration.is(declaration)) {
        // we want a type and that type will be the instanceType
        return declaration.instanceType;
      }

      let result = getType(declarator.type, c);
      return result;
    }
  }

  if (ast.Type.is(node)) {
    return node;
  }

  return null;
}

function getClassDeclaration(node, c) {
  let declarator = getDeclarator(node, c);

  if (declarator) {
    let baseDeclaration = c.getParent(declarator);
    baseDeclaration = c.getResolved(baseDeclaration);

    if (ast.ClassDeclaration.is(baseDeclaration)) {
      return baseDeclaration;
    }
  }

  return null;
}

function getFunctionType(node, c) {
  let type = getType(node, c);

  if (ast.FunctionType.is(type)) {
    return type;
  }

  if (ast.TypeExpression.is(type)) {
    // look inside and see if it implements a FunctionType
    for (let e of splitExpressions_1.default(type.value)) {
      if (ast.BinaryExpression.is(e) && e.operator === "is" && ast.DotExpression.is(e.left) && ast.FunctionType.is(e.right)) {
        return e.right;
      }
    }
  }

  return null;
}

function getConstructorType(node, c, returnType = null) {
  // if (node.isData) {
  //     console.log("------ not implemented data constructor types")
  //     // crap... we cannot actually
  //     // throw new Error("Not implemented data class constructor types")
  // }
  //  returnType is null on the first call, recursive calls pass in the original class type
  //  which should be the returnType patched onto any inherited constructor
  //  constructors can be inherited from base classes when not specified in subclasses
  let returnDefault = returnType == null;

  if (returnType == null) {
    returnType = new ast.Reference(node.id);
  }

  let ctor = node.instance.declarations.find(d => ast.VariableDeclaration.is(d) && d.id.name === "constructor");

  if (ctor == null) {
    for (let base of node.baseClasses) {
      let baseDeclaration = getClassDeclaration(base, c);

      if (baseDeclaration != null) {
        let baseType = getConstructorType(baseDeclaration, c, returnType);

        if (baseType != null) {
          return baseType.patch({
            returnType
          });
        }
      }
    }
  } else {
    // return the type of the ctor.
    let {
      value
    } = ctor;
    value = c.getResolved(value);

    if (value != null && ast.FunctionType.is(value === null || value === void 0 ? void 0 : value.type)) {
      return value.type;
    }
  } // default constructor


  return returnDefault ? new ast.FunctionType({
    params: [],
    returnType: new ast.Reference(node.id)
  }) : null;
}

function getDeclarator(node, c) {
  node = c.getResolved(node);
  let referencedNode = c.getDeclarator(node);

  if (ast.Reference.is(referencedNode)) {
    return c.getResolved(getDeclarator(referencedNode, c));
  } else if (ast.Declarator.is(referencedNode)) {
    return c.getResolved(referencedNode);
  } else {
    return null; // console.error(`Referenced node is not a declaration ${node.name}`, referencedNode)
    // throw new Error("Referenced node is not a declaration")
  }
}

function getChainedConditionalTypeAssertion(c, type, node, operator, negateValue) {
  let alist = common_1.getAncestorsAndSelfList(node, c.ancestors);
  let expressionIndex = alist.findIndex(node => {
    if (operator === "?") {
      return ast.ConditionalExpression.is(node);
    }

    return ast.BinaryExpression.is(node) && node.operator === operator;
  });

  if (expressionIndex >= 0) {
    let parent = c.getResolved(alist[expressionIndex]);

    if (ast.BinaryExpression.is(parent)) {
      //  check if we are the right side.
      //  the parent expression cannot have been resolved yet so we don't have to use resolved.
      if (parent.right === alist[expressionIndex - 1]) {
        // OK, now we just have to check the left side and find a reference with same name.
        // we can then definitely assert that the left expression is true
        let assertion = parent.left;

        if (negateValue) {
          assertion = negate_1.default(assertion);
        }

        return getImpliedType(type, assertion, node.name);
      }
    } else if (ast.ConditionalExpression.is(parent)) {
      let isConsequent = parent.consequent === alist[expressionIndex - 1];
      let isAlternate = parent.alternate === alist[expressionIndex - 1]; // type is only implied if we are in the consequent or alternate path
      //  otherwise we are in the test which implies nothing

      if (isConsequent || isAlternate) {
        let assertion = parent.test;

        if (isAlternate) {
          assertion = negate_1.default(assertion);
        }

        return getImpliedType(type, assertion, node.name);
      }
    }
  }

  return type;
}

function toTypeExpression(type) {
  if (ast.TypeExpression.is(type)) {
    return type;
  }

  if (ast.Reference.is(type) || ast.Literal.is(type)) {
    return new ast.TypeExpression({
      value: new ast.BinaryExpression({
        left: new ast.DotExpression({}),
        operator: ast.Reference.is(type) ? "is" : "==",
        right: type
      })
    });
  }

  if (ast.Expression.is(type)) {
    return new ast.TypeExpression({
      value: type
    });
  }

  return null; // throw new Error("getTypeExpression not implemented for " + type.constructor.name)
}

exports.inferType = {
  BinaryExpression(node) {
    // for now just use the left type
    let type = binaryOperationsType[node.operator];

    if (type == null) {
      throw common_1.SemanticError(`Could not find type for operator: ${node.operator}`, node);
    }

    return {
      type
    };
  },

  UnaryExpression(node) {
    // for now just use the left type
    let type = unaryOperationsType[node.operator];

    if (type == null) {
      throw common_1.SemanticError(`Could not find type for operator: ${node.operator}`, node);
    }

    return {
      type
    };
  },

  RegularExpression(node) {
    return {
      type: types.RegExp
    };
  },

  Literal(node) {
    // literals are their own type
    let literalType = literalTypes[typeof node.value];
    let baseType;

    if (Number.isInteger(node.value)) {
      literalType = types.Integer;
    }

    let type = toTypeExpression(combineTypeExpression_1.default(toTypeExpression(literalType), toTypeExpression(new ast.Literal({
      value: node.value
    }))));
    return {
      type
    };
  },

  ObjectExpression(node, c) {
    let expressions = [new ast.BinaryExpression({
      left: new ast.DotExpression({}),
      operator: "is",
      right: types.Object
    })];

    for (let p of node.properties) {
      if (ast.Property.is(p)) {
        if (p.key == null) {
          throw common_1.SemanticError("Key is required", p);
        }

        let pkey = c.getResolved(p.key);
        let pvalue = c.getResolved(p.value);

        if (pvalue.type == null) {
          console.log({
            pkey,
            pvalue
          });
        }

        expressions.push(new ast.BinaryExpression({
          left: new ast.MemberExpression({
            object: new ast.DotExpression({}),
            property: pkey
          }),
          operator: "is",
          right: pvalue.type
        }));
      } else {
        // Spread Element
        let arg = c.getResolved(p.argument);

        if (ast.TypeExpression.is(arg.type)) {
          for (let e of splitExpressions_1.default(arg.type.value, "&&")) {
            // ignore everything except member expressions
            if (ast.BinaryExpression.is(e) && ast.MemberExpression.is(e.left) && ast.DotExpression.is(getLeftMostMemberObject_1.default(e.left))) {
              let {
                left
              } = e; // remove any other BinaryExpressions with the same left value

              expressions = expressions.filter(check => !(ast.BinaryExpression.is(check) && toCodeString_1.default(check.left) == toCodeString_1.default(left))); // value = combineExpressions()
              // need ability to override properties in left type

              expressions.push(e);
            }
          }
        }
      }
    }

    let type = new ast.TypeExpression({
      value: combineExpressions_1.default(expressions)
    });
    return {
      type
    };
  },

  ArrayExpression(node, c) {
    let expressions = [new ast.BinaryExpression({
      left: new ast.DotExpression({}),
      operator: "is",
      right: types.Array
    })];
    let length = 0;
    let lengthKnown = true;
    let index = 0;

    for (let p of node.elements) {
      p = c.getResolved(p);

      if (ast.Expression.is(p)) {
        length++;

        if (p.type) {
          expressions.push(new ast.BinaryExpression({
            left: new ast.MemberExpression({
              object: new ast.DotExpression({}),
              property: new ast.Literal({
                value: index
              })
            }),
            operator: "is",
            right: p.type
          }));
        }
      } else if (ast.SpreadElement.is(p)) {
        let arg = c.getResolved(p.argument);
        let argType = getType(arg.type, c);

        if (ast.TypeExpression.is(argType)) {
          let foundLength = false;
          let baseLength = length; // save length before we add so we can offset indices

          for (let e of splitExpressions_1.default(argType.value)) {
            // ignore everything except member expressions
            if (ast.BinaryExpression.is(e) && ast.MemberExpression.is(e.left) && ast.DotExpression.is(e.left.object)) {
              if (ast.Identifier.is(e.left.property) && e.left.property.name === "length" && ast.Literal.is(e.right) && typeof e.right.value === "number") {
                if (e.operator === "==" || e.operator == ">=") {
                  if (e.operator === "==") {
                    foundLength = true;
                  }

                  length += e.right.value;
                }
              } //  if length is not known for sure, then we cannot assert index types
              //  theoretically... we COULD assert offset from right end of array


              if (lengthKnown && e.operator === "is" && ast.Literal.is(e.left.property) && typeof e.left.property.value === "number") {
                let {
                  left
                } = e; // remove any other BinaryExpressions with the same left value
                // expressions = expressions.filter(check => !(ast.BinaryExpression.is(check) && toCodeString(check.left) == toCodeString(left)))
                // value = combineExpressions()
                // need ability to override properties in left type

                let newIndex = baseLength + e.left.property.value; // the length must be at least large enough to hold this new index

                length = Math.max(length, newIndex + 1);
                expressions.push(e.patch({
                  left: e.left.patch({
                    property: new ast.Literal({
                      value: newIndex
                    })
                  })
                }));
              }
            }
          }

          if (!foundLength) {
            lengthKnown = false;
          }
        } else {
          console.log("ArrayExpression: Unexpected object type: " + toCodeString_1.default(arg.type));
        }
      }

      index++;
    } //  finally, insert a length property as a minimally known value
    //  if there are spread elements it could be larger


    expressions.splice(1, 0, new ast.BinaryExpression({
      left: new ast.MemberExpression({
        object: new ast.DotExpression({}),
        property: new ast.Identifier({
          name: "length"
        })
      }),
      operator: lengthKnown ? "==" : ">=",
      right: new ast.Literal({
        value: length
      })
    }));
    let type = new ast.TypeExpression({
      value: combineExpressions_1.default(expressions)
    });
    return {
      type
    }; // Type of ArrayExpression
    // For now... just Array reference?
    // we would need to find the common base type of multiple type expressions or references.

    return {
      type: types.Array
    };
  },

  ConditionalDeclaration(node, c) {
    var _a;

    const name = node.id.name;
    let [newKnownType, containingVarDeclarator] = getSortedTypedNodes_1.getContainingIfTestAndOriginalDeclarator(node, c.scopes, c.ancestors);
    newKnownType = c.getResolved(newKnownType);
    containingVarDeclarator = c.getResolved(containingVarDeclarator);

    if (node.negate) {
      newKnownType = negate_1.default(newKnownType);
    }

    let type = getImpliedType((_a = containingVarDeclarator === null || containingVarDeclarator === void 0 ? void 0 : containingVarDeclarator.type) !== null && _a !== void 0 ? _a : null, newKnownType, name);
    return {
      type
    };
  },

  ClassDeclaration(node, c) {
    // calculate a TypeExpression that can be used to compare these instances
    let instanceExpressions = new Array();
    instanceExpressions.push(is(new ast.Reference({
      name: node.id.path
    }))); // with normal (non-data) classes, we should combine actual instanceType from class 

    for (let base of node.baseClasses) {
      if (!node.isData) {
        let baseDeclaration = getClassDeclaration(base, c);

        if (baseDeclaration != null) {
          instanceExpressions.push(baseDeclaration.instanceType); // SKIP adding the reference is check beneath since this already contains it

          continue;
        }
      }

      instanceExpressions.push(is(base));
    }

    function* getAssertions(declarations) {
      for (let d of declarations) {
        d = c.getResolved(d);

        if (ast.VariableDeclaration.is(d)) {
          let dotMember = new ast.MemberExpression({
            object: new ast.DotExpression({}),
            property: d.id
          });

          switch (d.kind) {
            case "var":
              if (ast.TypeExpression.is(d.type)) {
                yield* [...splitExpressions_1.default(d.type.value)].map(term => runtimeTypeChecking_1.replaceNodes(term, ast.DotExpression.is, dotMember));
              } else {
                yield is(d.type, dotMember);
              }

              break;

            case "let":
              yield new ast.BinaryExpression({
                left: dotMember,
                operator: "==",
                right: d.value
              });
              break;
          }
        }
      }
    }

    instanceExpressions.push(...getAssertions(node.instance.declarations));
    let instanceType = new ast.TypeExpression({
      location: node.location,
      value: combineExpressions_1.default(instanceExpressions)
    }); // infer static types

    let type = new ast.TypeExpression({
      location: node.location,
      value: combineExpressions_1.default([is(getConstructorType(node, c)), is(types.Class), is(types.Function), ...getAssertions(node.static)])
    });
    return {
      instanceType,
      type
    };
  },

  Parameter(node, c) {
    var _a;

    return (_a = exports.inferType.VariableDeclaration) === null || _a === void 0 ? void 0 : _a.apply(this, arguments);
  },

  FunctionExpression(func, c) {
    var _a; // traverse and find all return types


    let returnType = func.returnType;

    if (returnType == null) {
      // see if we are a constructor...
      if (((_a = func.id) === null || _a === void 0 ? void 0 : _a.name) === "constructor") {
        let parent = c.getParent(func);

        if (ast.VariableDeclaration.is(parent) && parent.instance) {
          let clas = c.getAncestor(parent, ast.ClassDeclaration.is); // returnType is the containing class

          if (clas) {
            returnType = new ast.Reference({
              name: clas === null || clas === void 0 ? void 0 : clas.id.path
            });
          }
        }
      }

      if (returnType == null) {
        let returnTypes = [];
        traverse_1.traverse(func.body, {
          enter(node) {
            if (ast.ReturnStatement.is(node)) {
              let resolvedValue = c.getResolved(node.argument);

              if (resolvedValue.type != null) {
                returnTypes.push(resolvedValue.type);
              } else {
                // throw SemanticError(`Return Value type not resolved`, node)
                // console.log("type not resolved ===>", toCodeString(node.argument))
                if (returnTypes.indexOf(types.Any) < 0) {
                  returnTypes.push(types.Any);
                }
              }

              return traverse_1.skip;
            }
          }

        }); //  technically, IF the last statement of (every last branch of) a function
        //  is not a return statement then the function could return void.

        let finalStatements = [...getFinalStatements_1.default(func.body)];

        if (finalStatements.find(s => !ast.ReturnStatement.is(s)) != null) {
          returnTypes.push(types.Undefined);
        }

        if (returnTypes.length > 1) {
          let expressions = new Array();

          for (let i = returnTypes.length - 1; i >= 0; i--) {
            let type = returnTypes[i];
            expressions.push(ast.TypeExpression.is(type) ? type.value : new ast.BinaryExpression({
              left: new ast.DotExpression({}),
              operator: "is",
              right: type,
              location: type.location
            }));
          }

          returnType = simplify_1.default(new ast.TypeExpression({
            location: func.body.location,
            value: combineExpressions_1.default(expressions, "||")
          }));
        } else if (returnTypes.length === 0) {
          returnType = types.Undefined;
        } else if (returnTypes.length === 1) {
          returnType = returnTypes[0];
        }
      }
    } // we also need to infer the function signature type


    let type = func.type != null ? func.type : new ast.FunctionType({
      params: func.params.map(p => {
        var _a, _b;

        let ptype = (_b = (_a = c.getResolved(p)) === null || _a === void 0 ? void 0 : _a.type) !== null && _b !== void 0 ? _b : null;
        return ast.RestElement.is(p.id) ? new ast.SpreadElement({
          location: p.location,
          argument: ptype !== null && ptype !== void 0 ? ptype : types.Array
        }) : ptype;
      }),
      returnType
    });
    return {
      returnType,
      type
    };
  },

  VariableDeclaration(node, c) {
    let value = c.getResolved(node.value);

    if (node.type == null) {
      //  the "type" of a type declaration is the value
      //  otherwise the type is the values type
      let type;

      if ((value === null || value === void 0 ? void 0 : value.type) != null) {
        type = value === null || value === void 0 ? void 0 : value.type; //  if this variable is reassignable, then we remove the initial literal value
        //  from the variable type. So String & . == "foo" becomes => String

        if (node.kind === "var" && ast.TypeExpression.is(type)) {
          type = type.patch({
            value: combineExpressions_1.default([...splitExpressions_1.default(type.value)].filter(term => {
              if (ast.BinaryExpression.is(term) && term.operator === "==" && ast.DotExpression.is(term.left) && ast.Literal.is(term.right)) {
                return false;
              }

              return true;
            }))
          });
        }
      } else if (ast.Type.is(value)) {
        type = value;
      }

      return {
        type
      };
    } else if ((value === null || value === void 0 ? void 0 : value.type) != null) {
      // the variable has a type, so let's double check that the value type matches it.
      let check = c.isConsequent(toTypeExpression(value.type), toTypeExpression(node.type));

      if (check === false) {
        //  we only throw an error if we KNOW that a value is invalid.
        //  if it only might be invalid then we
        throw common_1.SemanticError(`Cannot assign type (${toCodeString_1.default(value.type)}) to type (${toCodeString_1.default(node.type)})`, node.value);
      }
    }
  },

  Declarator(node, c) {
    let parent = c.getResolved(c.getParent(node));

    if (ast_1.Typed.is(parent)) {
      return {
        type: parent.type
      };
    }
  },

  Reference(node, c) {
    var _a;

    let declarator = getDeclarator(node, c);
    let type = (_a = declarator === null || declarator === void 0 ? void 0 : declarator.type) !== null && _a !== void 0 ? _a : null;

    if (type == null) {
      // check if this is a reference to a global type
      let globalType = types[node.name];

      if ((globalType === null || globalType === void 0 ? void 0 : globalType.path) === node.path) {
        type = globalType;
      }
    } // Infer in chained conditionals here.
    // if we are the right side of a A & B conditional then that implies A


    type = getChainedConditionalTypeAssertion(c, type, node, "&&", false); // if we are the right side of a A | B optional then that implies not A

    type = getChainedConditionalTypeAssertion(c, type, node, "||", true); // if we are a consequent or alternate of an A ? B : C conditional that implies either A or not A

    type = getChainedConditionalTypeAssertion(c, type, node, "?");
    return {
      type
    };
  },

  AssignmentStatement(node, c) {
    let left = c.getResolved(node.left);
    let right = c.getResolved(node.right);

    if (left.type != null && right.type != null) {
      let check = c.isConsequent(toTypeExpression(right.type), toTypeExpression(left.type));

      if (check === false) {
        //  we only throw an error if we KNOW that a value is invalid.
        //  if it only might be invalid then we
        throw common_1.SemanticError(`Cannot assign type (${toCodeString_1.default(right.type)}) to type (${toCodeString_1.default(left.type)})`, left);
      }
    }
  },

  CallExpression(node, c) {
    var _a, _b;

    let callee = c.getResolved(node.callee);
    let calleeType = getFunctionType(callee.type, c);

    if (!ast.FunctionType.is(calleeType)) {
      // we don't know the type of the function so we won't type check
      return;
    } // console.log("......... CHECK PARAMETERS! " + toCodeString(calleeType))


    for (let i = 0; i < node.arguments.length; i++) {
      let arg = c.getResolved(node.arguments[i]);

      if (ast_1.Expression.is(arg)) {
        // get callee type
        let paramType = calleeType.params[i];

        if (paramType == null) {
          let lastType = calleeType.params[calleeType.params.length - 1];

          if (!ast.SpreadElement.is(lastType)) {
            throw common_1.SemanticError(`Target function only accepts ${calleeType.params.length} argument${calleeType.params.length === 1 ? '' : 's'}`, arg);
          }

          paramType = lastType;
        }

        if (ast.SpreadElement.is(paramType)) {
          let restType = paramType.argument;
          paramType = (_b = (_a = restType.arguments) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : null;
        }

        if (paramType != null && arg.type != null) {
          let check = c.isConsequent(toTypeExpression(arg.type), toTypeExpression(paramType));

          if (check === false) {
            //  we only throw an error if we KNOW that a value is invalid.
            //  if it only might be invalid then we
            throw common_1.SemanticError(`Argument of type (${toCodeString_1.default(arg.type)}) is not valid for expected parameter type (${toCodeString_1.default(paramType)})`, arg);
          } // console.log("(" + check + ") >>>>> " + toCodeString(arg) + " type " + toCodeString(arg.type) + " ::: " + toCodeString(paramType))

        }
      }
    }

    return {
      type: calleeType.returnType
    };
  },

  MemberExpression(node, c) {
    let object = c.getResolved(node.object);
    let objectType = getType(object.type, c);

    if (ast.TypeExpression.is(objectType)) {
      let property = c.getResolved(node.property);
      let type = getMemberTypeExpression_1.default(objectType, property);

      if (type != null) {
        return {
          type
        };
      }
    }
  }

};
exports.typeProperties = new Set(["type", "returnType", "instanceType"]);

class InferContext extends createScopeMaps_1.ScopeContext {
  constructor(root) {
    super(root, true);
    this.resolved = new Map();
  }

  setResolved(originalNode, currentNode) {
    this.resolved.set(originalNode, currentNode);

    if (originalNode !== currentNode) {
      // make sure that you can still get the correct scope for the new node
      this.scopes.set(currentNode, this.scopes.get(originalNode)); // same for ancestors map

      this.ancestors.set(currentNode, this.ancestors.get(originalNode));
    }
  }

  getResolved(node) {
    var _a;

    return (_a = this.resolved.get(node)) !== null && _a !== void 0 ? _a : node;
  }

}

function inferTypes(root, options) {
  let sc = new InferContext(root);
  let ancestorsMap = sc.ancestors;
  let scopes = sc.scopes;
  let resolved = sc.resolved;
  let sorted = getSortedTypedNodes_1.default(root, scopes, ancestorsMap); // let newTypeDeclarations = new Map<string, ast.TypeExpression>()
  // let typeNameToIdentifierName = new Map<string,string>()
  // let preferredTypeNameToIdentifierName = new Map<string,string>()
  // function getSharedTypeReference(node: ast.TypeExpression) {
  //     let name = toCodeString(node)
  //     let absoluteName = typeNameToIdentifierName.get(name)
  //     if (absoluteName == null) {
  //         let localName = preferredTypeNameToIdentifierName.get(name) ?? "?TYPE:" +name // idGenerator.createNewIdName(name)
  //         absoluteName = getModulePath("_types", localName)
  //         typeNameToIdentifierName.set(name, absoluteName)
  //         // see if we can find sub-nodes within this thingy
  //         let declaration = new ast.TypeExpression({
  //             value: traverse(node, {
  //                 leave(child) {
  //                     if (child !== node && Node.is(child)) {
  //                         let code = toCodeString(child)
  //                         let foundSubexpression = preferredTypeNameToIdentifierName.get(code)
  //                         if (foundSubexpression) {
  //                             return new ast.Reference({ name: foundSubexpression })
  //                         }
  //                     }
  //                 }
  //             })
  //         })
  //         newTypeDeclarations.set(absoluteName, declaration)
  //     }
  //     return new ast.Reference({ location: node.location, name: absoluteName })
  // }

  function ensureResolved(originalNode, resolveDependenciesFirst = false) {
    var _a;

    if (resolved.has(originalNode)) {
      return resolved.get(originalNode);
    }

    if (resolveDependenciesFirst) {
      for (let pred of getSortedTypedNodes_1.getPredecessors(originalNode, scopes, ancestorsMap)) {
        ensureResolved(pred, resolveDependenciesFirst);
      }
    } // first try to simplify


    let currentNode = (_a = resolved.get(originalNode)) !== null && _a !== void 0 ? _a : originalNode;
    currentNode = evaluate_1.default(currentNode, resolved, scopes);
    sc.setResolved(originalNode, currentNode); // then try to infer types

    let func = exports.inferType[currentNode.constructor.name];
    let changes = func === null || func === void 0 ? void 0 : func(currentNode, sc);

    if (changes != null) {
      if (ast_1.Typed.is(changes)) {
        // we track these so they don't get properties merged later but are returned as is.
        customConvertedNodes.add(changes);
        currentNode = changes;
      } else {
        currentNode = currentNode.patch(changes);
      }
    }

    sc.setResolved(originalNode, currentNode); // if (ast.Declaration.is(currentNode) && isAbsolute(currentNode.id.name)) {
    //     let name = currentNode.id.name
    //     let code = toCodeString(currentNode.type!)
    //     if (!ast.Reference.is(currentNode.type) && name.length < code.length) {
    //         preferredTypeNameToIdentifierName.set(code, `typeof ${sanitize(name)}`)
    //     }
    // }

    return currentNode;
  } // in order of preference: absolute path declaration... that's it.
  // we iterate all of the typed nodes in dependency order and resolve their actual types


  let customConvertedNodes = new Set();

  for (let originalNode of sorted) {
    ensureResolved(originalNode);
  } // console.log(preferredTypeNameToIdentifierName)


  return traverse_1.traverse(root, {
    enter(node) {
      if (ast.Location.is(node)) {
        return traverse_1.skip;
      }
    },

    merge(node, changes, helper) {
      let result = resolved.get(node);

      if (customConvertedNodes.has(result)) {
        return result;
      } // if (result) {
      //     for (let name of typeProperties) {
      //         let value = result[name]
      //         if (ast.TypeExpression.is(value)) {
      //             // move to a shared location and replace with a reference.
      //             result = result!.patch({ [name]: getSharedTypeReference(value) })
      //         }
      //     }
      // }


      if (result) {
        return ast_1.Node.is(changes) ? changes : helper.patch(result, changes);
      }
    }

  });
}

exports.default = inferTypes;
},{"@glas/traverse":"bYRw","../ast":"tHlf","../types":"xSXH","../createScopeMaps":"u957","../analysis/getSortedTypedNodes":"oseV","../analysis/evaluate":"Mlo2","../common":"gPgA","../analysis/simplify":"Yrsq","../toCodeString":"d3NE","../analysis/getLeftMostMemberObject":"AtkL","../analysis/splitExpressions":"inxk","../analysis/combineExpressions":"WnvG","../analysis/getMemberTypeExpression":"a9uC","../analysis/getFinalStatements":"CXCz","../analysis/combineTypeExpression":"phC5","../analysis/negate":"CEaR","./runtimeTypeChecking":"uwmd"}],"FX9C":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

function createTypeCheck(cls) {
  cls.implements = new Set();

  for (let baseClass of cls.baseClasses) {
    cls.implements.add(baseClass);

    for (let i of baseClass.implements) {
      cls.implements.add(i);
    }
  }

  return instance => {
    if (instance == null) {
      return false;
    }

    let ctor = instance.constructor;
    return ctor === cls || ctor.implements.has(cls);
  };
}

exports.default = createTypeCheck;
},{}],"aGfK":[function(require,module,exports) {
"use strict";

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const traverse_1 = require("@glas/traverse");

const ast_1 = require("../ast");

const runtimeTypeChecking_1 = require("./runtimeTypeChecking");

const inferTypes_1 = require("./inferTypes");

const common_1 = require("../common");

const createTypeCheck_1 = __importDefault(require("../../createTypeCheck"));

function createRuntime(root, options) {
  return traverse_1.traverse(root, {
    enter(node) {
      if (ast_1.VariableDeclaration.is(node) && node.kind === "type") {
        return traverse_1.skip;
      } // cannot skip TypeExprssions as we need to convert 'is' operators within them to is calls.
      // if (TypeExpression.is(node)) {
      //     return skip
      // }

    },

    leave(node, ancestors, path) {
      var _a;

      if (ast_1.Program.is(node)) {
        // insert an import of ionscript
        return node.patch({
          body: [new ast_1.ImportDeclaration({
            specifiers: [new ast_1.ImportNamespaceSpecifier({
              local: new ast_1.Declarator({
                name: common_1.runtimeModuleName
              })
            })],
            source: new ast_1.Literal({
              value: common_1.runtimeModuleName
            })
          }), ...node.body]
        });
      } //  types here.


      if (ast_1.TypeExpression.is(node)) {
        let last = path[path.length - 1];

        if (inferTypes_1.typeProperties.has(last)) {
          return null;
        }

        return node.value;
      }

      if (ast_1.DotExpression.is(node)) {
        return new ast_1.Reference({
          name: "value"
        });
      }

      if (ast_1.BinaryExpression.is(node) && node.operator === "is") {
        if (ast_1.Reference.is(node.right) || ast_1.RegularExpression.is(node.right) || ast_1.MemberExpression.is(node.right)) {
          return new ast_1.CallExpression({
            callee: new ast_1.MemberExpression({
              object: new ast_1.Reference({
                name: common_1.runtimeModuleName
              }),
              property: new ast_1.Identifier({
                name: "is"
              })
            }),
            arguments: [node.left, node.right]
          });
        } else {
          return runtimeTypeChecking_1.replaceNodes(node.right, ast_1.DotExpression.is, node.left);
        }
      } //  checked variables and things.


      if (ast_1.VariableDeclaration.is(node)) {
        if (node.static || node.instance) {
          if (node.kind === "let" && node.value != null && !ast_1.FunctionExpression.is(node.value)) {
            return node.patch({
              kind: "get",
              value: new ast_1.FunctionExpression({
                params: [],
                body: new ast_1.BlockStatement({
                  body: [new ast_1.ReturnStatement({
                    argument: node.value
                  })]
                })
              })
            });
          }
        }
      }

      if (ast_1.ClassDeclaration.is(node)) {
        let result = node;

        if (!node.isData) {
          //  iterate and find var variables with a default value
          let instanceVarsWithDefaults = node.instance.declarations.filter(d => d.kind === "var" && d.value != null);

          if (instanceVarsWithDefaults.length > 0) {
            let ctor = (_a = node.instance.declarations.find(d => d.id.name === "constructor")) !== null && _a !== void 0 ? _a : new ast_1.VariableDeclaration({
              kind: "let",
              id: new ast_1.Declarator({
                name: "constructor"
              }),
              value: new ast_1.FunctionExpression({
                params: [],
                body: new ast_1.BlockStatement({
                  body: []
                })
              })
            });
            let newCtor = ctor.patch({
              value: ctor.value.patch({
                body: new ast_1.BlockStatement({
                  body: [...instanceVarsWithDefaults.map(d => new ast_1.AssignmentStatement({
                    left: new ast_1.MemberExpression({
                      object: new ast_1.ThisExpression({}),
                      property: new ast_1.Identifier(d.id)
                    }),
                    right: d.value
                  })), ...ctor.value.body.body]
                })
              })
            });
            let newInstances = node.instance.declarations.map(d => d === ctor ? newCtor : d);

            if (newInstances.length === node.instance.declarations.length) {
              newInstances = [newCtor, ...newInstances];
            }

            result = result.patch({
              instance: new ast_1.InstanceDeclarations({
                declarations: newInstances
              }),
              instanceType: null
            });
          }
        } // remove extends from data classes


        if (node.isData) {
          result = result.patch({
            baseClasses: []
          });
        } //  handle static vars and typed vars


        let staticVarsWithDefaults = node.static.filter(d => d.kind === "var" && d.value != null);

        if (node.isData) {
          staticVarsWithDefaults.push(new ast_1.VariableDeclaration({
            static: new ast_1.Identifier({
              name: "static"
            }),
            kind: "var",
            id: new ast_1.Declarator({
              name: "baseClasses"
            }),
            value: new ast_1.CallExpression({
              new: true,
              callee: new ast_1.Reference({
                name: "Set"
              }),
              arguments: [new ast_1.ArrayExpression({
                elements: node.baseClasses
              })]
            })
          }));
          staticVarsWithDefaults.push(new ast_1.VariableDeclaration({
            static: new ast_1.Identifier({
              name: "static"
            }),
            kind: "var",
            id: new ast_1.Declarator({
              name: "is"
            }),
            value: new ast_1.CallExpression({
              callee: new ast_1.MemberExpression({
                object: new ast_1.Reference({
                  name: common_1.runtimeModuleName
                }),
                property: new ast_1.Identifier({
                  name: createTypeCheck_1.default.name.valueOf()
                })
              }),
              arguments: [new ast_1.Reference(node.id)]
            })
          }));
        }

        if (staticVarsWithDefaults.length > 0) {
          result = traverse_1.replace(result, ...staticVarsWithDefaults.map(d => new ast_1.AssignmentStatement({
            left: new ast_1.MemberExpression({
              object: new ast_1.Reference(node.id),
              property: new ast_1.Identifier(d.id)
            }),
            right: d.value
          })));
        }

        return result;
      }
    }

  });
}

exports.default = createRuntime;
},{"@glas/traverse":"bYRw","../ast":"tHlf","./runtimeTypeChecking":"uwmd","./inferTypes":"Q2Fc","../common":"gPgA","../../createTypeCheck":"FX9C"}],"PAQ2":[function(require,module,exports) {
"use strict";

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const traverse_1 = require("@glas/traverse");

const ast_1 = require("../ast");

const common_1 = require("../common");

const toCodeString_1 = __importDefault(require("../toCodeString"));

function semanticAnalysis(root, options) {
  return traverse_1.traverse(root, {
    enter(node, ancestors) {
      if (ast_1.VariableDeclaration.is(node)) {
        let container = ancestors[ancestors.length - 2];

        if (node.static && !ast_1.ClassDeclaration.is(container)) {
          throw common_1.SemanticError("static modifier only valid within class", node.static);
        }
      }

      if (ast_1.ClassDeclaration.is(node)) {
        if (!node.isData && node.baseClasses.length > 1) {
          throw common_1.SemanticError("only data classes support multiple inheritance", node.baseClasses[1]);
        }
      }

      if (ast_1.ElementExpression.is(node)) {
        if (node.close != null && toCodeString_1.default(node.kind) !== toCodeString_1.default(node.close)) {
          throw common_1.SemanticError("closing element does not match opening element", node.close);
        }
      }
    }

  });
}

exports.default = semanticAnalysis;
},{"@glas/traverse":"bYRw","../ast":"tHlf","../common":"gPgA","../toCodeString":"d3NE"}],"stDD":[function(require,module,exports) {
"use strict";

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const traverse_1 = require("@glas/traverse");

const ast_1 = require("../ast");

const createScopeMaps_1 = __importDefault(require("../createScopeMaps"));

const common_1 = require("../common");

const types_1 = require("../types");

const isConsequent_1 = __importDefault(require("../analysis/isConsequent"));
/*
export data struct Vector
    var x: Number = 0
    var y: Number = 0
    static class Array
        x: Float64Array
        // y: Float64Array
        get(i: Integer) =>
            return new Vector(this.x[i], this.x[i + 1])
        set(i: Integer, value: Vector) =>
            this.x[i] = value.x
            this.y[i+1] = value.y
        [Symbol.iterator]() =>
            // iteration here
*/


let fieldTypes = {
  Float64: 8,
  Float32: 4,
  Int32: 4,
  Int16: 2,
  Int8: 1,
  UInt32: 4,
  UInt16: 2,
  UInt8: 1
}; // let's start out WITHOUT recursion, then add that after

function getFieldType(type, scopes, ancestors) {
  if (ast_1.Reference.is(type)) {
    let fieldClass = common_1.getOriginalDeclaration(type, scopes, ancestors, ast_1.ClassDeclaration.is);

    if (fieldClass != null) {
      return type;
    }

    let variableDeclaration = common_1.getOriginalDeclaration(type, scopes, ancestors, ast_1.VariableDeclaration.is);

    if (variableDeclaration != null) {
      if (variableDeclaration.kind !== "type") {
        throw common_1.SemanticError("Expected a type declaration", type);
      }

      type = variableDeclaration.value;
    }
  }

  if (ast_1.TypeExpression.is(type)) {
    for (let name in types_1.IntegerTypes) {
      let integerType = types_1.IntegerTypes[name];

      if (isConsequent_1.default(type, integerType)) {
        return name;
      }
    }
  }

  return "Float64";
}

function assignActualFields(fields, actualFields = Array()) {
  let actualOffset = 0;

  for (let field of fields) {
    // try to find a pre-existing field that works.
    let actualIndex = actualFields.findIndex(a => {
      if (a.type === field.type) {
        let relativeOffset = field.offset - a.offset;
        let offsetByTypeSize = relativeOffset / fieldTypes[a.type];

        if (Number.isInteger(offsetByTypeSize)) {
          actualOffset = offsetByTypeSize;
          return true;
        }
      }

      return false;
    });

    if (actualIndex < 0) {
      actualIndex = actualFields.length;

      if (ast_1.Reference.is(field.type)) {
        assignActualFields(field.subfields, actualFields);
      } else {
        let actualField = {
          name: field.path,
          type: field.type,
          offset: field.offset,
          stride: -1
        };
        actualFields.push(actualField);
      }
    } // set field info


    field.actualField = actualIndex;
    field.actualOffset = actualOffset;
  }

  return actualFields;
}

function getFieldInfos(cls, scopes, ancestors, offset, path = []) {
  let fields = new Array();

  for (let d of cls.instance.declarations) {
    if (d.kind === "var") {
      if (d.type == null) {
        throw common_1.SemanticError("Type required on data struct properties", d);
      }

      let {
        name
      } = d.id;
      let type = getFieldType(d.type, scopes, ancestors);
      let subfields;

      if (ast_1.Reference.is(type)) {
        let fieldClass = common_1.getOriginalDeclaration(type, scopes, ancestors, ast_1.ClassDeclaration.is);

        if (fieldClass == null) {
          throw common_1.SemanticError(`Data struct not found`, type);
        }

        if (!fieldClass.isData || !fieldClass.isStruct) {
          throw common_1.SemanticError(`Data struct fields can only be Numbers or data structs`, fieldClass.id);
        }

        let result = getFieldInfos(fieldClass, scopes, ancestors, offset, path.concat(name));
        subfields = result[0];
        offset = result[1];
      }

      fields.push({
        name,
        path: path.concat(name).join('_'),
        offset,
        type,
        subfields,
        actualField: 0,
        actualOffset: 0
      });

      if (!ast_1.Reference.is(type)) {
        let fieldSize = fieldTypes[type];
        offset += fieldSize;
      }
    }
  }

  return [fields, offset];
}

function createTypedArrayDeclaration(cls, fields, actualFields, sizeInBytes, options) {
  function createFieldGetterOrSetter(field, setFrom) {
    if (ast_1.Reference.is(field.type)) {
      let {
        name
      } = field; // field.name

      let subfields = field.subfields.map(field => createFieldGetterOrSetter(field, setFrom ? new ast_1.MemberExpression({
        object: setFrom,
        property: new ast_1.Identifier({
          name
        })
      }) : setFrom));
      return setFrom ? subfields : new ast_1.CallExpression({
        new: true,
        callee: field.type,
        arguments: subfields
      });
    }

    let actualField = actualFields[field.actualField];
    let indexer = new ast_1.BinaryExpression({
      left: new ast_1.Reference({
        name: "index"
      }),
      operator: "*",
      right: new ast_1.Literal({
        value: actualField.stride
      })
    });

    if (field.actualOffset > 0) {
      indexer = new ast_1.BinaryExpression({
        left: indexer,
        operator: "+",
        right: new ast_1.Literal({
          value: field.actualOffset
        })
      });
    }

    let expression = new ast_1.MemberExpression({
      object: new ast_1.MemberExpression({
        object: new ast_1.ThisExpression({}),
        property: new ast_1.Identifier({
          name: actualField.name
        })
      }),
      property: indexer
    });
    return setFrom ? new ast_1.AssignmentStatement({
      left: expression,
      operator: "=",
      right: new ast_1.MemberExpression({
        object: setFrom,
        property: new ast_1.Identifier({
          name: field.name
        })
      })
    }) : expression;
  } // get function


  return new ast_1.VariableDeclaration({
    static: new ast_1.Identifier({
      name: "static"
    }),
    kind: "var",
    id: new ast_1.Declarator({
      name: "Array"
    }),
    value: new ast_1.ClassDeclaration({
      id: new ast_1.Declarator({
        name: `${cls.id.name}Array`
      }),
      instance: new ast_1.InstanceDeclarations({
        declarations: [// BEGIN CONSTRUCTOR
        new ast_1.VariableDeclaration({
          kind: "let",
          id: new ast_1.Declarator({
            name: "constructor"
          }),
          value: new ast_1.FunctionExpression({
            params: [new ast_1.Parameter({
              id: new ast_1.Declarator({
                name: "length"
              }),
              type: new ast_1.Reference({
                name: "Integer"
              })
            })],
            body: new ast_1.BlockStatement({
              body: [new ast_1.VariableDeclaration({
                kind: "let",
                id: new ast_1.Declarator({
                  name: "buffer"
                }),
                value: new ast_1.CallExpression({
                  new: true,
                  callee: new ast_1.Reference({
                    name: "ArrayBuffer"
                  }),
                  arguments: [new ast_1.BinaryExpression({
                    left: new ast_1.Reference({
                      name: "length"
                    }),
                    operator: "*",
                    right: new ast_1.Literal({
                      value: sizeInBytes
                    })
                  })]
                })
              }), new ast_1.AssignmentStatement({
                left: new ast_1.MemberExpression({
                  object: new ast_1.ThisExpression({}),
                  property: new ast_1.Identifier({
                    name: "length"
                  })
                }),
                right: new ast_1.Reference({
                  name: "length"
                })
              }), ...actualFields.map(field => new ast_1.AssignmentStatement({
                left: new ast_1.MemberExpression({
                  object: new ast_1.ThisExpression({}),
                  property: new ast_1.Identifier({
                    name: field.name
                  })
                }),
                right: new ast_1.CallExpression({
                  new: true,
                  callee: new ast_1.Reference({
                    name: `${field.type}Array`
                  }),
                  arguments: [new ast_1.Reference({
                    name: "buffer"
                  }), new ast_1.Literal({
                    value: field.offset
                  })]
                })
              })), options.debug ? new ast_1.ExpressionStatement({
                expression: new ast_1.CallExpression({
                  callee: new ast_1.MemberExpression({
                    object: new ast_1.Reference({
                      name: "Object"
                    }),
                    property: new ast_1.Identifier({
                      name: "freeze"
                    })
                  }),
                  arguments: [new ast_1.ThisExpression({})]
                })
              }) : []].flat()
            })
          })
        }), // BEGIN GETTER
        new ast_1.VariableDeclaration({
          kind: "let",
          id: new ast_1.Declarator({
            name: "get"
          }),
          value: new ast_1.FunctionExpression({
            params: [new ast_1.Parameter({
              id: new ast_1.Declarator({
                name: "index"
              })
            })],
            body: new ast_1.BlockStatement({
              body: [new ast_1.ReturnStatement({
                argument: new ast_1.CallExpression({
                  new: true,
                  callee: new ast_1.Reference({
                    name: cls.id.name
                  }),
                  arguments: fields.map(field => createFieldGetterOrSetter(field))
                })
              })]
            })
          })
        }), // BEGIN SETTER
        new ast_1.VariableDeclaration({
          kind: "let",
          id: new ast_1.Declarator({
            name: "set"
          }),
          value: new ast_1.FunctionExpression({
            params: [new ast_1.Parameter({
              id: new ast_1.Declarator({
                name: "index"
              })
            }), new ast_1.Parameter({
              id: new ast_1.Declarator({
                name: "value"
              })
            })],
            body: new ast_1.BlockStatement({
              body: fields.map(field => createFieldGetterOrSetter(field, new ast_1.Reference({
                name: "value"
              }))).flat()
            })
          })
        }), //  BEGIN ITERATOR
        new ast_1.VariableDeclaration({
          kind: "let",
          id: new ast_1.MemberExpression({
            object: new ast_1.Reference({
              name: "Symbol"
            }),
            property: new ast_1.Identifier({
              name: "iterator"
            })
          }),
          value: new ast_1.FunctionExpression({
            generator: true,
            params: [],
            body: new ast_1.BlockStatement({
              body: [new ast_1.VariableDeclaration({
                kind: "let",
                id: new ast_1.Declarator({
                  name: "length"
                }),
                value: new ast_1.MemberExpression({
                  object: new ast_1.ThisExpression({}),
                  property: new ast_1.Identifier({
                    name: "length"
                  })
                })
              }), new ast_1.ForStatement({
                init: new ast_1.VariableDeclaration({
                  kind: "var",
                  id: new ast_1.Declarator({
                    name: "i"
                  }),
                  value: new ast_1.Literal({
                    value: 0
                  })
                }),
                test: new ast_1.BinaryExpression({
                  left: new ast_1.Reference({
                    name: "i"
                  }),
                  operator: "<",
                  right: new ast_1.Reference({
                    name: "length"
                  })
                }),
                update: new ast_1.UnaryExpression({
                  prefix: false,
                  argument: new ast_1.Reference({
                    name: "i"
                  }),
                  operator: "++"
                }),
                body: new ast_1.BlockStatement({
                  body: [new ast_1.ExpressionStatement({
                    expression: new ast_1.YieldExpression({
                      argument: new ast_1.CallExpression({
                        callee: new ast_1.MemberExpression({
                          object: new ast_1.ThisExpression({}),
                          property: new ast_1.Identifier({
                            name: "get"
                          })
                        }),
                        arguments: [new ast_1.Reference({
                          name: "i"
                        })]
                      })
                    })
                  })]
                })
              })]
            })
          })
        })]
      }),
      static: []
    })
  });
}

function addTypedStructArrays(root, options) {
  let ancestors = new Map();
  let scopes = createScopeMaps_1.default(root, {
    ancestorsMap: ancestors
  });
  return traverse_1.traverse(root, {
    enter(node) {
      if (ast_1.TypeExpression.is(node)) {
        return traverse_1.skip;
      }
    },

    leave(node) {
      if (ast_1.ClassDeclaration.is(node) && node.isStruct && node.isData) {
        let [fields, naturalSize] = getFieldInfos(node, scopes, ancestors, 0);
        let actualFields = assignActualFields(fields); //  calculate stride for each actual field to move to the next element
        //  we have to pad each structure so that it ends at an even
        //  location to the largest contained type

        let largestTypeBytes = 0;

        for (let field of actualFields) {
          largestTypeBytes = Math.max(fieldTypes[field.type]);
        } //  we pad the size if needed so it ends at an even unit same as largest type size


        let paddedSize = Math.ceil(naturalSize / largestTypeBytes) * largestTypeBytes;

        for (let field of actualFields) {
          field.stride = paddedSize / fieldTypes[field.type];
        } // calculate stride for each actual field
        // console.log("==========> ", JSON.stringify(fields, null, 2), actualFields)


        console.log({
          largestTypeBytes,
          naturalSize,
          paddedSize,
          actualFields
        });
        return node.patch({
          static: [...node.static, createTypedArrayDeclaration(node, fields, actualFields, paddedSize, options)]
        });
      }
    }

  });
}

exports.default = addTypedStructArrays;
},{"@glas/traverse":"bYRw","../ast":"tHlf","../createScopeMaps":"u957","../common":"gPgA","../types":"xSXH","../analysis/isConsequent":"Gu3u"}],"p7cS":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.moduleExtension = void 0;
const babel_options = {
  plugins: [["@babel/plugin-transform-modules-commonjs", {
    noInterop: true
  }]]
};
exports.moduleExtension = ".mjs";

function toModuleFiles(output, options) {
  let modules = new Map();

  for (let path of output.modules.keys()) {
    let modernCode = output.modules.get(path); // create the modern modules with import/export syntax

    modules.set(path + exports.moduleExtension, modernCode); // create the nodejs compatible modules with require syntax

    if (options.emit) {
      let r = require; // don't want parcel resolving

      let babel = r("@babel/core");
      let nodejsCode = babel.transform(modernCode, babel_options).code;
      modules.set(path + ".js", nodejsCode);
    }
  }

  return { ...output,
    modules
  };
}

exports.default = toModuleFiles;
},{}],"CTXP":[function(require,module,exports) {
"use strict";

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.noEmit = exports.fast = void 0;

const parsing_1 = __importDefault(require("./parsing"));

const codegen_1 = __importDefault(require("./codegen"));

const toEsTree_1 = __importDefault(require("./toEsTree"));

const writeFiles_1 = __importDefault(require("./writeFiles"));

const controlFlowToExpressions_1 = __importDefault(require("./controlFlowToExpressions"));

const checkReferences_1 = __importDefault(require("./checkReferences"));

const createRuntime_1 = __importDefault(require("./createRuntime"));

const runtimeTypeChecking_1 = __importDefault(require("./runtimeTypeChecking"));

const semanticAnalysis_1 = __importDefault(require("./semanticAnalysis"));

const inferTypes_1 = __importDefault(require("./inferTypes"));

const addTypedStructArrays_1 = __importDefault(require("./addTypedStructArrays"));

const toModuleFiles_1 = __importDefault(require("./toModuleFiles"));

exports.fast = [parsing_1.default, controlFlowToExpressions_1.default, addTypedStructArrays_1.default, runtimeTypeChecking_1.default, createRuntime_1.default, toEsTree_1.default, codegen_1.default, toModuleFiles_1.default, writeFiles_1.default];
const defaultPhases = [parsing_1.default, semanticAnalysis_1.default, // fixImports,
// inheritBaseClasses,
controlFlowToExpressions_1.default, // createConditionalDeclarations,
// addDataClassConstructors,
checkReferences_1.default, inferTypes_1.default, addTypedStructArrays_1.default, // we could skip this.
runtimeTypeChecking_1.default, createRuntime_1.default, toEsTree_1.default, codegen_1.default, toModuleFiles_1.default, // no emit
writeFiles_1.default];
exports.default = defaultPhases; // we remove the last 6 phases if we're not emitting.

exports.noEmit = defaultPhases.slice(0, -1);
},{"./parsing":"ifyw","./codegen":"IUmA","./toEsTree":"RhB4","./writeFiles":"eqB6","./controlFlowToExpressions":"LRkx","./checkReferences":"RCa2","./createRuntime":"aGfK","./runtimeTypeChecking":"uwmd","./semanticAnalysis":"PAQ2","./inferTypes":"Q2Fc","./addTypedStructArrays":"stDD","./toModuleFiles":"p7cS"}],"UdBY":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var BaseObject = function () {
  function BaseObject() {}

  BaseObject.prototype.toString = function () {
    var className = this.constructor.name;
    return className + JSON.stringify(this);
  };

  return BaseObject;
}();

exports.default = BaseObject;
},{}],"RHHh":[function(require,module,exports) {
"use strict";

var __extends = this && this.__extends || function () {
  var extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

Object.defineProperty(exports, "__esModule", {
  value: true
});

var BaseObject_1 = require("./BaseObject");

var Rule = function (_super) {
  __extends(Rule, _super);

  function Rule() {
    var _this = _super !== null && _super.apply(this, arguments) || this;

    _this.isWhitespace = false;
    return _this;
  }

  Rule.passed = function (result) {
    return result !== Rule.failure;
  };

  Rule.prototype.parse = function (context) {
    context.pushRule(this);
    var saveOffset = context.offset;
    var saveState = context.state;
    var saveLocationFunc = context.location;

    context.location = function () {
      return context.getLocationCalculator().getLocation(saveOffset, context.offset, context.filename);
    };

    var result = this.parseInternal(context);

    if (!Rule.passed(result)) {
      context.offset = saveOffset;
      context.state = saveState;
    }

    context.popRule();
    context.location = saveLocationFunc;
    return result;
  };

  Rule.prototype.setName = function (name) {
    this.name = name;
    return this;
  };

  Rule.prototype.setLabel = function (label) {
    this.label = label;
    return this;
  };

  Rule.prototype.toString = function () {
    return this.label || _super.prototype.toString.call(this);
  };

  return Rule;
}(BaseObject_1.default);

Rule.failure = Symbol('Rule.failure');
exports.default = Rule;
},{"./BaseObject":"UdBY"}],"t1ns":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var Position = function () {
  function Position(offset, line, column) {
    this.offset = offset;
    this.line = line;
    this.column = column;
  }

  return Position;
}();

exports.default = Position;
},{}],"ApC5":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var Location = function () {
  function Location(start, end, filename) {
    this.start = start;
    this.end = end;
    this.filename = filename;
  }

  return Location;
}();

exports.default = Location;
},{}],"uEOl":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var Position_1 = require("./Position");

var Location_1 = require("./Location");

var LocationCalculator = function () {
  function LocationCalculator(source) {
    this.lines = [];
    this.columns = [];
    this.source = source;
    var line = 1;
    var column = 1;

    for (var i = 0; i <= source.length; i++) {
      this.lines[i] = line;
      this.columns[i] = column;

      if (source.charCodeAt(i) == 10) {
        line++;
        column = 1;
      } else {
        column++;
      }
    }
  }

  LocationCalculator.prototype.getLocation = function (start, end, filename) {
    return new Location_1.default(new Position_1.default(start, this.lines[start], this.columns[start]), new Position_1.default(end, this.lines[end], this.columns[end]), filename);
  };

  return LocationCalculator;
}();

exports.default = LocationCalculator;
},{"./Position":"t1ns","./Location":"ApC5"}],"J0Dr":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var Rule_1 = require("./Rule");

var LocationCalculator_1 = require("./LocationCalculator");

var Context = function () {
  function Context(grammar, source, filename) {
    this.offset = 0;
    this.state = {};
    this.failureOffsetStart = 0;
    this.failureOffsetFinish = 0;
    this.grammar = grammar;
    this.source = source;
    if (filename != null) this.filename = filename;
  }

  Context.prototype.getLines = function () {
    if (this.lines == null) this.lines = this.source.split(/\r?\n/g);
    return this.lines;
  };

  Context.prototype.getLine = function (indexStartingAtOne) {
    return this.getLines()[indexStartingAtOne - 1];
  };

  Context.prototype.getState = function (name, defaultValue) {
    if (defaultValue === void 0) {
      defaultValue = 0;
    }

    var value = this.state[name];
    if (value == null) value = defaultValue;
    return value;
  };

  Context.prototype.setState = function (name, value) {
    var newState = Object.assign({}, this.state);
    newState[name] = value;
    this.state = newState;
  };

  Context.prototype.pushRule = function (rule) {};

  Context.prototype.popRule = function () {};

  Context.prototype.failure = function (failureOffsetFinish) {
    if (failureOffsetFinish === void 0) {
      failureOffsetFinish = this.offset;
    }

    if (this.offset >= this.failureOffsetStart) {
      this.failureOffsetStart = this.offset;
      this.failureOffsetFinish = failureOffsetFinish;
    }

    return Rule_1.default.failure;
  };

  Context.prototype.getLocationCalculator = function () {
    if (this.locationCalculator == null) this.locationCalculator = new LocationCalculator_1.default(this.source);
    return this.locationCalculator;
  };

  return Context;
}();

exports.default = Context;
},{"./Rule":"RHHh","./LocationCalculator":"uEOl"}],"IY7d":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Reset = "\x1b[0m";
exports.Bright = "\x1b[1m";
exports.Dim = "\x1b[2m";
exports.Underscore = "\x1b[4m";
exports.Blink = "\x1b[5m";
exports.Reverse = "\x1b[7m";
exports.Hidden = "\x1b[8m";
exports.FgBlack = "\x1b[30m";
exports.FgRed = "\x1b[31m";
exports.FgGreen = "\x1b[32m";
exports.FgYellow = "\x1b[33m";
exports.FgBlue = "\x1b[34m";
exports.FgMagenta = "\x1b[35m";
exports.FgCyan = "\x1b[36m";
exports.FgWhite = "\x1b[37m";
exports.BgBlack = "\x1b[40m";
exports.BgRed = "\x1b[41m";
exports.BgGreen = "\x1b[42m";
exports.BgYellow = "\x1b[43m";
exports.BgBlue = "\x1b[44m";
exports.BgMagenta = "\x1b[45m";
exports.BgCyan = "\x1b[46m";
exports.BgWhite = "\x1b[47m";
},{}],"XaCn":[function(require,module,exports) {
"use strict";

var __extends = this && this.__extends || function () {
  var extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

Object.defineProperty(exports, "__esModule", {
  value: true
});

var Context_1 = require("./Context");

var Colors = require("./Colors");

function pad(text, length, insert) {
  if (insert === void 0) {
    insert = " ";
  }

  while (text.length < length) text = insert + text;

  return text;
}

function getRuleLabel(frames, offset) {
  for (var i = frames.length - 1; i >= 0; i--) {
    var frame = frames[i];
    if (frame.rule.label != null && frame.offset == offset) return frame.rule.label;
  }

  return frames[frames.length - 1].rule.toString();
}

var StackFrame = function () {
  function StackFrame(rule, offset) {
    this.rule = rule;
    this.offset = offset;
  }

  return StackFrame;
}();

var ErrorContext = function (_super) {
  __extends(ErrorContext, _super);

  function ErrorContext(context) {
    var _this = _super.call(this, context.grammar, context.source, context.filename) || this;

    _this.ruleStack = [];
    _this.errorStacks = [];
    _this.debugErrorOffsetStart = context.failureOffsetStart;
    _this.debugErrorOffsetFinish = context.failureOffsetFinish;
    return _this;
  }

  ErrorContext.prototype.pushRule = function (rule) {
    this.ruleStack.push(new StackFrame(rule, this.offset));
  };

  ErrorContext.prototype.popRule = function () {
    this.ruleStack.pop();
  };

  ErrorContext.prototype.failure = function (failureOffsetFinish) {
    if (failureOffsetFinish === void 0) {
      failureOffsetFinish = this.offset;
    }

    if (this.offset == this.debugErrorOffsetStart) {
      this.errorStacks.push(this.ruleStack.slice(0));
    }

    return _super.prototype.failure.call(this, failureOffsetFinish);
  };

  ErrorContext.prototype.getExpected = function (includeWhitespace) {
    var expected = [];

    for (var _i = 0, _a = this.errorStacks; _i < _a.length; _i++) {
      var stack = _a[_i];

      if (includeWhitespace || !stack[stack.length - 1].rule.isWhitespace) {
        var label = getRuleLabel(stack, this.debugErrorOffsetStart);
        if (expected.indexOf(label) < 0 && label.length > 0) expected.push(label);
      }
    }

    return expected;
  };

  ErrorContext.prototype.wrapErrorLine = function (lineNumber, errorLocation, start, end) {
    var lineText = this.getLine(lineNumber);
    if (lineText == null) return null;
    if (lineNumber < errorLocation.start.line || lineNumber > errorLocation.end.line) return lineText;
    if (lineNumber > errorLocation.start.line && lineNumber < errorLocation.end.line) return start + lineText + end;
    var startIndex = lineNumber == errorLocation.start.line ? errorLocation.start.column : 0;
    var endIndex = lineNumber == errorLocation.end.line ? errorLocation.end.column : lineText.length + 1;

    if (startIndex >= lineText.length) {
      var append = Colors.Dim + " ";
      lineText += append;
      endIndex = startIndex + append.length;
    }

    if (startIndex == endIndex) endIndex += 1;
    var result = lineText.substring(0, startIndex - 1) + start + lineText.substring(startIndex - 1, endIndex - 1) + end + lineText.substring(endIndex - 1);
    return result;
  };

  ErrorContext.prototype.getLinesWithNumbers = function (startLine, endLine, errorLocation) {
    var lineDigits = Math.max(Math.max(0, startLine).toString().length, endLine.toString().length);
    var linePrefix = "| ";
    var lines = [];

    for (var i = startLine; i <= endLine; i++) {
      var line = this.wrapErrorLine(i, errorLocation, Colors.BgMagenta, Colors.Reset);

      if (line != null) {
        lines.push(Colors.Dim + pad(i.toString(), lineDigits) + linePrefix + Colors.Reset + line);
      }
    }

    return [lineDigits + linePrefix.length, lines.join('\n')];
  };

  ErrorContext.prototype.getError = function (errorDescription, location) {
    if (location == null) location = this.getLocationCalculator().getLocation(this.debugErrorOffsetStart, this.debugErrorOffsetFinish, this.filename);
    var filename = location.filename;
    var errorLine = location.start.line;

    var _a = this.getLinesWithNumbers(errorLine - 2, errorLine + 2, location),
        padLength = _a[0],
        lines = _a[1];

    if (errorDescription == null) {
      var expected = this.getExpected(false);
      if (expected.length == 0) expected = this.getExpected(true);
      errorDescription = "Expected " + expected.join(" or ");
    }

    var message = "\n" + errorDescription + "\n\n" + Colors.Dim + pad("", padLength - 1, "/") + " " + filename + "\n" + Colors.Reset + lines + "\n\n" + pad(" ", padLength) + "\n";
    var error = new Error(message);
    error.description = errorDescription;
    error.location = location;
    return error;
  };

  return ErrorContext;
}(Context_1.default);

exports.default = ErrorContext;
},{"./Context":"J0Dr","./Colors":"IY7d"}],"ORKK":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var Rule_1 = require("./Rule");

var Context_1 = require("./Context");

var ErrorContext_1 = require("./ErrorContext");

var Parser = function () {
  function Parser(grammar, options) {
    if (options === void 0) {
      options = {};
    }

    this.grammar = grammar;
    this.options = options;
  }

  Parser.prototype.parse = function (source, filename) {
    var start = this.options.start ? this.grammar.rules[this.options.start] : this.grammar.start;
    this.context = new Context_1.default(this.grammar, source, filename);
    var value = start.parse(this.context);
    if (Rule_1.default.passed(value)) return value;
    var errorContext = new ErrorContext_1.default(this.context);
    this.context = errorContext;
    start.parse(errorContext);
    throw errorContext.getError();
  };

  Parser.prototype.getError = function (description, location, source, filename) {
    var context = new Context_1.default(this.grammar, source, filename);
    var errorContext = new ErrorContext_1.default(context);
    return errorContext.getError(description, location);
  };

  return Parser;
}();

exports.default = Parser;
},{"./Rule":"RHHh","./Context":"J0Dr","./ErrorContext":"XaCn"}],"EbUl":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var Grammar = function () {
  function Grammar(rules, start) {
    if (start === void 0) {
      start = rules[0];
    }

    this.rules = {};

    for (var _i = 0, rules_1 = rules; _i < rules_1.length; _i++) {
      var rule = rules_1[_i];
      this.rules[rule.name] = rule;
    }

    this.start = start;
  }

  return Grammar;
}();

exports.default = Grammar;
},{}],"UPqq":[function(require,module,exports) {
"use strict";

var __extends = this && this.__extends || function () {
  var extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function (d, b) {
    d.__proto__ = b;
  } || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
  };

  return function (d, b) {
    extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();

Object.defineProperty(exports, "__esModule", {
  value: true
});

var Rule_1 = require("./Rule");

function createFunctionFromBody(rules, body) {
  var namesToIndexes = {};

  for (var i = 0; i < rules.length; i++) {
    var name_1 = rules[i].name;
    if (name_1 != null) namesToIndexes[name_1] = i;
  }

  var localVariables = Object.keys(namesToIndexes).map(function (name) {
    var index = namesToIndexes[name];
    return "let " + name + " = __values[" + index + "]";
  }).join(";\n");
  var functionText = "(function(__context, __values) {" + localVariables + ";\n" + body + "})";
  return eval(functionText);
}

var Terminal = function (_super) {
  __extends(Terminal, _super);

  function Terminal(match) {
    var _this = _super.call(this) || this;

    _this.match = match;
    _this.isWhitespace = match.trim().length == 0;
    return _this;
  }

  Terminal.prototype.parseInternal = function (context) {
    var source = context.source;
    var match = this.match;

    for (var i = 0, k = context.offset; i < this.match.length; i++, k++) {
      if (source.charCodeAt(k) !== match.charCodeAt(i)) {
        return context.failure(k);
      }
    }

    context.offset += this.match.length;
    return this.match;
  };

  Terminal.prototype.toString = function () {
    return JSON.stringify(this.match);
  };

  return Terminal;
}(Rule_1.default);

exports.Terminal = Terminal;

var CharRange = function (_super) {
  __extends(CharRange, _super);

  function CharRange(lower, upper, ignoreCase, inverted) {
    if (ignoreCase === void 0) {
      ignoreCase = false;
    }

    if (inverted === void 0) {
      inverted = false;
    }

    var _this = _super.call(this) || this;

    _this.ignoreCase = ignoreCase;
    _this.inverted = inverted;
    _this.lower = lower.charCodeAt(0);
    _this.upper = upper.charCodeAt(0);
    if (_this.lower > _this.upper) throw new Error("Lower and upper characters are in wrong order!");
    return _this;
  }

  CharRange.prototype.parseInternal = function (context) {
    var ch = context.source.charAt(context.offset);
    if ((this.charMatches(ch) || this.ignoreCase && this.charMatches(this.flipCase(ch))) != this.inverted) return context.source[context.offset++];else return context.failure();
  };

  CharRange.prototype.charMatches = function (ch) {
    var code = ch.charCodeAt(0);
    return this.lower <= code && this.upper >= code;
  };

  CharRange.prototype.flipCase = function (ch) {
    return ch.toUpperCase() === ch ? ch.toLowerCase() : ch.toUpperCase();
  };

  CharRange.prototype.toString = function () {
    return this.label || (this.inverted ? '[^' : '[') + String.fromCharCode(this.lower) + '-' + String.fromCharCode(this.upper) + (this.ignoreCase ? ']i' : ']');
  };

  return CharRange;
}(Rule_1.default);

exports.CharRange = CharRange;

var Regex = function (_super) {
  __extends(Regex, _super);

  function Regex(regex) {
    var _this = _super.call(this) || this;

    _this.regex = regex;
    return _this;
  }

  Regex.prototype.parseInternal = function (context) {
    this.regex.lastIndex = context.offset;
    var result = context.source.match(this.regex);

    if (result != null) {
      context.offset += result[0].length;
      return result[0];
    }

    return context.failure(context.offset);
  };

  Regex.prototype.toString = function () {
    return '/' + this.regex.source + '/';
  };

  return Regex;
}(Rule_1.default);

exports.Regex = Regex;

var Reference = function (_super) {
  __extends(Reference, _super);

  function Reference(reference) {
    var _this = _super.call(this) || this;

    _this.reference = reference;
    return _this;
  }

  Reference.prototype.parseInternal = function (context) {
    var rule = context.grammar.rules[this.reference];
    return rule.parse(context);
  };

  return Reference;
}(Rule_1.default);

exports.Reference = Reference;

var Any = function (_super) {
  __extends(Any, _super);

  function Any() {
    return _super !== null && _super.apply(this, arguments) || this;
  }

  Any.prototype.parseInternal = function (context) {
    var char = context.source[context.offset];

    if (char == null) {
      return context.failure();
    } else {
      context.offset++;
      return char;
    }
  };

  return Any;
}(Rule_1.default);

exports.Any = Any;

var Sequence = function (_super) {
  __extends(Sequence, _super);

  function Sequence() {
    var rules = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      rules[_i] = arguments[_i];
    }

    var _this = _super.call(this) || this;

    _this.rules = rules;
    return _this;
  }

  Sequence.prototype.parseInternal = function (context) {
    var consumed = 0;
    var values = [];
    var index = 0;

    for (var _i = 0, _a = this.rules; _i < _a.length; _i++) {
      var rule = _a[_i];
      context.rules = this.rules;
      context.values = values;
      var value = rule.parse(context);
      if (!Rule_1.default.passed(value)) return value;
      values.push(value);
      index++;
    }

    return values;
  };

  return Sequence;
}(Rule_1.default);

exports.Sequence = Sequence;

var Choice = function (_super) {
  __extends(Choice, _super);

  function Choice() {
    var rules = [];

    for (var _i = 0; _i < arguments.length; _i++) {
      rules[_i] = arguments[_i];
    }

    var _this = _super.call(this) || this;

    _this.rules = rules;
    return _this;
  }

  Choice.prototype.parseInternal = function (context) {
    for (var _i = 0, _a = this.rules; _i < _a.length; _i++) {
      var rule = _a[_i];
      var value = rule.parse(context);
      if (Rule_1.default.passed(value)) return value;
    }

    return Rule_1.default.failure;
  };

  return Choice;
}(Rule_1.default);

exports.Choice = Choice;

var Repeat = function (_super) {
  __extends(Repeat, _super);

  function Repeat(rule, min, max) {
    if (min === void 0) {
      min = 0;
    }

    if (max === void 0) {
      max = -1;
    }

    var _this = _super.call(this) || this;

    _this.rule = rule;
    _this.max = max;
    _this.min = min;
    return _this;
  }

  Repeat.prototype.parseInternal = function (context) {
    var matches = 0;
    var values = [];
    var min = typeof this.min == 'string' ? context.state[this.min] : this.min;
    var max = typeof this.min == 'string' ? context.state[this.max] : this.max;

    while (matches != max) {
      var value = this.rule.parse(context);

      if (Rule_1.default.passed(value)) {
        matches++;
        values.push(value);
      } else {
        if (matches < min) return value;
        break;
      }
    }

    return values;
  };

  return Repeat;
}(Rule_1.default);

exports.Repeat = Repeat;

var Optional = function (_super) {
  __extends(Optional, _super);

  function Optional(rule) {
    var _this = _super.call(this) || this;

    _this.rule = rule;
    return _this;
  }

  Optional.prototype.parseInternal = function (context) {
    var value = this.rule.parse(context);
    if (Rule_1.default.passed(value)) return value;
    return null;
  };

  Optional.prototype.toString = function () {
    return this.label || "(" + this.rule + ")?";
  };

  return Optional;
}(Rule_1.default);

exports.Optional = Optional;

var NotPredicate = function (_super) {
  __extends(NotPredicate, _super);

  function NotPredicate(rule) {
    var _this = _super.call(this) || this;

    _this.rule = rule;
    return _this;
  }

  NotPredicate.prototype.parseInternal = function (context) {
    var initialOffset = context.offset;
    var value = this.rule.parse(context);
    context.offset = initialOffset;

    if (Rule_1.default.passed(value)) {
      return context.failure();
    }

    return undefined;
  };

  NotPredicate.prototype.toString = function () {
    return "!" + this.rule;
  };

  return NotPredicate;
}(Rule_1.default);

exports.NotPredicate = NotPredicate;

var AndPredicate = function (_super) {
  __extends(AndPredicate, _super);

  function AndPredicate(rule) {
    var _this = _super.call(this) || this;

    _this.rule = rule;
    return _this;
  }

  AndPredicate.prototype.parseInternal = function (context) {
    var initialOffset = context.offset;
    var value = this.rule.parse(context);

    if (Rule_1.default.passed(value)) {
      context.offset = initialOffset;
      return undefined;
    }

    return value;
  };

  AndPredicate.prototype.toString = function () {
    return "&" + this.rule;
  };

  return AndPredicate;
}(Rule_1.default);

exports.AndPredicate = AndPredicate;

var StringValue = function (_super) {
  __extends(StringValue, _super);

  function StringValue(rule) {
    var _this = _super.call(this) || this;

    _this.rule = rule;
    return _this;
  }

  StringValue.prototype.parseInternal = function (context) {
    var initialOffset = context.offset;
    var value = this.rule.parse(context);

    if (Rule_1.default.passed(value)) {
      value = context.source.substring(initialOffset, context.offset);
    }

    return value;
  };

  StringValue.prototype.toString = function () {
    return "$" + this.rule;
  };

  return StringValue;
}(Rule_1.default);

exports.StringValue = StringValue;

var Extract = function (_super) {
  __extends(Extract, _super);

  function Extract(sequence, index) {
    var _this = this;

    if (index < 0 || index >= sequence.rules.length) throw new Error("Invalid index: " + index);
    _this = _super.call(this) || this;
    _this.sequence = sequence;
    _this.index = index;
    return _this;
  }

  Extract.prototype.parseInternal = function (context) {
    var value = this.sequence.parseInternal(context);
    if (Rule_1.default.passed(value)) value = value[this.index];
    return value;
  };

  return Extract;
}(Rule_1.default);

exports.Extract = Extract;

var Group = function (_super) {
  __extends(Group, _super);

  function Group(rule) {
    var _this = _super.call(this) || this;

    _this.rule = rule;
    return _this;
  }

  Group.prototype.parseInternal = function (context) {
    return this.rule.parse(context);
  };

  Group.prototype.toString = function () {
    return "(" + this.rule + ")";
  };

  return Group;
}(Rule_1.default);

exports.Group = Group;

var Increment = function (_super) {
  __extends(Increment, _super);

  function Increment(varName, step) {
    if (step === void 0) {
      step = 1;
    }

    var _this = _super.call(this) || this;

    _this.varName = varName;
    _this.step = step;
    return _this;
  }

  Increment.prototype.parseInternal = function (context) {
    context.setState(this.varName, context.getState(this.varName) + this.step);
    return undefined;
  };

  Increment.prototype.toString = function () {
    var suffix = this.step == 1 ? "++" : this.step == -1 ? "--" : "+= " + this.step;
    return this.varName + suffix;
  };

  return Increment;
}(Rule_1.default);

exports.Increment = Increment;

var Action = function (_super) {
  __extends(Action, _super);

  function Action(sequence, handler) {
    var _this = _super.call(this) || this;

    _this.sequence = sequence;
    if (typeof handler == 'string') handler = createFunctionFromBody(sequence.rules, handler);
    _this.handler = handler;
    return _this;
  }

  Action.prototype.parseInternal = function (context) {
    var value = this.sequence.parseInternal(context);

    if (Rule_1.default.passed(value)) {
      value = this.handler(context, value);
    }

    return value;
  };

  return Action;
}(Rule_1.default);

exports.Action = Action;

var CustomPredicate = function (_super) {
  __extends(CustomPredicate, _super);

  function CustomPredicate(handlerBody) {
    var _this = _super.call(this) || this;

    _this.handlerBody = handlerBody;
    return _this;
  }

  CustomPredicate.prototype.setHandler = function (handlerFunction) {
    this.handlerFunction = handlerFunction;
    return this;
  };

  CustomPredicate.prototype.parseInternal = function (context) {
    if (context.rules == null || context.values == null) throw new Error("CustomPredicate requires context.rules and context.values");

    if (this.handlerFunction == null) {
      var precedingRules = context.rules.slice(0, context.values.length);
      this.handlerFunction = createFunctionFromBody(precedingRules, this.handlerBody);
    }

    if (this.handlerFunction(context, context.values)) return undefined;
    return context.failure();
  };

  CustomPredicate.prototype.toString = function () {
    return "&{" + this.handlerBody + "}";
  };

  return CustomPredicate;
}(Rule_1.default);

exports.CustomPredicate = CustomPredicate;
},{"./Rule":"RHHh"}],"PLlZ":[function(require,module,exports) {
"use strict";

function __export(m) {
  for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}

Object.defineProperty(exports, "__esModule", {
  value: true
});

var Context_1 = require("./Context");

exports.Context = Context_1.default;

var Parser_1 = require("./Parser");

exports.Parser = Parser_1.default;

var Grammar_1 = require("./Grammar");

exports.Grammar = Grammar_1.default;

var Position_1 = require("./Position");

exports.Position = Position_1.default;

var Rule_1 = require("./Rule");

exports.Rule = Rule_1.default;

var Location_1 = require("./Location");

exports.SourceLocation = Location_1.default;

__export(require("./Rules"));
},{"./Context":"J0Dr","./Parser":"ORKK","./Grammar":"EbUl","./Position":"t1ns","./Rule":"RHHh","./Location":"ApC5","./Rules":"UPqq"}],"rnKD":[function(require,module,exports) {
"use strict";

function __export(m) {
  for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}

Object.defineProperty(exports, "__esModule", {
  value: true
});

__export(require("./runtime"));
},{"./runtime":"PLlZ"}],"ifA8":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isPosition = exports.Position = void 0;

const Number = __importStar(require("./ion/Number"));

const Class = __importStar(require("./ion/Class"));

class Position {
  constructor(offset, line, column) {
    if (!Number.isNumber(offset)) throw new Error('offset is not a Number: ' + Class.toString(offset));
    if (!Number.isNumber(line)) throw new Error('line is not a Number: ' + Class.toString(line));
    if (!Number.isNumber(column)) throw new Error('column is not a Number: ' + Class.toString(column));
    this.offset = offset;
    this.line = line;
    this.column = column;
    Object.freeze(this);
  }

  static is(value) {
    return isPosition(value);
  }

}

exports.Position = Position;
Position.id = 'Position';
Position.implements = new Set(['Position', 'ion_Object']);

function isPosition(value) {
  return Class.isInstance(Position, value);
}

exports.isPosition = isPosition;
exports.default = Position;
},{"./ion/Number":"Zizk","./ion/Class":"iy0N"}],"WmoZ":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isLocation = exports.Location = void 0;

const Position = __importStar(require("./Position"));

const String = __importStar(require("./ion/String"));

const Class = __importStar(require("./ion/Class"));

class Location {
  constructor({
    start,
    end,
    filename
  }) {
    if (!Position.isPosition(start)) throw new Error('start is not a Position: ' + Class.toString(start));
    if (!Position.isPosition(end)) throw new Error('end is not a Position: ' + Class.toString(end));
    if (!String.isString(filename)) throw new Error('filename is not a String: ' + Class.toString(filename));
    this.start = start;
    this.end = end;
    this.filename = filename;
    Object.freeze(this);
  }

  patch(properties) {
    return new Location({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isLocation(value);
  }

}

exports.Location = Location;
Location.id = 'Location';
Location.implements = new Set(['Location', 'ion_Object']);

function isLocation(value) {
  return Class.isInstance(Location, value);
}

exports.isLocation = isLocation;
exports.default = Location;
},{"./Position":"ifA8","./ion/String":"CAX3","./ion/Class":"iy0N"}],"xMkn":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isAnalysis = exports.Analysis = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Map = __importStar(require("./ion/Map"));

const Class = __importStar(require("./ion/Class"));

class Analysis {
  constructor({
    location = null,
    declarations
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!Map.isMap(declarations)) throw new Error('declarations is not a Map: ' + Class.toString(declarations));
    this.location = location;
    this.declarations = declarations;
    Object.freeze(this);
  }

  patch(properties) {
    return new Analysis({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isAnalysis(value);
  }

}

exports.Analysis = Analysis;
Analysis.id = 'Analysis';
Analysis.implements = new Set(['Analysis', 'ion_Object', 'Node']);

function isAnalysis(value) {
  return Class.isInstance(Analysis, value);
}

exports.isAnalysis = isAnalysis;
exports.default = Analysis;
},{"./Location":"WmoZ","./ion/Null":"ozVR","./ion/Map":"AiNq","./ion/Class":"iy0N"}],"aNCm":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isType = exports.Type = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Class = __importStar(require("./ion/Class"));

class Type {
  constructor({
    location = null,
    type = null
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    this.location = location;
    this.type = type;
    Object.freeze(this);
  }

  patch(properties) {
    return new Type({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isType(value);
  }

}

exports.Type = Type;
Type.id = 'Type';
Type.implements = new Set(['Type', 'ion_Object', 'Expression', 'Typed', 'Node']);

function isType(value) {
  return Class.isInstance(Type, value);
}

exports.isType = isType;
exports.default = Type;
},{"./Location":"WmoZ","./ion/Null":"ozVR","./ion/Class":"iy0N"}],"DUgi":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isArrayExpression = exports.ArrayExpression = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const _Array = __importStar(require("./ion/Array"));

const Boolean = __importStar(require("./ion/Boolean"));

const Class = __importStar(require("./ion/Class"));

class ArrayExpression {
  constructor({
    location = null,
    type = null,
    elements,
    isSet = false
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!_Array.isArray(elements)) throw new Error('elements is not a Array: ' + Class.toString(elements));
    if (!Boolean.isBoolean(isSet)) throw new Error('isSet is not a Boolean: ' + Class.toString(isSet));
    this.location = location;
    this.type = type;
    this.elements = elements;
    this.isSet = isSet;
    Object.freeze(this);
  }

  patch(properties) {
    return new ArrayExpression({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isArrayExpression(value);
  }

}

exports.ArrayExpression = ArrayExpression;
ArrayExpression.id = 'ArrayExpression';
ArrayExpression.implements = new Set(['ArrayExpression', 'ion_Object', 'Expression', 'Typed', 'Node']);

function isArrayExpression(value) {
  return Class.isInstance(ArrayExpression, value);
}

exports.isArrayExpression = isArrayExpression;
exports.default = ArrayExpression;
},{"./Location":"WmoZ","./ion/Null":"ozVR","./Type":"aNCm","./ion/Array":"PpFg","./ion/Boolean":"eJLV","./ion/Class":"iy0N"}],"rXs3":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isArrayPattern = exports.ArrayPattern = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const _Array = __importStar(require("./ion/Array"));

const Class = __importStar(require("./ion/Class"));

class ArrayPattern {
  constructor({
    location = null,
    type = null,
    elements
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!_Array.isArray(elements)) throw new Error('elements is not a Array: ' + Class.toString(elements));
    this.location = location;
    this.type = type;
    this.elements = elements;
    Object.freeze(this);
  }

  patch(properties) {
    return new ArrayPattern({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isArrayPattern(value);
  }

}

exports.ArrayPattern = ArrayPattern;
ArrayPattern.id = 'ArrayPattern';
ArrayPattern.implements = new Set(['ArrayPattern', 'ion_Object', 'Pattern', 'Typed', 'Node']);

function isArrayPattern(value) {
  return Class.isInstance(ArrayPattern, value);
}

exports.isArrayPattern = isArrayPattern;
exports.default = ArrayPattern;
},{"./Location":"WmoZ","./ion/Null":"ozVR","./Type":"aNCm","./ion/Array":"PpFg","./ion/Class":"iy0N"}],"htdT":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isExpression = exports.Expression = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const Class = __importStar(require("./ion/Class"));

class Expression {
  constructor({
    location = null,
    type = null
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    this.location = location;
    this.type = type;
    Object.freeze(this);
  }

  patch(properties) {
    return new Expression({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isExpression(value);
  }

}

exports.Expression = Expression;
Expression.id = 'Expression';
Expression.implements = new Set(['Expression', 'ion_Object', 'Typed', 'Node']);

function isExpression(value) {
  return Class.isInstance(Expression, value);
}

exports.isExpression = isExpression;
exports.default = Expression;
},{"./Location":"WmoZ","./ion/Null":"ozVR","./Type":"aNCm","./ion/Class":"iy0N"}],"KP28":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isBlockStatement = exports.BlockStatement = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const _Array = __importStar(require("./ion/Array"));

const Class = __importStar(require("./ion/Class"));

class BlockStatement {
  constructor({
    location = null,
    type = null,
    body
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!_Array.isArray(body)) throw new Error('body is not a Array: ' + Class.toString(body));
    this.location = location;
    this.type = type;
    this.body = body;
    Object.freeze(this);
  }

  patch(properties) {
    return new BlockStatement({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isBlockStatement(value);
  }

}

exports.BlockStatement = BlockStatement;
BlockStatement.id = 'BlockStatement';
BlockStatement.implements = new Set(['BlockStatement', 'ion_Object', 'Statement', 'Scope', 'Typed', 'Node']);

function isBlockStatement(value) {
  return Class.isInstance(BlockStatement, value);
}

exports.isBlockStatement = isBlockStatement;
exports.default = BlockStatement;
},{"./Location":"WmoZ","./ion/Null":"ozVR","./Type":"aNCm","./ion/Array":"PpFg","./ion/Class":"iy0N"}],"BBgA":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isArrowFunctionExpression = exports.ArrowFunctionExpression = void 0;

const Expression = __importStar(require("./Expression"));

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const _Array = __importStar(require("./ion/Array"));

const BlockStatement = __importStar(require("./BlockStatement"));

const Boolean = __importStar(require("./ion/Boolean"));

const Class = __importStar(require("./ion/Class"));

class ArrowFunctionExpression {
  constructor({
    location = null,
    type = null,
    params,
    body,
    expression
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!_Array.isArray(params)) throw new Error('params is not a Array: ' + Class.toString(params));
    if (!(BlockStatement.isBlockStatement(body) || Expression.isExpression(body))) throw new Error('body is not a BlockStatement | Expression: ' + Class.toString(body));
    if (!Boolean.isBoolean(expression)) throw new Error('expression is not a Boolean: ' + Class.toString(expression));
    this.location = location;
    this.type = type;
    this.params = params;
    this.body = body;
    this.expression = expression;
    Object.freeze(this);
  }

  patch(properties) {
    return new ArrowFunctionExpression({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isArrowFunctionExpression(value);
  }

}

exports.ArrowFunctionExpression = ArrowFunctionExpression;
ArrowFunctionExpression.id = 'ArrowFunctionExpression';
ArrowFunctionExpression.implements = new Set(['ArrowFunctionExpression', 'ion_Object', 'Expression', 'Scope', 'Typed', 'Node']);

function isArrowFunctionExpression(value) {
  return Class.isInstance(ArrowFunctionExpression, value);
}

exports.isArrowFunctionExpression = isArrowFunctionExpression;
exports.default = ArrowFunctionExpression;
},{"./Expression":"htdT","./Location":"WmoZ","./ion/Null":"ozVR","./Type":"aNCm","./ion/Array":"PpFg","./BlockStatement":"KP28","./ion/Boolean":"eJLV","./ion/Class":"iy0N"}],"Aly1":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isAssembly = exports.Assembly = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Map = __importStar(require("./ion/Map"));

const Class = __importStar(require("./ion/Class"));

class Assembly {
  constructor({
    location = null,
    modules
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!Map.isMap(modules)) throw new Error('modules is not a Map: ' + Class.toString(modules));
    this.location = location;
    this.modules = modules;
    Object.freeze(this);
  }

  patch(properties) {
    return new Assembly({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isAssembly(value);
  }

}

exports.Assembly = Assembly;
Assembly.id = 'Assembly';
Assembly.implements = new Set(['Assembly', 'ion_Object', 'Node']);

function isAssembly(value) {
  return Class.isInstance(Assembly, value);
}

exports.isAssembly = isAssembly;
exports.default = Assembly;
},{"./Location":"WmoZ","./ion/Null":"ozVR","./ion/Map":"AiNq","./ion/Class":"iy0N"}],"lXGK":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isPattern = exports.Pattern = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const Class = __importStar(require("./ion/Class"));

class Pattern {
  constructor({
    location = null,
    type = null
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    this.location = location;
    this.type = type;
    Object.freeze(this);
  }

  patch(properties) {
    return new Pattern({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isPattern(value);
  }

}

exports.Pattern = Pattern;
Pattern.id = 'Pattern';
Pattern.implements = new Set(['Pattern', 'ion_Object', 'Typed', 'Node']);

function isPattern(value) {
  return Class.isInstance(Pattern, value);
}

exports.isPattern = isPattern;
exports.default = Pattern;
},{"./Location":"WmoZ","./ion/Null":"ozVR","./Type":"aNCm","./ion/Class":"iy0N"}],"ctBp":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isAssignmentPattern = exports.AssignmentPattern = void 0;

const Pattern = __importStar(require("./Pattern"));

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const Expression = __importStar(require("./Expression"));

const Class = __importStar(require("./ion/Class"));

class AssignmentPattern {
  constructor({
    location = null,
    type = null,
    left,
    right
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!Pattern.isPattern(left)) throw new Error('left is not a Pattern: ' + Class.toString(left));
    if (!Expression.isExpression(right)) throw new Error('right is not a Expression: ' + Class.toString(right));
    this.location = location;
    this.type = type;
    this.left = left;
    this.right = right;
    Object.freeze(this);
  }

  patch(properties) {
    return new AssignmentPattern({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isAssignmentPattern(value);
  }

}

exports.AssignmentPattern = AssignmentPattern;
AssignmentPattern.id = 'AssignmentPattern';
AssignmentPattern.implements = new Set(['AssignmentPattern', 'ion_Object', 'Pattern', 'Typed', 'Node']);

function isAssignmentPattern(value) {
  return Class.isInstance(AssignmentPattern, value);
}

exports.isAssignmentPattern = isAssignmentPattern;
exports.default = AssignmentPattern;
},{"./Pattern":"lXGK","./Location":"WmoZ","./ion/Null":"ozVR","./Type":"aNCm","./Expression":"htdT","./ion/Class":"iy0N"}],"GPPI":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isAssignmentStatement = exports.AssignmentStatement = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const String = __importStar(require("./ion/String"));

const Pattern = __importStar(require("./Pattern"));

const Expression = __importStar(require("./Expression"));

const Class = __importStar(require("./ion/Class"));

class AssignmentStatement {
  constructor({
    location = null,
    type = null,
    operator = '=',
    left,
    right
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!String.isString(operator)) throw new Error('operator is not a String: ' + Class.toString(operator));
    if (!(Pattern.isPattern(left) || Expression.isExpression(left))) throw new Error('left is not a Pattern | Expression: ' + Class.toString(left));
    if (!Expression.isExpression(right)) throw new Error('right is not a Expression: ' + Class.toString(right));
    this.location = location;
    this.type = type;
    this.operator = operator;
    this.left = left;
    this.right = right;
    Object.freeze(this);
  }

  patch(properties) {
    return new AssignmentStatement({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isAssignmentStatement(value);
  }

}

exports.AssignmentStatement = AssignmentStatement;
AssignmentStatement.id = 'AssignmentStatement';
AssignmentStatement.implements = new Set(['AssignmentStatement', 'ion_Object', 'Statement', 'Typed', 'Node']);

function isAssignmentStatement(value) {
  return Class.isInstance(AssignmentStatement, value);
}

exports.isAssignmentStatement = isAssignmentStatement;
exports.default = AssignmentStatement;
},{"./Location":"WmoZ","./ion/Null":"ozVR","./Type":"aNCm","./ion/String":"CAX3","./Pattern":"lXGK","./Expression":"htdT","./ion/Class":"iy0N"}],"n6ms":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isAwaitExpression = exports.AwaitExpression = void 0;

const Expression = __importStar(require("./Expression"));

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const Class = __importStar(require("./ion/Class"));

class AwaitExpression {
  constructor({
    location = null,
    type = null,
    argument
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!Expression.isExpression(argument)) throw new Error('argument is not a Expression: ' + Class.toString(argument));
    this.location = location;
    this.type = type;
    this.argument = argument;
    Object.freeze(this);
  }

  patch(properties) {
    return new AwaitExpression({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isAwaitExpression(value);
  }

}

exports.AwaitExpression = AwaitExpression;
AwaitExpression.id = 'AwaitExpression';
AwaitExpression.implements = new Set(['AwaitExpression', 'ion_Object', 'Expression', 'Typed', 'Node']);

function isAwaitExpression(value) {
  return Class.isInstance(AwaitExpression, value);
}

exports.isAwaitExpression = isAwaitExpression;
exports.default = AwaitExpression;
},{"./Expression":"htdT","./Location":"WmoZ","./ion/Null":"ozVR","./Type":"aNCm","./ion/Class":"iy0N"}],"v4in":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isBinaryExpression = exports.BinaryExpression = void 0;

const Expression = __importStar(require("./Expression"));

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const String = __importStar(require("./ion/String"));

const Class = __importStar(require("./ion/Class"));

class BinaryExpression {
  constructor({
    location = null,
    type = null,
    left,
    operator,
    right
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!Expression.isExpression(left)) throw new Error('left is not a Expression: ' + Class.toString(left));
    if (!String.isString(operator)) throw new Error('operator is not a String: ' + Class.toString(operator));
    if (!Expression.isExpression(right)) throw new Error('right is not a Expression: ' + Class.toString(right));
    this.location = location;
    this.type = type;
    this.left = left;
    this.operator = operator;
    this.right = right;
    Object.freeze(this);
  }

  patch(properties) {
    return new BinaryExpression({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isBinaryExpression(value);
  }

}

exports.BinaryExpression = BinaryExpression;
BinaryExpression.id = 'BinaryExpression';
BinaryExpression.implements = new Set(['BinaryExpression', 'ion_Object', 'Expression', 'Typed', 'Node']);

function isBinaryExpression(value) {
  return Class.isInstance(BinaryExpression, value);
}

exports.isBinaryExpression = isBinaryExpression;
exports.default = BinaryExpression;
},{"./Expression":"htdT","./Location":"WmoZ","./ion/Null":"ozVR","./Type":"aNCm","./ion/String":"CAX3","./ion/Class":"iy0N"}],"UlDp":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isBreakStatement = exports.BreakStatement = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const Class = __importStar(require("./ion/Class"));

class BreakStatement {
  constructor({
    location = null,
    type = null
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    this.location = location;
    this.type = type;
    Object.freeze(this);
  }

  patch(properties) {
    return new BreakStatement({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isBreakStatement(value);
  }

}

exports.BreakStatement = BreakStatement;
BreakStatement.id = 'BreakStatement';
BreakStatement.implements = new Set(['BreakStatement', 'ion_Object', 'Statement', 'Typed', 'Node']);

function isBreakStatement(value) {
  return Class.isInstance(BreakStatement, value);
}

exports.isBreakStatement = isBreakStatement;
exports.default = BreakStatement;
},{"./Location":"WmoZ","./ion/Null":"ozVR","./Type":"aNCm","./ion/Class":"iy0N"}],"xjN4":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isCallExpression = exports.CallExpression = void 0;

const Expression = __importStar(require("./Expression"));

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const Boolean = __importStar(require("./ion/Boolean"));

const _Array = __importStar(require("./ion/Array"));

const Class = __importStar(require("./ion/Class"));

class CallExpression {
  constructor({
    location = null,
    type = null,
    optional = false,
    new: _new = false,
    callee,
    arguments: _arguments
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!Boolean.isBoolean(optional)) throw new Error('optional is not a Boolean: ' + Class.toString(optional));
    if (!Boolean.isBoolean(_new)) throw new Error('new is not a Boolean: ' + Class.toString(_new));
    if (!Expression.isExpression(callee)) throw new Error('callee is not a Expression: ' + Class.toString(callee));
    if (!_Array.isArray(_arguments)) throw new Error('arguments is not a Array: ' + Class.toString(_arguments));
    this.location = location;
    this.type = type;
    this.optional = optional;
    this.new = _new;
    this.callee = callee;
    this.arguments = _arguments;
    Object.freeze(this);
  }

  patch(properties) {
    return new CallExpression({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isCallExpression(value);
  }

}

exports.CallExpression = CallExpression;
CallExpression.id = 'CallExpression';
CallExpression.implements = new Set(['CallExpression', 'ion_Object', 'Expression', 'ChainElement', 'Typed', 'Node']);

function isCallExpression(value) {
  return Class.isInstance(CallExpression, value);
}

exports.isCallExpression = isCallExpression;
exports.default = CallExpression;
},{"./Expression":"htdT","./Location":"WmoZ","./ion/Null":"ozVR","./Type":"aNCm","./ion/Boolean":"eJLV","./ion/Array":"PpFg","./ion/Class":"iy0N"}],"cLXq":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isCatchClause = exports.CatchClause = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Pattern = __importStar(require("./Pattern"));

const BlockStatement = __importStar(require("./BlockStatement"));

const Class = __importStar(require("./ion/Class"));

class CatchClause {
  constructor({
    location = null,
    param,
    body
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!Pattern.isPattern(param)) throw new Error('param is not a Pattern: ' + Class.toString(param));
    if (!BlockStatement.isBlockStatement(body)) throw new Error('body is not a BlockStatement: ' + Class.toString(body));
    this.location = location;
    this.param = param;
    this.body = body;
    Object.freeze(this);
  }

  patch(properties) {
    return new CatchClause({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isCatchClause(value);
  }

}

exports.CatchClause = CatchClause;
CatchClause.id = 'CatchClause';
CatchClause.implements = new Set(['CatchClause', 'ion_Object', 'Node']);

function isCatchClause(value) {
  return Class.isInstance(CatchClause, value);
}

exports.isCatchClause = isCatchClause;
exports.default = CatchClause;
},{"./Location":"WmoZ","./ion/Null":"ozVR","./Pattern":"lXGK","./BlockStatement":"KP28","./ion/Class":"iy0N"}],"rzYm":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isChainElement = exports.ChainElement = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Boolean = __importStar(require("./ion/Boolean"));

const Class = __importStar(require("./ion/Class"));

class ChainElement {
  constructor({
    location = null,
    optional = false
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!Boolean.isBoolean(optional)) throw new Error('optional is not a Boolean: ' + Class.toString(optional));
    this.location = location;
    this.optional = optional;
    Object.freeze(this);
  }

  patch(properties) {
    return new ChainElement({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isChainElement(value);
  }

}

exports.ChainElement = ChainElement;
ChainElement.id = 'ChainElement';
ChainElement.implements = new Set(['ChainElement', 'ion_Object', 'Node']);

function isChainElement(value) {
  return Class.isInstance(ChainElement, value);
}

exports.isChainElement = isChainElement;
exports.default = ChainElement;
},{"./Location":"WmoZ","./ion/Null":"ozVR","./ion/Boolean":"eJLV","./ion/Class":"iy0N"}],"GwVA":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isInteger = void 0;
/*
This file was generated from ion source. Do not edit.
*/

const Number = __importStar(require("./Number"));

function isInteger(value) {
  return Number.isNumber(value) && value % 1 === 0;
}

exports.isInteger = isInteger;
},{"./Number":"Zizk"}],"GkPh":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isDeclarator = exports.Declarator = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const String = __importStar(require("./ion/String"));

const Type = __importStar(require("./Type"));

const Class = __importStar(require("./ion/Class"));

class Declarator {
  constructor({
    location = null,
    name,
    path = null,
    type = null
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!String.isString(name)) throw new Error('name is not a String: ' + Class.toString(name));
    if (!(String.isString(path) || Null.isNull(path))) throw new Error('path is not a String | Null: ' + Class.toString(path));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    this.location = location;
    this.name = name;
    this.path = path;
    this.type = type;
    Object.freeze(this);
  }

  patch(properties) {
    return new Declarator({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isDeclarator(value);
  }

}

exports.Declarator = Declarator;
Declarator.id = 'Declarator';
Declarator.implements = new Set(['Declarator', 'ion_Object', 'Identifier', 'Pattern', 'Node', 'Typed']);

function isDeclarator(value) {
  return Class.isInstance(Declarator, value);
}

exports.isDeclarator = isDeclarator;
exports.default = Declarator;
},{"./Location":"WmoZ","./ion/Null":"ozVR","./ion/String":"CAX3","./Type":"aNCm","./ion/Class":"iy0N"}],"X8Jq":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isInstanceDeclarations = exports.InstanceDeclarations = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const _Array = __importStar(require("./ion/Array"));

const Class = __importStar(require("./ion/Class"));

class InstanceDeclarations {
  constructor({
    location = null,
    declarations
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!_Array.isArray(declarations)) throw new Error('declarations is not a Array: ' + Class.toString(declarations));
    this.location = location;
    this.declarations = declarations;
    Object.freeze(this);
  }

  patch(properties) {
    return new InstanceDeclarations({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isInstanceDeclarations(value);
  }

}

exports.InstanceDeclarations = InstanceDeclarations;
InstanceDeclarations.id = 'InstanceDeclarations';
InstanceDeclarations.implements = new Set(['InstanceDeclarations', 'ion_Object', 'Scope', 'Node']);

function isInstanceDeclarations(value) {
  return Class.isInstance(InstanceDeclarations, value);
}

exports.isInstanceDeclarations = isInstanceDeclarations;
exports.default = InstanceDeclarations;
},{"./Location":"WmoZ","./ion/Null":"ozVR","./ion/Array":"PpFg","./ion/Class":"iy0N"}],"cVoV":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isClassDeclaration = exports.ClassDeclaration = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const Integer = __importStar(require("./ion/Integer"));

const Boolean = __importStar(require("./ion/Boolean"));

const Declarator = __importStar(require("./Declarator"));

const _Array = __importStar(require("./ion/Array"));

const InstanceDeclarations = __importStar(require("./InstanceDeclarations"));

const Class = __importStar(require("./ion/Class"));

class ClassDeclaration {
  constructor({
    location = null,
    type = null,
    export: _export = 0,
    isStruct = false,
    isData = false,
    id,
    parameters = [],
    baseClasses = [],
    static: _static,
    instance,
    instanceType = null
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!Integer.isInteger(_export)) throw new Error('export is not a Integer: ' + Class.toString(_export));
    if (!Boolean.isBoolean(isStruct)) throw new Error('isStruct is not a Boolean: ' + Class.toString(isStruct));
    if (!Boolean.isBoolean(isData)) throw new Error('isData is not a Boolean: ' + Class.toString(isData));
    if (!Declarator.isDeclarator(id)) throw new Error('id is not a Declarator: ' + Class.toString(id));
    if (!_Array.isArray(parameters)) throw new Error('parameters is not a Array: ' + Class.toString(parameters));
    if (!_Array.isArray(baseClasses)) throw new Error('baseClasses is not a Array: ' + Class.toString(baseClasses));
    if (!_Array.isArray(_static)) throw new Error('static is not a Array: ' + Class.toString(_static));
    if (!InstanceDeclarations.isInstanceDeclarations(instance)) throw new Error('instance is not a InstanceDeclarations: ' + Class.toString(instance));
    if (!(Type.isType(instanceType) || Null.isNull(instanceType))) throw new Error('instanceType is not a Type | Null: ' + Class.toString(instanceType));
    this.location = location;
    this.type = type;
    this.export = _export;
    this.isStruct = isStruct;
    this.isData = isData;
    this.id = id;
    this.parameters = parameters;
    this.baseClasses = baseClasses;
    this.static = _static;
    this.instance = instance;
    this.instanceType = instanceType;
    Object.freeze(this);
  }

  patch(properties) {
    return new ClassDeclaration({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isClassDeclaration(value);
  }

}

exports.ClassDeclaration = ClassDeclaration;
ClassDeclaration.id = 'ClassDeclaration';
ClassDeclaration.implements = new Set(['ClassDeclaration', 'ion_Object', 'Declaration', 'Expression', 'Statement', 'Exportable', 'Typed', 'Node']);

function isClassDeclaration(value) {
  return Class.isInstance(ClassDeclaration, value);
}

exports.isClassDeclaration = isClassDeclaration;
exports.default = ClassDeclaration;
},{"./Location":"WmoZ","./ion/Null":"ozVR","./Type":"aNCm","./ion/Integer":"GwVA","./ion/Boolean":"eJLV","./Declarator":"GkPh","./ion/Array":"PpFg","./InstanceDeclarations":"X8Jq","./ion/Class":"iy0N"}],"yF41":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isIdentifier = exports.Identifier = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const String = __importStar(require("./ion/String"));

const Class = __importStar(require("./ion/Class"));

class Identifier {
  constructor({
    location = null,
    name,
    path = null
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!String.isString(name)) throw new Error('name is not a String: ' + Class.toString(name));
    if (!(String.isString(path) || Null.isNull(path))) throw new Error('path is not a String | Null: ' + Class.toString(path));
    this.location = location;
    this.name = name;
    this.path = path;
    Object.freeze(this);
  }

  patch(properties) {
    return new Identifier({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isIdentifier(value);
  }

}

exports.Identifier = Identifier;
Identifier.id = 'Identifier';
Identifier.implements = new Set(['Identifier', 'ion_Object', 'Node']);

function isIdentifier(value) {
  return Class.isInstance(Identifier, value);
}

exports.isIdentifier = isIdentifier;
exports.default = Identifier;
},{"./Location":"WmoZ","./ion/Null":"ozVR","./ion/String":"CAX3","./ion/Class":"iy0N"}],"l4vW":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isConditionalDeclaration = exports.ConditionalDeclaration = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const Pattern = __importStar(require("./Pattern"));

const Expression = __importStar(require("./Expression"));

const Integer = __importStar(require("./ion/Integer"));

const String = __importStar(require("./ion/String"));

const Identifier = __importStar(require("./Identifier"));

const Boolean = __importStar(require("./ion/Boolean"));

const Class = __importStar(require("./ion/Class"));

class ConditionalDeclaration {
  constructor({
    location = null,
    type = null,
    id,
    value = null,
    export: _export = 0,
    kind,
    static: _static = null,
    instance = false,
    negate = false
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!(Pattern.isPattern(id) || Expression.isExpression(id))) throw new Error('id is not a Pattern | Expression: ' + Class.toString(id));
    if (!(Expression.isExpression(value) || Null.isNull(value))) throw new Error('value is not a Expression | Null: ' + Class.toString(value));
    if (!Integer.isInteger(_export)) throw new Error('export is not a Integer: ' + Class.toString(_export));
    if (!String.isString(kind)) throw new Error('kind is not a String: ' + Class.toString(kind));
    if (!(Identifier.isIdentifier(_static) || Null.isNull(_static))) throw new Error('static is not a Identifier | Null: ' + Class.toString(_static));
    if (!Boolean.isBoolean(instance)) throw new Error('instance is not a Boolean: ' + Class.toString(instance));
    if (!Boolean.isBoolean(negate)) throw new Error('negate is not a Boolean: ' + Class.toString(negate));
    this.location = location;
    this.type = type;
    this.id = id;
    this.value = value;
    this.export = _export;
    this.kind = kind;
    this.static = _static;
    this.instance = instance;
    this.negate = negate;
    Object.freeze(this);
  }

  patch(properties) {
    return new ConditionalDeclaration({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isConditionalDeclaration(value);
  }

}

exports.ConditionalDeclaration = ConditionalDeclaration;
ConditionalDeclaration.id = 'ConditionalDeclaration';
ConditionalDeclaration.implements = new Set(['ConditionalDeclaration', 'ion_Object', 'VariableDeclaration', 'Variable', 'Declaration', 'Typed', 'Node', 'Statement', 'Exportable']);

function isConditionalDeclaration(value) {
  return Class.isInstance(ConditionalDeclaration, value);
}

exports.isConditionalDeclaration = isConditionalDeclaration;
exports.default = ConditionalDeclaration;
},{"./Location":"WmoZ","./ion/Null":"ozVR","./Type":"aNCm","./Pattern":"lXGK","./Expression":"htdT","./ion/Integer":"GwVA","./ion/String":"CAX3","./Identifier":"yF41","./ion/Boolean":"eJLV","./ion/Class":"iy0N"}],"ROnC":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isConditionalExpression = exports.ConditionalExpression = void 0;

const Expression = __importStar(require("./Expression"));

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const Class = __importStar(require("./ion/Class"));

class ConditionalExpression {
  constructor({
    location = null,
    type = null,
    test,
    consequent,
    alternate
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!Expression.isExpression(test)) throw new Error('test is not a Expression: ' + Class.toString(test));
    if (!Expression.isExpression(consequent)) throw new Error('consequent is not a Expression: ' + Class.toString(consequent));
    if (!Expression.isExpression(alternate)) throw new Error('alternate is not a Expression: ' + Class.toString(alternate));
    this.location = location;
    this.type = type;
    this.test = test;
    this.consequent = consequent;
    this.alternate = alternate;
    Object.freeze(this);
  }

  patch(properties) {
    return new ConditionalExpression({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isConditionalExpression(value);
  }

}

exports.ConditionalExpression = ConditionalExpression;
ConditionalExpression.id = 'ConditionalExpression';
ConditionalExpression.implements = new Set(['ConditionalExpression', 'ion_Object', 'Expression', 'Typed', 'Node']);

function isConditionalExpression(value) {
  return Class.isInstance(ConditionalExpression, value);
}

exports.isConditionalExpression = isConditionalExpression;
exports.default = ConditionalExpression;
},{"./Expression":"htdT","./Location":"WmoZ","./ion/Null":"ozVR","./Type":"aNCm","./ion/Class":"iy0N"}],"ASeV":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isContinueStatement = exports.ContinueStatement = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const Class = __importStar(require("./ion/Class"));

class ContinueStatement {
  constructor({
    location = null,
    type = null
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    this.location = location;
    this.type = type;
    Object.freeze(this);
  }

  patch(properties) {
    return new ContinueStatement({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isContinueStatement(value);
  }

}

exports.ContinueStatement = ContinueStatement;
ContinueStatement.id = 'ContinueStatement';
ContinueStatement.implements = new Set(['ContinueStatement', 'ion_Object', 'Statement', 'Typed', 'Node']);

function isContinueStatement(value) {
  return Class.isInstance(ContinueStatement, value);
}

exports.isContinueStatement = isContinueStatement;
exports.default = ContinueStatement;
},{"./Location":"WmoZ","./ion/Null":"ozVR","./Type":"aNCm","./ion/Class":"iy0N"}],"ncJC":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isDeclaration = exports.Declaration = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const Integer = __importStar(require("./ion/Integer"));

const Class = __importStar(require("./ion/Class"));

class Declaration {
  constructor({
    location = null,
    type = null,
    export: _export = 0
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!Integer.isInteger(_export)) throw new Error('export is not a Integer: ' + Class.toString(_export));
    this.location = location;
    this.type = type;
    this.export = _export;
    Object.freeze(this);
  }

  patch(properties) {
    return new Declaration({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isDeclaration(value);
  }

}

exports.Declaration = Declaration;
Declaration.id = 'Declaration';
Declaration.implements = new Set(['Declaration', 'ion_Object', 'Statement', 'Exportable', 'Typed', 'Node']);

function isDeclaration(value) {
  return Class.isInstance(Declaration, value);
}

exports.isDeclaration = isDeclaration;
exports.default = Declaration;
},{"./Location":"WmoZ","./ion/Null":"ozVR","./Type":"aNCm","./ion/Integer":"GwVA","./ion/Class":"iy0N"}],"EsPb":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isDotExpression = exports.DotExpression = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const Class = __importStar(require("./ion/Class"));

class DotExpression {
  constructor({
    location = null,
    type = null
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    this.location = location;
    this.type = type;
    Object.freeze(this);
  }

  patch(properties) {
    return new DotExpression({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isDotExpression(value);
  }

}

exports.DotExpression = DotExpression;
DotExpression.id = 'DotExpression';
DotExpression.implements = new Set(['DotExpression', 'ion_Object', 'Expression', 'Typed', 'Node']);

function isDotExpression(value) {
  return Class.isInstance(DotExpression, value);
}

exports.isDotExpression = isDotExpression;
exports.default = DotExpression;
},{"./Location":"WmoZ","./ion/Null":"ozVR","./Type":"aNCm","./ion/Class":"iy0N"}],"eNg6":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isElementExpression = exports.ElementExpression = void 0;

const Expression = __importStar(require("./Expression"));

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const _Array = __importStar(require("./ion/Array"));

const Class = __importStar(require("./ion/Class"));

class ElementExpression {
  constructor({
    location = null,
    type = null,
    kind,
    close = null,
    properties,
    children
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!Expression.isExpression(kind)) throw new Error('kind is not a Expression: ' + Class.toString(kind));
    if (!(Expression.isExpression(close) || Null.isNull(close))) throw new Error('close is not a Expression | Null: ' + Class.toString(close));
    if (!_Array.isArray(properties)) throw new Error('properties is not a Array: ' + Class.toString(properties));
    if (!_Array.isArray(children)) throw new Error('children is not a Array: ' + Class.toString(children));
    this.location = location;
    this.type = type;
    this.kind = kind;
    this.close = close;
    this.properties = properties;
    this.children = children;
    Object.freeze(this);
  }

  patch(properties) {
    return new ElementExpression({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isElementExpression(value);
  }

}

exports.ElementExpression = ElementExpression;
ElementExpression.id = 'ElementExpression';
ElementExpression.implements = new Set(['ElementExpression', 'ion_Object', 'Expression', 'Typed', 'Node']);

function isElementExpression(value) {
  return Class.isInstance(ElementExpression, value);
}

exports.isElementExpression = isElementExpression;
exports.default = ElementExpression;
},{"./Expression":"htdT","./Location":"WmoZ","./ion/Null":"ozVR","./Type":"aNCm","./ion/Array":"PpFg","./ion/Class":"iy0N"}],"S47C":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isExportable = exports.Exportable = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Integer = __importStar(require("./ion/Integer"));

const Class = __importStar(require("./ion/Class"));

class Exportable {
  constructor({
    location = null,
    export: _export = 0
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!Integer.isInteger(_export)) throw new Error('export is not a Integer: ' + Class.toString(_export));
    this.location = location;
    this.export = _export;
    Object.freeze(this);
  }

  patch(properties) {
    return new Exportable({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isExportable(value);
  }

}

exports.Exportable = Exportable;
Exportable.id = 'Exportable';
Exportable.implements = new Set(['Exportable', 'ion_Object', 'Node']);

function isExportable(value) {
  return Class.isInstance(Exportable, value);
}

exports.isExportable = isExportable;
exports.default = Exportable;
},{"./Location":"WmoZ","./ion/Null":"ozVR","./ion/Integer":"GwVA","./ion/Class":"iy0N"}],"q56r":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isSpreadElement = exports.SpreadElement = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Expression = __importStar(require("./Expression"));

const Class = __importStar(require("./ion/Class"));

class SpreadElement {
  constructor({
    location = null,
    argument
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!Expression.isExpression(argument)) throw new Error('argument is not a Expression: ' + Class.toString(argument));
    this.location = location;
    this.argument = argument;
    Object.freeze(this);
  }

  patch(properties) {
    return new SpreadElement({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isSpreadElement(value);
  }

}

exports.SpreadElement = SpreadElement;
SpreadElement.id = 'SpreadElement';
SpreadElement.implements = new Set(['SpreadElement', 'ion_Object', 'Node']);

function isSpreadElement(value) {
  return Class.isInstance(SpreadElement, value);
}

exports.isSpreadElement = isSpreadElement;
exports.default = SpreadElement;
},{"./Location":"WmoZ","./ion/Null":"ozVR","./Expression":"htdT","./ion/Class":"iy0N"}],"pROO":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isExpressionStatement = exports.ExpressionStatement = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const Expression = __importStar(require("./Expression"));

const SpreadElement = __importStar(require("./SpreadElement"));

const Class = __importStar(require("./ion/Class"));

class ExpressionStatement {
  constructor({
    location = null,
    type = null,
    expression
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!(Expression.isExpression(expression) || SpreadElement.isSpreadElement(expression))) throw new Error('expression is not a Expression | SpreadElement: ' + Class.toString(expression));
    this.location = location;
    this.type = type;
    this.expression = expression;
    Object.freeze(this);
  }

  patch(properties) {
    return new ExpressionStatement({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isExpressionStatement(value);
  }

}

exports.ExpressionStatement = ExpressionStatement;
ExpressionStatement.id = 'ExpressionStatement';
ExpressionStatement.implements = new Set(['ExpressionStatement', 'ion_Object', 'Statement', 'Typed', 'Node']);

function isExpressionStatement(value) {
  return Class.isInstance(ExpressionStatement, value);
}

exports.isExpressionStatement = isExpressionStatement;
exports.default = ExpressionStatement;
},{"./Location":"WmoZ","./ion/Null":"ozVR","./Type":"aNCm","./Expression":"htdT","./SpreadElement":"q56r","./ion/Class":"iy0N"}],"n5i9":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isVariableDeclaration = exports.VariableDeclaration = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const Pattern = __importStar(require("./Pattern"));

const Expression = __importStar(require("./Expression"));

const Integer = __importStar(require("./ion/Integer"));

const String = __importStar(require("./ion/String"));

const Identifier = __importStar(require("./Identifier"));

const Boolean = __importStar(require("./ion/Boolean"));

const Class = __importStar(require("./ion/Class"));

class VariableDeclaration {
  constructor({
    location = null,
    type = null,
    id,
    value = null,
    export: _export = 0,
    kind,
    static: _static = null,
    instance = false
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!(Pattern.isPattern(id) || Expression.isExpression(id))) throw new Error('id is not a Pattern | Expression: ' + Class.toString(id));
    if (!(Expression.isExpression(value) || Null.isNull(value))) throw new Error('value is not a Expression | Null: ' + Class.toString(value));
    if (!Integer.isInteger(_export)) throw new Error('export is not a Integer: ' + Class.toString(_export));
    if (!String.isString(kind)) throw new Error('kind is not a String: ' + Class.toString(kind));
    if (!(Identifier.isIdentifier(_static) || Null.isNull(_static))) throw new Error('static is not a Identifier | Null: ' + Class.toString(_static));
    if (!Boolean.isBoolean(instance)) throw new Error('instance is not a Boolean: ' + Class.toString(instance));
    this.location = location;
    this.type = type;
    this.id = id;
    this.value = value;
    this.export = _export;
    this.kind = kind;
    this.static = _static;
    this.instance = instance;
    Object.freeze(this);
  }

  patch(properties) {
    return new VariableDeclaration({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isVariableDeclaration(value);
  }

}

exports.VariableDeclaration = VariableDeclaration;
VariableDeclaration.id = 'VariableDeclaration';
VariableDeclaration.implements = new Set(['VariableDeclaration', 'ion_Object', 'Variable', 'Declaration', 'Typed', 'Node', 'Statement', 'Exportable']);

function isVariableDeclaration(value) {
  return Class.isInstance(VariableDeclaration, value);
}

exports.isVariableDeclaration = isVariableDeclaration;
exports.default = VariableDeclaration;
},{"./Location":"WmoZ","./ion/Null":"ozVR","./Type":"aNCm","./Pattern":"lXGK","./Expression":"htdT","./ion/Integer":"GwVA","./ion/String":"CAX3","./Identifier":"yF41","./ion/Boolean":"eJLV","./ion/Class":"iy0N"}],"iuoi":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isForOfStatement = exports.ForOfStatement = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const VariableDeclaration = __importStar(require("./VariableDeclaration"));

const Expression = __importStar(require("./Expression"));

const BlockStatement = __importStar(require("./BlockStatement"));

const Class = __importStar(require("./ion/Class"));

class ForOfStatement {
  constructor({
    location = null,
    type = null,
    left,
    right,
    body
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!VariableDeclaration.isVariableDeclaration(left)) throw new Error('left is not a VariableDeclaration: ' + Class.toString(left));
    if (!Expression.isExpression(right)) throw new Error('right is not a Expression: ' + Class.toString(right));
    if (!BlockStatement.isBlockStatement(body)) throw new Error('body is not a BlockStatement: ' + Class.toString(body));
    this.location = location;
    this.type = type;
    this.left = left;
    this.right = right;
    this.body = body;
    Object.freeze(this);
  }

  patch(properties) {
    return new ForOfStatement({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isForOfStatement(value);
  }

}

exports.ForOfStatement = ForOfStatement;
ForOfStatement.id = 'ForOfStatement';
ForOfStatement.implements = new Set(['ForOfStatement', 'ion_Object', 'Statement', 'Typed', 'Node']);

function isForOfStatement(value) {
  return Class.isInstance(ForOfStatement, value);
}

exports.isForOfStatement = isForOfStatement;
exports.default = ForOfStatement;
},{"./Location":"WmoZ","./ion/Null":"ozVR","./Type":"aNCm","./VariableDeclaration":"n5i9","./Expression":"htdT","./BlockStatement":"KP28","./ion/Class":"iy0N"}],"gPRV":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isForStatement = exports.ForStatement = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const VariableDeclaration = __importStar(require("./VariableDeclaration"));

const Expression = __importStar(require("./Expression"));

const BlockStatement = __importStar(require("./BlockStatement"));

const Class = __importStar(require("./ion/Class"));

class ForStatement {
  constructor({
    location = null,
    type = null,
    init = null,
    test = null,
    update = null,
    body
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!(VariableDeclaration.isVariableDeclaration(init) || Null.isNull(init))) throw new Error('init is not a VariableDeclaration | Null: ' + Class.toString(init));
    if (!(Expression.isExpression(test) || Null.isNull(test))) throw new Error('test is not a Expression | Null: ' + Class.toString(test));
    if (!(Expression.isExpression(update) || Null.isNull(update))) throw new Error('update is not a Expression | Null: ' + Class.toString(update));
    if (!BlockStatement.isBlockStatement(body)) throw new Error('body is not a BlockStatement: ' + Class.toString(body));
    this.location = location;
    this.type = type;
    this.init = init;
    this.test = test;
    this.update = update;
    this.body = body;
    Object.freeze(this);
  }

  patch(properties) {
    return new ForStatement({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isForStatement(value);
  }

}

exports.ForStatement = ForStatement;
ForStatement.id = 'ForStatement';
ForStatement.implements = new Set(['ForStatement', 'ion_Object', 'Statement', 'Typed', 'Node']);

function isForStatement(value) {
  return Class.isInstance(ForStatement, value);
}

exports.isForStatement = isForStatement;
exports.default = ForStatement;
},{"./Location":"WmoZ","./ion/Null":"ozVR","./Type":"aNCm","./VariableDeclaration":"n5i9","./Expression":"htdT","./BlockStatement":"KP28","./ion/Class":"iy0N"}],"c6YV":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isFunctionExpression = exports.FunctionExpression = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const Identifier = __importStar(require("./Identifier"));

const _Array = __importStar(require("./ion/Array"));

const BlockStatement = __importStar(require("./BlockStatement"));

const Boolean = __importStar(require("./ion/Boolean"));

const Class = __importStar(require("./ion/Class"));

class FunctionExpression {
  constructor({
    location = null,
    type = null,
    id = null,
    params,
    body,
    async: _async = false,
    generator = false,
    returnType = null
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!(Identifier.isIdentifier(id) || Null.isNull(id))) throw new Error('id is not a Identifier | Null: ' + Class.toString(id));
    if (!_Array.isArray(params)) throw new Error('params is not a Array: ' + Class.toString(params));
    if (!BlockStatement.isBlockStatement(body)) throw new Error('body is not a BlockStatement: ' + Class.toString(body));
    if (!Boolean.isBoolean(_async)) throw new Error('async is not a Boolean: ' + Class.toString(_async));
    if (!Boolean.isBoolean(generator)) throw new Error('generator is not a Boolean: ' + Class.toString(generator));
    if (!(Type.isType(returnType) || Null.isNull(returnType))) throw new Error('returnType is not a Type | Null: ' + Class.toString(returnType));
    this.location = location;
    this.type = type;
    this.id = id;
    this.params = params;
    this.body = body;
    this.async = _async;
    this.generator = generator;
    this.returnType = returnType;
    Object.freeze(this);
  }

  patch(properties) {
    return new FunctionExpression({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isFunctionExpression(value);
  }

}

exports.FunctionExpression = FunctionExpression;
FunctionExpression.id = 'FunctionExpression';
FunctionExpression.implements = new Set(['FunctionExpression', 'ion_Object', 'Expression', 'Scope', 'Typed', 'Node']);

function isFunctionExpression(value) {
  return Class.isInstance(FunctionExpression, value);
}

exports.isFunctionExpression = isFunctionExpression;
exports.default = FunctionExpression;
},{"./Location":"WmoZ","./ion/Null":"ozVR","./Type":"aNCm","./Identifier":"yF41","./ion/Array":"PpFg","./BlockStatement":"KP28","./ion/Boolean":"eJLV","./ion/Class":"iy0N"}],"TEUp":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isFunctionType = exports.FunctionType = void 0;

const Type = __importStar(require("./Type"));

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const _Array = __importStar(require("./ion/Array"));

const Boolean = __importStar(require("./ion/Boolean"));

const Class = __importStar(require("./ion/Class"));

class FunctionType {
  constructor({
    location = null,
    type = null,
    params,
    async: _async = false,
    returnType = null
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!_Array.isArray(params)) throw new Error('params is not a Array: ' + Class.toString(params));
    if (!Boolean.isBoolean(_async)) throw new Error('async is not a Boolean: ' + Class.toString(_async));
    if (!(Type.isType(returnType) || Null.isNull(returnType))) throw new Error('returnType is not a Type | Null: ' + Class.toString(returnType));
    this.location = location;
    this.type = type;
    this.params = params;
    this.async = _async;
    this.returnType = returnType;
    Object.freeze(this);
  }

  patch(properties) {
    return new FunctionType({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isFunctionType(value);
  }

}

exports.FunctionType = FunctionType;
FunctionType.id = 'FunctionType';
FunctionType.implements = new Set(['FunctionType', 'ion_Object', 'Type', 'Expression', 'Typed', 'Node']);

function isFunctionType(value) {
  return Class.isInstance(FunctionType, value);
}

exports.isFunctionType = isFunctionType;
exports.default = FunctionType;
},{"./Type":"aNCm","./Location":"WmoZ","./ion/Null":"ozVR","./ion/Array":"PpFg","./ion/Boolean":"eJLV","./ion/Class":"iy0N"}],"VWfJ":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isIfStatement = exports.IfStatement = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const Expression = __importStar(require("./Expression"));

const BlockStatement = __importStar(require("./BlockStatement"));

const Class = __importStar(require("./ion/Class"));

class IfStatement {
  constructor({
    location = null,
    type = null,
    test,
    consequent,
    alternate = null
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!Expression.isExpression(test)) throw new Error('test is not a Expression: ' + Class.toString(test));
    if (!BlockStatement.isBlockStatement(consequent)) throw new Error('consequent is not a BlockStatement: ' + Class.toString(consequent));
    if (!(BlockStatement.isBlockStatement(alternate) || isIfStatement(alternate) || Null.isNull(alternate))) throw new Error('alternate is not a BlockStatement | IfStatement | Null: ' + Class.toString(alternate));
    this.location = location;
    this.type = type;
    this.test = test;
    this.consequent = consequent;
    this.alternate = alternate;
    Object.freeze(this);
  }

  patch(properties) {
    return new IfStatement({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isIfStatement(value);
  }

}

exports.IfStatement = IfStatement;
IfStatement.id = 'IfStatement';
IfStatement.implements = new Set(['IfStatement', 'ion_Object', 'Statement', 'Typed', 'Node']);

function isIfStatement(value) {
  return Class.isInstance(IfStatement, value);
}

exports.isIfStatement = isIfStatement;
exports.default = IfStatement;
},{"./Location":"WmoZ","./ion/Null":"ozVR","./Type":"aNCm","./Expression":"htdT","./BlockStatement":"KP28","./ion/Class":"iy0N"}],"vQgK":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isImportSpecifier = exports.ImportSpecifier = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Identifier = __importStar(require("./Identifier"));

const Class = __importStar(require("./ion/Class"));

class ImportSpecifier {
  constructor({
    location = null,
    local,
    imported
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!Identifier.isIdentifier(local)) throw new Error('local is not a Identifier: ' + Class.toString(local));
    if (!Identifier.isIdentifier(imported)) throw new Error('imported is not a Identifier: ' + Class.toString(imported));
    this.location = location;
    this.local = local;
    this.imported = imported;
    Object.freeze(this);
  }

  patch(properties) {
    return new ImportSpecifier({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isImportSpecifier(value);
  }

}

exports.ImportSpecifier = ImportSpecifier;
ImportSpecifier.id = 'ImportSpecifier';
ImportSpecifier.implements = new Set(['ImportSpecifier', 'ion_Object', 'ModuleSpecifier', 'Node']);

function isImportSpecifier(value) {
  return Class.isInstance(ImportSpecifier, value);
}

exports.isImportSpecifier = isImportSpecifier;
exports.default = ImportSpecifier;
},{"./Location":"WmoZ","./ion/Null":"ozVR","./Identifier":"yF41","./ion/Class":"iy0N"}],"rUZN":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isImportDefaultSpecifier = exports.ImportDefaultSpecifier = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Identifier = __importStar(require("./Identifier"));

const Class = __importStar(require("./ion/Class"));

class ImportDefaultSpecifier {
  constructor({
    location = null,
    local
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!Identifier.isIdentifier(local)) throw new Error('local is not a Identifier: ' + Class.toString(local));
    this.location = location;
    this.local = local;
    Object.freeze(this);
  }

  patch(properties) {
    return new ImportDefaultSpecifier({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isImportDefaultSpecifier(value);
  }

}

exports.ImportDefaultSpecifier = ImportDefaultSpecifier;
ImportDefaultSpecifier.id = 'ImportDefaultSpecifier';
ImportDefaultSpecifier.implements = new Set(['ImportDefaultSpecifier', 'ion_Object', 'ModuleSpecifier', 'Node']);

function isImportDefaultSpecifier(value) {
  return Class.isInstance(ImportDefaultSpecifier, value);
}

exports.isImportDefaultSpecifier = isImportDefaultSpecifier;
exports.default = ImportDefaultSpecifier;
},{"./Location":"WmoZ","./ion/Null":"ozVR","./Identifier":"yF41","./ion/Class":"iy0N"}],"zYhG":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isImportNamespaceSpecifier = exports.ImportNamespaceSpecifier = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Identifier = __importStar(require("./Identifier"));

const Class = __importStar(require("./ion/Class"));

class ImportNamespaceSpecifier {
  constructor({
    location = null,
    local
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!Identifier.isIdentifier(local)) throw new Error('local is not a Identifier: ' + Class.toString(local));
    this.location = location;
    this.local = local;
    Object.freeze(this);
  }

  patch(properties) {
    return new ImportNamespaceSpecifier({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isImportNamespaceSpecifier(value);
  }

}

exports.ImportNamespaceSpecifier = ImportNamespaceSpecifier;
ImportNamespaceSpecifier.id = 'ImportNamespaceSpecifier';
ImportNamespaceSpecifier.implements = new Set(['ImportNamespaceSpecifier', 'ion_Object', 'ModuleSpecifier', 'Node']);

function isImportNamespaceSpecifier(value) {
  return Class.isInstance(ImportNamespaceSpecifier, value);
}

exports.isImportNamespaceSpecifier = isImportNamespaceSpecifier;
exports.default = ImportNamespaceSpecifier;
},{"./Location":"WmoZ","./ion/Null":"ozVR","./Identifier":"yF41","./ion/Class":"iy0N"}],"OSXi":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isLiteral = exports.Literal = void 0;

const Type = __importStar(require("./Type"));

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const String = __importStar(require("./ion/String"));

const Number = __importStar(require("./ion/Number"));

const Boolean = __importStar(require("./ion/Boolean"));

const Class = __importStar(require("./ion/Class"));

class Literal {
  constructor({
    location = null,
    type = null,
    value
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!(String.isString(value) || Number.isNumber(value) || Boolean.isBoolean(value) || Null.isNull(value))) throw new Error('value is not a String | Number | Boolean | Null: ' + Class.toString(value));
    this.location = location;
    this.type = type;
    this.value = value;
    Object.freeze(this);
  }

  patch(properties) {
    return new Literal({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isLiteral(value);
  }

}

exports.Literal = Literal;
Literal.id = 'Literal';
Literal.implements = new Set(['Literal', 'ion_Object', 'Expression', 'Type', 'Typed', 'Node']);

function isLiteral(value) {
  return Class.isInstance(Literal, value);
}

exports.isLiteral = isLiteral;
exports.default = Literal;
},{"./Type":"aNCm","./Location":"WmoZ","./ion/Null":"ozVR","./ion/String":"CAX3","./ion/Number":"Zizk","./ion/Boolean":"eJLV","./ion/Class":"iy0N"}],"Gpay":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isImportDeclaration = exports.ImportDeclaration = exports.isSpecifier = void 0;
/*
This file was generated from ion source. Do not edit.
*/

const ImportSpecifier = __importStar(require("./ImportSpecifier"));

const ImportDefaultSpecifier = __importStar(require("./ImportDefaultSpecifier"));

const ImportNamespaceSpecifier = __importStar(require("./ImportNamespaceSpecifier"));

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const Integer = __importStar(require("./ion/Integer"));

const _Array = __importStar(require("./ion/Array"));

const Literal = __importStar(require("./Literal"));

const Class = __importStar(require("./ion/Class"));

function isSpecifier(value) {
  return ImportSpecifier.isImportSpecifier(value) || ImportDefaultSpecifier.isImportDefaultSpecifier(value) || ImportNamespaceSpecifier.isImportNamespaceSpecifier(value);
}

exports.isSpecifier = isSpecifier;

class ImportDeclaration {
  constructor({
    location = null,
    type = null,
    export: _export = 0,
    specifiers,
    source
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!Integer.isInteger(_export)) throw new Error('export is not a Integer: ' + Class.toString(_export));
    if (!_Array.isArray(specifiers)) throw new Error('specifiers is not a Array: ' + Class.toString(specifiers));
    if (!Literal.isLiteral(source)) throw new Error('source is not a Literal: ' + Class.toString(source));
    this.location = location;
    this.type = type;
    this.export = _export;
    this.specifiers = specifiers;
    this.source = source;
    Object.freeze(this);
  }

  patch(properties) {
    return new ImportDeclaration({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isImportDeclaration(value);
  }

}

exports.ImportDeclaration = ImportDeclaration;
ImportDeclaration.id = 'ImportDeclaration';
ImportDeclaration.implements = new Set(['ImportDeclaration', 'ion_Object', 'Declaration', 'Statement', 'Exportable', 'Typed', 'Node']);

function isImportDeclaration(value) {
  return Class.isInstance(ImportDeclaration, value);
}

exports.isImportDeclaration = isImportDeclaration;
exports.default = ImportDeclaration;
},{"./ImportSpecifier":"vQgK","./ImportDefaultSpecifier":"rUZN","./ImportNamespaceSpecifier":"zYhG","./Location":"WmoZ","./ion/Null":"ozVR","./Type":"aNCm","./ion/Integer":"GwVA","./ion/Array":"PpFg","./Literal":"OSXi","./ion/Class":"iy0N"}],"J940":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isMemberExpression = exports.MemberExpression = void 0;

const Expression = __importStar(require("./Expression"));

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const Boolean = __importStar(require("./ion/Boolean"));

const Identifier = __importStar(require("./Identifier"));

const Class = __importStar(require("./ion/Class"));

class MemberExpression {
  constructor({
    location = null,
    type = null,
    optional = false,
    object,
    property
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!Boolean.isBoolean(optional)) throw new Error('optional is not a Boolean: ' + Class.toString(optional));
    if (!Expression.isExpression(object)) throw new Error('object is not a Expression: ' + Class.toString(object));
    if (!(Identifier.isIdentifier(property) || Expression.isExpression(property))) throw new Error('property is not a Identifier | Expression: ' + Class.toString(property));
    this.location = location;
    this.type = type;
    this.optional = optional;
    this.object = object;
    this.property = property;
    Object.freeze(this);
  }

  patch(properties) {
    return new MemberExpression({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isMemberExpression(value);
  }

}

exports.MemberExpression = MemberExpression;
MemberExpression.id = 'MemberExpression';
MemberExpression.implements = new Set(['MemberExpression', 'ion_Object', 'Expression', 'ChainElement', 'Typed', 'Node']);

function isMemberExpression(value) {
  return Class.isInstance(MemberExpression, value);
}

exports.isMemberExpression = isMemberExpression;
exports.default = MemberExpression;
},{"./Expression":"htdT","./Location":"WmoZ","./ion/Null":"ozVR","./Type":"aNCm","./ion/Boolean":"eJLV","./Identifier":"yF41","./ion/Class":"iy0N"}],"uZ2y":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isMethodDefinition = exports.MethodDefinition = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Expression = __importStar(require("./Expression"));

const Identifier = __importStar(require("./Identifier"));

const FunctionExpression = __importStar(require("./FunctionExpression"));

const String = __importStar(require("./ion/String"));

const Boolean = __importStar(require("./ion/Boolean"));

const Class = __importStar(require("./ion/Class"));

class MethodDefinition {
  constructor({
    location = null,
    key,
    value,
    kind = 'method',
    computed = false,
    static: _static = false
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Expression.isExpression(key) || Identifier.isIdentifier(key))) throw new Error('key is not a Expression | Identifier: ' + Class.toString(key));
    if (!FunctionExpression.isFunctionExpression(value)) throw new Error('value is not a FunctionExpression: ' + Class.toString(value));
    if (!String.isString(kind)) throw new Error('kind is not a String: ' + Class.toString(kind));
    if (!Boolean.isBoolean(computed)) throw new Error('computed is not a Boolean: ' + Class.toString(computed));
    if (!Boolean.isBoolean(_static)) throw new Error('static is not a Boolean: ' + Class.toString(_static));
    this.location = location;
    this.key = key;
    this.value = value;
    this.kind = kind;
    this.computed = computed;
    this.static = _static;
    Object.freeze(this);
  }

  patch(properties) {
    return new MethodDefinition({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isMethodDefinition(value);
  }

}

exports.MethodDefinition = MethodDefinition;
MethodDefinition.id = 'MethodDefinition';
MethodDefinition.implements = new Set(['MethodDefinition', 'ion_Object', 'Node']);

function isMethodDefinition(value) {
  return Class.isInstance(MethodDefinition, value);
}

exports.isMethodDefinition = isMethodDefinition;
exports.default = MethodDefinition;
},{"./Location":"WmoZ","./ion/Null":"ozVR","./Expression":"htdT","./Identifier":"yF41","./FunctionExpression":"c6YV","./ion/String":"CAX3","./ion/Boolean":"eJLV","./ion/Class":"iy0N"}],"TUZi":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isModuleSpecifier = exports.ModuleSpecifier = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Identifier = __importStar(require("./Identifier"));

const Class = __importStar(require("./ion/Class"));

class ModuleSpecifier {
  constructor({
    location = null,
    local
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!Identifier.isIdentifier(local)) throw new Error('local is not a Identifier: ' + Class.toString(local));
    this.location = location;
    this.local = local;
    Object.freeze(this);
  }

  patch(properties) {
    return new ModuleSpecifier({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isModuleSpecifier(value);
  }

}

exports.ModuleSpecifier = ModuleSpecifier;
ModuleSpecifier.id = 'ModuleSpecifier';
ModuleSpecifier.implements = new Set(['ModuleSpecifier', 'ion_Object', 'Node']);

function isModuleSpecifier(value) {
  return Class.isInstance(ModuleSpecifier, value);
}

exports.isModuleSpecifier = isModuleSpecifier;
exports.default = ModuleSpecifier;
},{"./Location":"WmoZ","./ion/Null":"ozVR","./Identifier":"yF41","./ion/Class":"iy0N"}],"VLt5":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isNode = exports.Node = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Class = __importStar(require("./ion/Class"));

class Node {
  constructor({
    location = null
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    this.location = location;
    Object.freeze(this);
  }

  patch(properties) {
    return new Node({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isNode(value);
  }

}

exports.Node = Node;
Node.id = 'Node';
Node.implements = new Set(['Node', 'ion_Object']);

function isNode(value) {
  return Class.isInstance(Node, value);
}

exports.isNode = isNode;
exports.default = Node;
},{"./Location":"WmoZ","./ion/Null":"ozVR","./ion/Class":"iy0N"}],"vayH":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isObjectExpression = exports.ObjectExpression = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const _Array = __importStar(require("./ion/Array"));

const Boolean = __importStar(require("./ion/Boolean"));

const Class = __importStar(require("./ion/Class"));

class ObjectExpression {
  constructor({
    location = null,
    type = null,
    properties,
    isMap = false
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!_Array.isArray(properties)) throw new Error('properties is not a Array: ' + Class.toString(properties));
    if (!Boolean.isBoolean(isMap)) throw new Error('isMap is not a Boolean: ' + Class.toString(isMap));
    this.location = location;
    this.type = type;
    this.properties = properties;
    this.isMap = isMap;
    Object.freeze(this);
  }

  patch(properties) {
    return new ObjectExpression({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isObjectExpression(value);
  }

}

exports.ObjectExpression = ObjectExpression;
ObjectExpression.id = 'ObjectExpression';
ObjectExpression.implements = new Set(['ObjectExpression', 'ion_Object', 'Expression', 'Typed', 'Node']);

function isObjectExpression(value) {
  return Class.isInstance(ObjectExpression, value);
}

exports.isObjectExpression = isObjectExpression;
exports.default = ObjectExpression;
},{"./Location":"WmoZ","./ion/Null":"ozVR","./Type":"aNCm","./ion/Array":"PpFg","./ion/Boolean":"eJLV","./ion/Class":"iy0N"}],"KtIa":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isObjectPattern = exports.ObjectPattern = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const _Array = __importStar(require("./ion/Array"));

const Class = __importStar(require("./ion/Class"));

class ObjectPattern {
  constructor({
    location = null,
    type = null,
    properties
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!_Array.isArray(properties)) throw new Error('properties is not a Array: ' + Class.toString(properties));
    this.location = location;
    this.type = type;
    this.properties = properties;
    Object.freeze(this);
  }

  patch(properties) {
    return new ObjectPattern({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isObjectPattern(value);
  }

}

exports.ObjectPattern = ObjectPattern;
ObjectPattern.id = 'ObjectPattern';
ObjectPattern.implements = new Set(['ObjectPattern', 'ion_Object', 'Pattern', 'Typed', 'Node']);

function isObjectPattern(value) {
  return Class.isInstance(ObjectPattern, value);
}

exports.isObjectPattern = isObjectPattern;
exports.default = ObjectPattern;
},{"./Location":"WmoZ","./ion/Null":"ozVR","./Type":"aNCm","./ion/Array":"PpFg","./ion/Class":"iy0N"}],"i8a2":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isOutlineOperation = exports.OutlineOperation = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const _Array = __importStar(require("./ion/Array"));

const String = __importStar(require("./ion/String"));

const Class = __importStar(require("./ion/Class"));

class OutlineOperation {
  constructor({
    location = null,
    type = null,
    operands,
    operator
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!_Array.isArray(operands)) throw new Error('operands is not a Array: ' + Class.toString(operands));
    if (!String.isString(operator)) throw new Error('operator is not a String: ' + Class.toString(operator));
    this.location = location;
    this.type = type;
    this.operands = operands;
    this.operator = operator;
    Object.freeze(this);
  }

  patch(properties) {
    return new OutlineOperation({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isOutlineOperation(value);
  }

}

exports.OutlineOperation = OutlineOperation;
OutlineOperation.id = 'OutlineOperation';
OutlineOperation.implements = new Set(['OutlineOperation', 'ion_Object', 'Expression', 'Typed', 'Node']);

function isOutlineOperation(value) {
  return Class.isInstance(OutlineOperation, value);
}

exports.isOutlineOperation = isOutlineOperation;
exports.default = OutlineOperation;
},{"./Location":"WmoZ","./ion/Null":"ozVR","./Type":"aNCm","./ion/Array":"PpFg","./ion/String":"CAX3","./ion/Class":"iy0N"}],"DpYk":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isParameter = exports.Parameter = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const Pattern = __importStar(require("./Pattern"));

const Expression = __importStar(require("./Expression"));

const Class = __importStar(require("./ion/Class"));

class Parameter {
  constructor({
    location = null,
    type = null,
    id,
    value = null
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!(Pattern.isPattern(id) || Expression.isExpression(id))) throw new Error('id is not a Pattern | Expression: ' + Class.toString(id));
    if (!(Expression.isExpression(value) || Null.isNull(value))) throw new Error('value is not a Expression | Null: ' + Class.toString(value));
    this.location = location;
    this.type = type;
    this.id = id;
    this.value = value;
    Object.freeze(this);
  }

  patch(properties) {
    return new Parameter({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isParameter(value);
  }

}

exports.Parameter = Parameter;
Parameter.id = 'Parameter';
Parameter.implements = new Set(['Parameter', 'ion_Object', 'Variable', 'Typed', 'Node']);

function isParameter(value) {
  return Class.isInstance(Parameter, value);
}

exports.isParameter = isParameter;
exports.default = Parameter;
},{"./Location":"WmoZ","./ion/Null":"ozVR","./Type":"aNCm","./Pattern":"lXGK","./Expression":"htdT","./ion/Class":"iy0N"}],"mjEP":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isProgram = exports.Program = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Declarator = __importStar(require("./Declarator"));

const _Array = __importStar(require("./ion/Array"));

const Class = __importStar(require("./ion/Class"));

class Program {
  constructor({
    location = null,
    id,
    body
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!Declarator.isDeclarator(id)) throw new Error('id is not a Declarator: ' + Class.toString(id));
    if (!_Array.isArray(body)) throw new Error('body is not a Array: ' + Class.toString(body));
    this.location = location;
    this.id = id;
    this.body = body;
    Object.freeze(this);
  }

  patch(properties) {
    return new Program({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isProgram(value);
  }

}

exports.Program = Program;
Program.id = 'Program';
Program.implements = new Set(['Program', 'ion_Object', 'Scope', 'Node']);

function isProgram(value) {
  return Class.isInstance(Program, value);
}

exports.isProgram = isProgram;
exports.default = Program;
},{"./Location":"WmoZ","./ion/Null":"ozVR","./Declarator":"GkPh","./ion/Array":"PpFg","./ion/Class":"iy0N"}],"MVmq":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isProperty = exports.Property = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const Expression = __importStar(require("./Expression"));

const Identifier = __importStar(require("./Identifier"));

const Pattern = __importStar(require("./Pattern"));

const String = __importStar(require("./ion/String"));

const Boolean = __importStar(require("./ion/Boolean"));

const Class = __importStar(require("./ion/Class"));

class Property {
  constructor({
    location = null,
    type = null,
    key,
    value,
    kind = 'init',
    method = false,
    shorthand = false,
    computed = false
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!(Expression.isExpression(key) || Identifier.isIdentifier(key))) throw new Error('key is not a Expression | Identifier: ' + Class.toString(key));
    if (!(Expression.isExpression(value) || Pattern.isPattern(value))) throw new Error('value is not a Expression | Pattern: ' + Class.toString(value));
    if (!String.isString(kind)) throw new Error('kind is not a String: ' + Class.toString(kind));
    if (!Boolean.isBoolean(method)) throw new Error('method is not a Boolean: ' + Class.toString(method));
    if (!Boolean.isBoolean(shorthand)) throw new Error('shorthand is not a Boolean: ' + Class.toString(shorthand));
    if (!Boolean.isBoolean(computed)) throw new Error('computed is not a Boolean: ' + Class.toString(computed));
    this.location = location;
    this.type = type;
    this.key = key;
    this.value = value;
    this.kind = kind;
    this.method = method;
    this.shorthand = shorthand;
    this.computed = computed;
    Object.freeze(this);
  }

  patch(properties) {
    return new Property({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isProperty(value);
  }

}

exports.Property = Property;
Property.id = 'Property';
Property.implements = new Set(['Property', 'ion_Object', 'Typed', 'Node']);

function isProperty(value) {
  return Class.isInstance(Property, value);
}

exports.isProperty = isProperty;
exports.default = Property;
},{"./Location":"WmoZ","./ion/Null":"ozVR","./Type":"aNCm","./Expression":"htdT","./Identifier":"yF41","./Pattern":"lXGK","./ion/String":"CAX3","./ion/Boolean":"eJLV","./ion/Class":"iy0N"}],"j000":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isPropertyStatement = exports.PropertyStatement = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const Property = __importStar(require("./Property"));

const Class = __importStar(require("./ion/Class"));

class PropertyStatement {
  constructor({
    location = null,
    type = null,
    property
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!Property.isProperty(property)) throw new Error('property is not a Property: ' + Class.toString(property));
    this.location = location;
    this.type = type;
    this.property = property;
    Object.freeze(this);
  }

  patch(properties) {
    return new PropertyStatement({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isPropertyStatement(value);
  }

}

exports.PropertyStatement = PropertyStatement;
PropertyStatement.id = 'PropertyStatement';
PropertyStatement.implements = new Set(['PropertyStatement', 'ion_Object', 'Statement', 'Typed', 'Node']);

function isPropertyStatement(value) {
  return Class.isInstance(PropertyStatement, value);
}

exports.isPropertyStatement = isPropertyStatement;
exports.default = PropertyStatement;
},{"./Location":"WmoZ","./ion/Null":"ozVR","./Type":"aNCm","./Property":"MVmq","./ion/Class":"iy0N"}],"BzJU":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isReference = exports.Reference = void 0;

const Type = __importStar(require("./Type"));

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const String = __importStar(require("./ion/String"));

const _Array = __importStar(require("./ion/Array"));

const Class = __importStar(require("./ion/Class"));

class Reference {
  constructor({
    location = null,
    name,
    path = null,
    type = null,
    arguments: _arguments = null
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!String.isString(name)) throw new Error('name is not a String: ' + Class.toString(name));
    if (!(String.isString(path) || Null.isNull(path))) throw new Error('path is not a String | Null: ' + Class.toString(path));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!(_Array.isArray(_arguments) || Null.isNull(_arguments))) throw new Error('arguments is not a Array | Null: ' + Class.toString(_arguments));
    this.location = location;
    this.name = name;
    this.path = path;
    this.type = type;
    this.arguments = _arguments;
    Object.freeze(this);
  }

  patch(properties) {
    return new Reference({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isReference(value);
  }

}

exports.Reference = Reference;
Reference.id = 'Reference';
Reference.implements = new Set(['Reference', 'ion_Object', 'Identifier', 'Expression', 'Type', 'Node', 'Typed']);

function isReference(value) {
  return Class.isInstance(Reference, value);
}

exports.isReference = isReference;
exports.default = Reference;
},{"./Type":"aNCm","./Location":"WmoZ","./ion/Null":"ozVR","./ion/String":"CAX3","./ion/Array":"PpFg","./ion/Class":"iy0N"}],"BQ9J":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isRegularExpression = exports.RegularExpression = void 0;

const Type = __importStar(require("./Type"));

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const String = __importStar(require("./ion/String"));

const Class = __importStar(require("./ion/Class"));

class RegularExpression {
  constructor({
    location = null,
    type = null,
    pattern,
    flags
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!String.isString(pattern)) throw new Error('pattern is not a String: ' + Class.toString(pattern));
    if (!String.isString(flags)) throw new Error('flags is not a String: ' + Class.toString(flags));
    this.location = location;
    this.type = type;
    this.pattern = pattern;
    this.flags = flags;
    Object.freeze(this);
  }

  patch(properties) {
    return new RegularExpression({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isRegularExpression(value);
  }

}

exports.RegularExpression = RegularExpression;
RegularExpression.id = 'RegularExpression';
RegularExpression.implements = new Set(['RegularExpression', 'ion_Object', 'Expression', 'Type', 'Typed', 'Node']);

function isRegularExpression(value) {
  return Class.isInstance(RegularExpression, value);
}

exports.isRegularExpression = isRegularExpression;
exports.default = RegularExpression;
},{"./Type":"aNCm","./Location":"WmoZ","./ion/Null":"ozVR","./ion/String":"CAX3","./ion/Class":"iy0N"}],"lFlI":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isRestElement = exports.RestElement = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const Declarator = __importStar(require("./Declarator"));

const Class = __importStar(require("./ion/Class"));

class RestElement {
  constructor({
    location = null,
    type = null,
    argument
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!Declarator.isDeclarator(argument)) throw new Error('argument is not a Declarator: ' + Class.toString(argument));
    this.location = location;
    this.type = type;
    this.argument = argument;
    Object.freeze(this);
  }

  patch(properties) {
    return new RestElement({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isRestElement(value);
  }

}

exports.RestElement = RestElement;
RestElement.id = 'RestElement';
RestElement.implements = new Set(['RestElement', 'ion_Object', 'Pattern', 'Typed', 'Node']);

function isRestElement(value) {
  return Class.isInstance(RestElement, value);
}

exports.isRestElement = isRestElement;
exports.default = RestElement;
},{"./Location":"WmoZ","./ion/Null":"ozVR","./Type":"aNCm","./Declarator":"GkPh","./ion/Class":"iy0N"}],"GovC":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isReturnStatement = exports.ReturnStatement = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const Expression = __importStar(require("./Expression"));

const Class = __importStar(require("./ion/Class"));

class ReturnStatement {
  constructor({
    location = null,
    type = null,
    argument
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!Expression.isExpression(argument)) throw new Error('argument is not a Expression: ' + Class.toString(argument));
    this.location = location;
    this.type = type;
    this.argument = argument;
    Object.freeze(this);
  }

  patch(properties) {
    return new ReturnStatement({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isReturnStatement(value);
  }

}

exports.ReturnStatement = ReturnStatement;
ReturnStatement.id = 'ReturnStatement';
ReturnStatement.implements = new Set(['ReturnStatement', 'ion_Object', 'Statement', 'Typed', 'Node']);

function isReturnStatement(value) {
  return Class.isInstance(ReturnStatement, value);
}

exports.isReturnStatement = isReturnStatement;
exports.default = ReturnStatement;
},{"./Location":"WmoZ","./ion/Null":"ozVR","./Type":"aNCm","./Expression":"htdT","./ion/Class":"iy0N"}],"rDqY":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isScope = exports.Scope = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Class = __importStar(require("./ion/Class"));

class Scope {
  constructor({
    location = null
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    this.location = location;
    Object.freeze(this);
  }

  patch(properties) {
    return new Scope({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isScope(value);
  }

}

exports.Scope = Scope;
Scope.id = 'Scope';
Scope.implements = new Set(['Scope', 'ion_Object', 'Node']);

function isScope(value) {
  return Class.isInstance(Scope, value);
}

exports.isScope = isScope;
exports.default = Scope;
},{"./Location":"WmoZ","./ion/Null":"ozVR","./ion/Class":"iy0N"}],"cBQA":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isStatement = exports.Statement = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const Class = __importStar(require("./ion/Class"));

class Statement {
  constructor({
    location = null,
    type = null
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    this.location = location;
    this.type = type;
    Object.freeze(this);
  }

  patch(properties) {
    return new Statement({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isStatement(value);
  }

}

exports.Statement = Statement;
Statement.id = 'Statement';
Statement.implements = new Set(['Statement', 'ion_Object', 'Typed', 'Node']);

function isStatement(value) {
  return Class.isInstance(Statement, value);
}

exports.isStatement = isStatement;
exports.default = Statement;
},{"./Location":"WmoZ","./ion/Null":"ozVR","./Type":"aNCm","./ion/Class":"iy0N"}],"AMVm":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isSwitchCase = exports.SwitchCase = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Expression = __importStar(require("./Expression"));

const BlockStatement = __importStar(require("./BlockStatement"));

const Class = __importStar(require("./ion/Class"));

class SwitchCase {
  constructor({
    location = null,
    test,
    consequent
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Expression.isExpression(test) || Null.isNull(test))) throw new Error('test is not a Expression | Null: ' + Class.toString(test));
    if (!(BlockStatement.isBlockStatement(consequent) || Null.isNull(consequent))) throw new Error('consequent is not a BlockStatement | Null: ' + Class.toString(consequent));
    this.location = location;
    this.test = test;
    this.consequent = consequent;
    Object.freeze(this);
  }

  patch(properties) {
    return new SwitchCase({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isSwitchCase(value);
  }

}

exports.SwitchCase = SwitchCase;
SwitchCase.id = 'SwitchCase';
SwitchCase.implements = new Set(['SwitchCase', 'ion_Object', 'Node']);

function isSwitchCase(value) {
  return Class.isInstance(SwitchCase, value);
}

exports.isSwitchCase = isSwitchCase;
exports.default = SwitchCase;
},{"./Location":"WmoZ","./ion/Null":"ozVR","./Expression":"htdT","./BlockStatement":"KP28","./ion/Class":"iy0N"}],"MNK8":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isSwitchStatement = exports.SwitchStatement = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const Expression = __importStar(require("./Expression"));

const _Array = __importStar(require("./ion/Array"));

const Class = __importStar(require("./ion/Class"));

class SwitchStatement {
  constructor({
    location = null,
    type = null,
    discriminant,
    cases
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!Expression.isExpression(discriminant)) throw new Error('discriminant is not a Expression: ' + Class.toString(discriminant));
    if (!_Array.isArray(cases)) throw new Error('cases is not a Array: ' + Class.toString(cases));
    this.location = location;
    this.type = type;
    this.discriminant = discriminant;
    this.cases = cases;
    Object.freeze(this);
  }

  patch(properties) {
    return new SwitchStatement({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isSwitchStatement(value);
  }

}

exports.SwitchStatement = SwitchStatement;
SwitchStatement.id = 'SwitchStatement';
SwitchStatement.implements = new Set(['SwitchStatement', 'ion_Object', 'Statement', 'Typed', 'Node']);

function isSwitchStatement(value) {
  return Class.isInstance(SwitchStatement, value);
}

exports.isSwitchStatement = isSwitchStatement;
exports.default = SwitchStatement;
},{"./Location":"WmoZ","./ion/Null":"ozVR","./Type":"aNCm","./Expression":"htdT","./ion/Array":"PpFg","./ion/Class":"iy0N"}],"DQjH":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isThisExpression = exports.ThisExpression = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const Class = __importStar(require("./ion/Class"));

class ThisExpression {
  constructor({
    location = null,
    type = null
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    this.location = location;
    this.type = type;
    Object.freeze(this);
  }

  patch(properties) {
    return new ThisExpression({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isThisExpression(value);
  }

}

exports.ThisExpression = ThisExpression;
ThisExpression.id = 'ThisExpression';
ThisExpression.implements = new Set(['ThisExpression', 'ion_Object', 'Expression', 'Typed', 'Node']);

function isThisExpression(value) {
  return Class.isInstance(ThisExpression, value);
}

exports.isThisExpression = isThisExpression;
exports.default = ThisExpression;
},{"./Location":"WmoZ","./ion/Null":"ozVR","./Type":"aNCm","./ion/Class":"iy0N"}],"BS2q":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isThrowStatement = exports.ThrowStatement = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const Expression = __importStar(require("./Expression"));

const Class = __importStar(require("./ion/Class"));

class ThrowStatement {
  constructor({
    location = null,
    type = null,
    argument
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!Expression.isExpression(argument)) throw new Error('argument is not a Expression: ' + Class.toString(argument));
    this.location = location;
    this.type = type;
    this.argument = argument;
    Object.freeze(this);
  }

  patch(properties) {
    return new ThrowStatement({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isThrowStatement(value);
  }

}

exports.ThrowStatement = ThrowStatement;
ThrowStatement.id = 'ThrowStatement';
ThrowStatement.implements = new Set(['ThrowStatement', 'ion_Object', 'Statement', 'Typed', 'Node']);

function isThrowStatement(value) {
  return Class.isInstance(ThrowStatement, value);
}

exports.isThrowStatement = isThrowStatement;
exports.default = ThrowStatement;
},{"./Location":"WmoZ","./ion/Null":"ozVR","./Type":"aNCm","./Expression":"htdT","./ion/Class":"iy0N"}],"QJxJ":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isTryStatement = exports.TryStatement = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const BlockStatement = __importStar(require("./BlockStatement"));

const CatchClause = __importStar(require("./CatchClause"));

const Class = __importStar(require("./ion/Class"));

class TryStatement {
  constructor({
    location = null,
    type = null,
    block,
    handler = null,
    finalizer = null
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!BlockStatement.isBlockStatement(block)) throw new Error('block is not a BlockStatement: ' + Class.toString(block));
    if (!(CatchClause.isCatchClause(handler) || Null.isNull(handler))) throw new Error('handler is not a CatchClause | Null: ' + Class.toString(handler));
    if (!(BlockStatement.isBlockStatement(finalizer) || Null.isNull(finalizer))) throw new Error('finalizer is not a BlockStatement | Null: ' + Class.toString(finalizer));
    this.location = location;
    this.type = type;
    this.block = block;
    this.handler = handler;
    this.finalizer = finalizer;
    Object.freeze(this);
  }

  patch(properties) {
    return new TryStatement({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isTryStatement(value);
  }

}

exports.TryStatement = TryStatement;
TryStatement.id = 'TryStatement';
TryStatement.implements = new Set(['TryStatement', 'ion_Object', 'Statement', 'Typed', 'Node']);

function isTryStatement(value) {
  return Class.isInstance(TryStatement, value);
}

exports.isTryStatement = isTryStatement;
exports.default = TryStatement;
},{"./Location":"WmoZ","./ion/Null":"ozVR","./Type":"aNCm","./BlockStatement":"KP28","./CatchClause":"cLXq","./ion/Class":"iy0N"}],"MOIc":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isTypeExpression = exports.TypeExpression = void 0;

const Type = __importStar(require("./Type"));

const Expression = __importStar(require("./Expression"));

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Class = __importStar(require("./ion/Class"));

class TypeExpression {
  constructor({
    location = null,
    type = null,
    value
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!Expression.isExpression(value)) throw new Error('value is not a Expression: ' + Class.toString(value));
    this.location = location;
    this.type = type;
    this.value = value;
    Object.freeze(this);
  }

  patch(properties) {
    return new TypeExpression({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isTypeExpression(value);
  }

}

exports.TypeExpression = TypeExpression;
TypeExpression.id = 'TypeExpression';
TypeExpression.implements = new Set(['TypeExpression', 'ion_Object', 'Type', 'Expression', 'Typed', 'Node']);

function isTypeExpression(value) {
  return Class.isInstance(TypeExpression, value);
}

exports.isTypeExpression = isTypeExpression;
exports.default = TypeExpression;
},{"./Type":"aNCm","./Expression":"htdT","./Location":"WmoZ","./ion/Null":"ozVR","./ion/Class":"iy0N"}],"lxAy":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isTyped = exports.Typed = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const Class = __importStar(require("./ion/Class"));

class Typed {
  constructor({
    location = null,
    type = null
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    this.location = location;
    this.type = type;
    Object.freeze(this);
  }

  patch(properties) {
    return new Typed({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isTyped(value);
  }

}

exports.Typed = Typed;
Typed.id = 'Typed';
Typed.implements = new Set(['Typed', 'ion_Object', 'Node']);

function isTyped(value) {
  return Class.isInstance(Typed, value);
}

exports.isTyped = isTyped;
exports.default = Typed;
},{"./Location":"WmoZ","./ion/Null":"ozVR","./Type":"aNCm","./ion/Class":"iy0N"}],"mhlq":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isUnaryExpression = exports.UnaryExpression = void 0;

const Expression = __importStar(require("./Expression"));

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const String = __importStar(require("./ion/String"));

const Boolean = __importStar(require("./ion/Boolean"));

const Class = __importStar(require("./ion/Class"));

class UnaryExpression {
  constructor({
    location = null,
    type = null,
    operator,
    argument,
    prefix = true
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!String.isString(operator)) throw new Error('operator is not a String: ' + Class.toString(operator));
    if (!Expression.isExpression(argument)) throw new Error('argument is not a Expression: ' + Class.toString(argument));
    if (!Boolean.isBoolean(prefix)) throw new Error('prefix is not a Boolean: ' + Class.toString(prefix));
    this.location = location;
    this.type = type;
    this.operator = operator;
    this.argument = argument;
    this.prefix = prefix;
    Object.freeze(this);
  }

  patch(properties) {
    return new UnaryExpression({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isUnaryExpression(value);
  }

}

exports.UnaryExpression = UnaryExpression;
UnaryExpression.id = 'UnaryExpression';
UnaryExpression.implements = new Set(['UnaryExpression', 'ion_Object', 'Expression', 'Typed', 'Node']);

function isUnaryExpression(value) {
  return Class.isInstance(UnaryExpression, value);
}

exports.isUnaryExpression = isUnaryExpression;
exports.default = UnaryExpression;
},{"./Expression":"htdT","./Location":"WmoZ","./ion/Null":"ozVR","./Type":"aNCm","./ion/String":"CAX3","./ion/Boolean":"eJLV","./ion/Class":"iy0N"}],"CXdX":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isVariable = exports.Variable = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const Pattern = __importStar(require("./Pattern"));

const Expression = __importStar(require("./Expression"));

const Class = __importStar(require("./ion/Class"));

class Variable {
  constructor({
    location = null,
    type = null,
    id,
    value = null
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!(Pattern.isPattern(id) || Expression.isExpression(id))) throw new Error('id is not a Pattern | Expression: ' + Class.toString(id));
    if (!(Expression.isExpression(value) || Null.isNull(value))) throw new Error('value is not a Expression | Null: ' + Class.toString(value));
    this.location = location;
    this.type = type;
    this.id = id;
    this.value = value;
    Object.freeze(this);
  }

  patch(properties) {
    return new Variable({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isVariable(value);
  }

}

exports.Variable = Variable;
Variable.id = 'Variable';
Variable.implements = new Set(['Variable', 'ion_Object', 'Typed', 'Node']);

function isVariable(value) {
  return Class.isInstance(Variable, value);
}

exports.isVariable = isVariable;
exports.default = Variable;
},{"./Location":"WmoZ","./ion/Null":"ozVR","./Type":"aNCm","./Pattern":"lXGK","./Expression":"htdT","./ion/Class":"iy0N"}],"q57X":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isWhileStatement = exports.WhileStatement = void 0;

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const Expression = __importStar(require("./Expression"));

const BlockStatement = __importStar(require("./BlockStatement"));

const Class = __importStar(require("./ion/Class"));

class WhileStatement {
  constructor({
    location = null,
    type = null,
    test,
    body
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!Expression.isExpression(test)) throw new Error('test is not a Expression: ' + Class.toString(test));
    if (!BlockStatement.isBlockStatement(body)) throw new Error('body is not a BlockStatement: ' + Class.toString(body));
    this.location = location;
    this.type = type;
    this.test = test;
    this.body = body;
    Object.freeze(this);
  }

  patch(properties) {
    return new WhileStatement({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isWhileStatement(value);
  }

}

exports.WhileStatement = WhileStatement;
WhileStatement.id = 'WhileStatement';
WhileStatement.implements = new Set(['WhileStatement', 'ion_Object', 'Statement', 'Typed', 'Node']);

function isWhileStatement(value) {
  return Class.isInstance(WhileStatement, value);
}

exports.isWhileStatement = isWhileStatement;
exports.default = WhileStatement;
},{"./Location":"WmoZ","./ion/Null":"ozVR","./Type":"aNCm","./Expression":"htdT","./BlockStatement":"KP28","./ion/Class":"iy0N"}],"xXUT":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isYieldExpression = exports.YieldExpression = void 0;

const Expression = __importStar(require("./Expression"));

const Location = __importStar(require("./Location"));

const Null = __importStar(require("./ion/Null"));

const Type = __importStar(require("./Type"));

const Boolean = __importStar(require("./ion/Boolean"));

const Class = __importStar(require("./ion/Class"));

class YieldExpression {
  constructor({
    location = null,
    type = null,
    argument,
    delegate = false
  }) {
    if (!(Location.isLocation(location) || Null.isNull(location))) throw new Error('location is not a Location | Null: ' + Class.toString(location));
    if (!(Type.isType(type) || Null.isNull(type))) throw new Error('type is not a Type | Null: ' + Class.toString(type));
    if (!Expression.isExpression(argument)) throw new Error('argument is not a Expression: ' + Class.toString(argument));
    if (!Boolean.isBoolean(delegate)) throw new Error('delegate is not a Boolean: ' + Class.toString(delegate));
    this.location = location;
    this.type = type;
    this.argument = argument;
    this.delegate = delegate;
    Object.freeze(this);
  }

  patch(properties) {
    return new YieldExpression({ ...this,
      ...properties
    });
  }

  static is(value) {
    return isYieldExpression(value);
  }

}

exports.YieldExpression = YieldExpression;
YieldExpression.id = 'YieldExpression';
YieldExpression.implements = new Set(['YieldExpression', 'ion_Object', 'Expression', 'Typed', 'Node']);

function isYieldExpression(value) {
  return Class.isInstance(YieldExpression, value);
}

exports.isYieldExpression = isYieldExpression;
exports.default = YieldExpression;
},{"./Expression":"htdT","./Location":"WmoZ","./ion/Null":"ozVR","./Type":"aNCm","./ion/Boolean":"eJLV","./ion/Class":"iy0N"}],"rCtP":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var Analysis_1 = require("./Analysis");

Object.defineProperty(exports, "Analysis", {
  enumerable: true,
  get: function () {
    return Analysis_1.default;
  }
});

var ArrayExpression_1 = require("./ArrayExpression");

Object.defineProperty(exports, "ArrayExpression", {
  enumerable: true,
  get: function () {
    return ArrayExpression_1.default;
  }
});

var ArrayPattern_1 = require("./ArrayPattern");

Object.defineProperty(exports, "ArrayPattern", {
  enumerable: true,
  get: function () {
    return ArrayPattern_1.default;
  }
});

var ArrowFunctionExpression_1 = require("./ArrowFunctionExpression");

Object.defineProperty(exports, "ArrowFunctionExpression", {
  enumerable: true,
  get: function () {
    return ArrowFunctionExpression_1.default;
  }
});

var Assembly_1 = require("./Assembly");

Object.defineProperty(exports, "Assembly", {
  enumerable: true,
  get: function () {
    return Assembly_1.default;
  }
});

var AssignmentPattern_1 = require("./AssignmentPattern");

Object.defineProperty(exports, "AssignmentPattern", {
  enumerable: true,
  get: function () {
    return AssignmentPattern_1.default;
  }
});

var AssignmentStatement_1 = require("./AssignmentStatement");

Object.defineProperty(exports, "AssignmentStatement", {
  enumerable: true,
  get: function () {
    return AssignmentStatement_1.default;
  }
});

var AwaitExpression_1 = require("./AwaitExpression");

Object.defineProperty(exports, "AwaitExpression", {
  enumerable: true,
  get: function () {
    return AwaitExpression_1.default;
  }
});

var BinaryExpression_1 = require("./BinaryExpression");

Object.defineProperty(exports, "BinaryExpression", {
  enumerable: true,
  get: function () {
    return BinaryExpression_1.default;
  }
});

var BlockStatement_1 = require("./BlockStatement");

Object.defineProperty(exports, "BlockStatement", {
  enumerable: true,
  get: function () {
    return BlockStatement_1.default;
  }
});

var BreakStatement_1 = require("./BreakStatement");

Object.defineProperty(exports, "BreakStatement", {
  enumerable: true,
  get: function () {
    return BreakStatement_1.default;
  }
});

var CallExpression_1 = require("./CallExpression");

Object.defineProperty(exports, "CallExpression", {
  enumerable: true,
  get: function () {
    return CallExpression_1.default;
  }
});

var CatchClause_1 = require("./CatchClause");

Object.defineProperty(exports, "CatchClause", {
  enumerable: true,
  get: function () {
    return CatchClause_1.default;
  }
});

var ChainElement_1 = require("./ChainElement");

Object.defineProperty(exports, "ChainElement", {
  enumerable: true,
  get: function () {
    return ChainElement_1.default;
  }
});

var ClassDeclaration_1 = require("./ClassDeclaration");

Object.defineProperty(exports, "ClassDeclaration", {
  enumerable: true,
  get: function () {
    return ClassDeclaration_1.default;
  }
});

var ConditionalDeclaration_1 = require("./ConditionalDeclaration");

Object.defineProperty(exports, "ConditionalDeclaration", {
  enumerable: true,
  get: function () {
    return ConditionalDeclaration_1.default;
  }
});

var ConditionalExpression_1 = require("./ConditionalExpression");

Object.defineProperty(exports, "ConditionalExpression", {
  enumerable: true,
  get: function () {
    return ConditionalExpression_1.default;
  }
});

var ContinueStatement_1 = require("./ContinueStatement");

Object.defineProperty(exports, "ContinueStatement", {
  enumerable: true,
  get: function () {
    return ContinueStatement_1.default;
  }
});

var Declaration_1 = require("./Declaration");

Object.defineProperty(exports, "Declaration", {
  enumerable: true,
  get: function () {
    return Declaration_1.default;
  }
});

var Declarator_1 = require("./Declarator");

Object.defineProperty(exports, "Declarator", {
  enumerable: true,
  get: function () {
    return Declarator_1.default;
  }
});

var DotExpression_1 = require("./DotExpression");

Object.defineProperty(exports, "DotExpression", {
  enumerable: true,
  get: function () {
    return DotExpression_1.default;
  }
});

var ElementExpression_1 = require("./ElementExpression");

Object.defineProperty(exports, "ElementExpression", {
  enumerable: true,
  get: function () {
    return ElementExpression_1.default;
  }
});

var Exportable_1 = require("./Exportable");

Object.defineProperty(exports, "Exportable", {
  enumerable: true,
  get: function () {
    return Exportable_1.default;
  }
});

var Expression_1 = require("./Expression");

Object.defineProperty(exports, "Expression", {
  enumerable: true,
  get: function () {
    return Expression_1.default;
  }
});

var ExpressionStatement_1 = require("./ExpressionStatement");

Object.defineProperty(exports, "ExpressionStatement", {
  enumerable: true,
  get: function () {
    return ExpressionStatement_1.default;
  }
});

var ForOfStatement_1 = require("./ForOfStatement");

Object.defineProperty(exports, "ForOfStatement", {
  enumerable: true,
  get: function () {
    return ForOfStatement_1.default;
  }
});

var ForStatement_1 = require("./ForStatement");

Object.defineProperty(exports, "ForStatement", {
  enumerable: true,
  get: function () {
    return ForStatement_1.default;
  }
});

var FunctionExpression_1 = require("./FunctionExpression");

Object.defineProperty(exports, "FunctionExpression", {
  enumerable: true,
  get: function () {
    return FunctionExpression_1.default;
  }
});

var FunctionType_1 = require("./FunctionType");

Object.defineProperty(exports, "FunctionType", {
  enumerable: true,
  get: function () {
    return FunctionType_1.default;
  }
});

var Identifier_1 = require("./Identifier");

Object.defineProperty(exports, "Identifier", {
  enumerable: true,
  get: function () {
    return Identifier_1.default;
  }
});

var IfStatement_1 = require("./IfStatement");

Object.defineProperty(exports, "IfStatement", {
  enumerable: true,
  get: function () {
    return IfStatement_1.default;
  }
});

var ImportDeclaration_1 = require("./ImportDeclaration");

Object.defineProperty(exports, "ImportDeclaration", {
  enumerable: true,
  get: function () {
    return ImportDeclaration_1.default;
  }
});

var ImportDefaultSpecifier_1 = require("./ImportDefaultSpecifier");

Object.defineProperty(exports, "ImportDefaultSpecifier", {
  enumerable: true,
  get: function () {
    return ImportDefaultSpecifier_1.default;
  }
});

var ImportNamespaceSpecifier_1 = require("./ImportNamespaceSpecifier");

Object.defineProperty(exports, "ImportNamespaceSpecifier", {
  enumerable: true,
  get: function () {
    return ImportNamespaceSpecifier_1.default;
  }
});

var ImportSpecifier_1 = require("./ImportSpecifier");

Object.defineProperty(exports, "ImportSpecifier", {
  enumerable: true,
  get: function () {
    return ImportSpecifier_1.default;
  }
});

var InstanceDeclarations_1 = require("./InstanceDeclarations");

Object.defineProperty(exports, "InstanceDeclarations", {
  enumerable: true,
  get: function () {
    return InstanceDeclarations_1.default;
  }
});

var Literal_1 = require("./Literal");

Object.defineProperty(exports, "Literal", {
  enumerable: true,
  get: function () {
    return Literal_1.default;
  }
});

var Location_1 = require("./Location");

Object.defineProperty(exports, "Location", {
  enumerable: true,
  get: function () {
    return Location_1.default;
  }
});

var MemberExpression_1 = require("./MemberExpression");

Object.defineProperty(exports, "MemberExpression", {
  enumerable: true,
  get: function () {
    return MemberExpression_1.default;
  }
});

var MethodDefinition_1 = require("./MethodDefinition");

Object.defineProperty(exports, "MethodDefinition", {
  enumerable: true,
  get: function () {
    return MethodDefinition_1.default;
  }
});

var ModuleSpecifier_1 = require("./ModuleSpecifier");

Object.defineProperty(exports, "ModuleSpecifier", {
  enumerable: true,
  get: function () {
    return ModuleSpecifier_1.default;
  }
});

var Node_1 = require("./Node");

Object.defineProperty(exports, "Node", {
  enumerable: true,
  get: function () {
    return Node_1.default;
  }
});

var ObjectExpression_1 = require("./ObjectExpression");

Object.defineProperty(exports, "ObjectExpression", {
  enumerable: true,
  get: function () {
    return ObjectExpression_1.default;
  }
});

var ObjectPattern_1 = require("./ObjectPattern");

Object.defineProperty(exports, "ObjectPattern", {
  enumerable: true,
  get: function () {
    return ObjectPattern_1.default;
  }
});

var OutlineOperation_1 = require("./OutlineOperation");

Object.defineProperty(exports, "OutlineOperation", {
  enumerable: true,
  get: function () {
    return OutlineOperation_1.default;
  }
});

var Parameter_1 = require("./Parameter");

Object.defineProperty(exports, "Parameter", {
  enumerable: true,
  get: function () {
    return Parameter_1.default;
  }
});

var Pattern_1 = require("./Pattern");

Object.defineProperty(exports, "Pattern", {
  enumerable: true,
  get: function () {
    return Pattern_1.default;
  }
});

var Position_1 = require("./Position");

Object.defineProperty(exports, "Position", {
  enumerable: true,
  get: function () {
    return Position_1.default;
  }
});

var Program_1 = require("./Program");

Object.defineProperty(exports, "Program", {
  enumerable: true,
  get: function () {
    return Program_1.default;
  }
});

var Property_1 = require("./Property");

Object.defineProperty(exports, "Property", {
  enumerable: true,
  get: function () {
    return Property_1.default;
  }
});

var PropertyStatement_1 = require("./PropertyStatement");

Object.defineProperty(exports, "PropertyStatement", {
  enumerable: true,
  get: function () {
    return PropertyStatement_1.default;
  }
});

var Reference_1 = require("./Reference");

Object.defineProperty(exports, "Reference", {
  enumerable: true,
  get: function () {
    return Reference_1.default;
  }
});

var RegularExpression_1 = require("./RegularExpression");

Object.defineProperty(exports, "RegularExpression", {
  enumerable: true,
  get: function () {
    return RegularExpression_1.default;
  }
});

var RestElement_1 = require("./RestElement");

Object.defineProperty(exports, "RestElement", {
  enumerable: true,
  get: function () {
    return RestElement_1.default;
  }
});

var ReturnStatement_1 = require("./ReturnStatement");

Object.defineProperty(exports, "ReturnStatement", {
  enumerable: true,
  get: function () {
    return ReturnStatement_1.default;
  }
});

var Scope_1 = require("./Scope");

Object.defineProperty(exports, "Scope", {
  enumerable: true,
  get: function () {
    return Scope_1.default;
  }
});

var SpreadElement_1 = require("./SpreadElement");

Object.defineProperty(exports, "SpreadElement", {
  enumerable: true,
  get: function () {
    return SpreadElement_1.default;
  }
});

var Statement_1 = require("./Statement");

Object.defineProperty(exports, "Statement", {
  enumerable: true,
  get: function () {
    return Statement_1.default;
  }
});

var SwitchCase_1 = require("./SwitchCase");

Object.defineProperty(exports, "SwitchCase", {
  enumerable: true,
  get: function () {
    return SwitchCase_1.default;
  }
});

var SwitchStatement_1 = require("./SwitchStatement");

Object.defineProperty(exports, "SwitchStatement", {
  enumerable: true,
  get: function () {
    return SwitchStatement_1.default;
  }
});

var ThisExpression_1 = require("./ThisExpression");

Object.defineProperty(exports, "ThisExpression", {
  enumerable: true,
  get: function () {
    return ThisExpression_1.default;
  }
});

var ThrowStatement_1 = require("./ThrowStatement");

Object.defineProperty(exports, "ThrowStatement", {
  enumerable: true,
  get: function () {
    return ThrowStatement_1.default;
  }
});

var TryStatement_1 = require("./TryStatement");

Object.defineProperty(exports, "TryStatement", {
  enumerable: true,
  get: function () {
    return TryStatement_1.default;
  }
});

var Type_1 = require("./Type");

Object.defineProperty(exports, "Type", {
  enumerable: true,
  get: function () {
    return Type_1.default;
  }
});

var TypeExpression_1 = require("./TypeExpression");

Object.defineProperty(exports, "TypeExpression", {
  enumerable: true,
  get: function () {
    return TypeExpression_1.default;
  }
});

var Typed_1 = require("./Typed");

Object.defineProperty(exports, "Typed", {
  enumerable: true,
  get: function () {
    return Typed_1.default;
  }
});

var UnaryExpression_1 = require("./UnaryExpression");

Object.defineProperty(exports, "UnaryExpression", {
  enumerable: true,
  get: function () {
    return UnaryExpression_1.default;
  }
});

var Variable_1 = require("./Variable");

Object.defineProperty(exports, "Variable", {
  enumerable: true,
  get: function () {
    return Variable_1.default;
  }
});

var VariableDeclaration_1 = require("./VariableDeclaration");

Object.defineProperty(exports, "VariableDeclaration", {
  enumerable: true,
  get: function () {
    return VariableDeclaration_1.default;
  }
});

var WhileStatement_1 = require("./WhileStatement");

Object.defineProperty(exports, "WhileStatement", {
  enumerable: true,
  get: function () {
    return WhileStatement_1.default;
  }
});

var YieldExpression_1 = require("./YieldExpression");

Object.defineProperty(exports, "YieldExpression", {
  enumerable: true,
  get: function () {
    return YieldExpression_1.default;
  }
});
},{"./Analysis":"xMkn","./ArrayExpression":"DUgi","./ArrayPattern":"rXs3","./ArrowFunctionExpression":"BBgA","./Assembly":"Aly1","./AssignmentPattern":"ctBp","./AssignmentStatement":"GPPI","./AwaitExpression":"n6ms","./BinaryExpression":"v4in","./BlockStatement":"KP28","./BreakStatement":"UlDp","./CallExpression":"xjN4","./CatchClause":"cLXq","./ChainElement":"rzYm","./ClassDeclaration":"cVoV","./ConditionalDeclaration":"l4vW","./ConditionalExpression":"ROnC","./ContinueStatement":"ASeV","./Declaration":"ncJC","./Declarator":"GkPh","./DotExpression":"EsPb","./ElementExpression":"eNg6","./Exportable":"S47C","./Expression":"htdT","./ExpressionStatement":"pROO","./ForOfStatement":"iuoi","./ForStatement":"gPRV","./FunctionExpression":"c6YV","./FunctionType":"TEUp","./Identifier":"yF41","./IfStatement":"VWfJ","./ImportDeclaration":"Gpay","./ImportDefaultSpecifier":"rUZN","./ImportNamespaceSpecifier":"zYhG","./ImportSpecifier":"vQgK","./InstanceDeclarations":"X8Jq","./Literal":"OSXi","./Location":"WmoZ","./MemberExpression":"J940","./MethodDefinition":"uZ2y","./ModuleSpecifier":"TUZi","./Node":"VLt5","./ObjectExpression":"vayH","./ObjectPattern":"KtIa","./OutlineOperation":"i8a2","./Parameter":"DpYk","./Pattern":"lXGK","./Position":"ifA8","./Program":"mjEP","./Property":"MVmq","./PropertyStatement":"j000","./Reference":"BzJU","./RegularExpression":"BQ9J","./RestElement":"lFlI","./ReturnStatement":"GovC","./Scope":"rDqY","./SpreadElement":"q56r","./Statement":"cBQA","./SwitchCase":"AMVm","./SwitchStatement":"MNK8","./ThisExpression":"DQjH","./ThrowStatement":"BS2q","./TryStatement":"QJxJ","./Type":"aNCm","./TypeExpression":"MOIc","./Typed":"lxAy","./UnaryExpression":"mhlq","./Variable":"CXdX","./VariableDeclaration":"n5i9","./WhileStatement":"q57X","./YieldExpression":"xXUT"}],"IQyZ":[function(require,module,exports) {
module.exports = exports = function () {
  var runtime;

  try {
    runtime = require('pegs');
  } catch (e) {}

  if (runtime == null) {
    /* use r to avoid parcel trying to resolve path */
    var r = require;
    runtime = r('../runtime');
  }

  var Context = runtime.Context;
  var Parser = runtime.Parser;
  var Grammar = runtime.Grammar;
  var Position = runtime.Position;
  var Rule = runtime.Rule;
  var SourceLocation = runtime.SourceLocation;
  var Terminal = runtime.Terminal;
  var CharRange = runtime.CharRange;
  var Regex = runtime.Regex;
  var Reference = runtime.Reference;
  var Any = runtime.Any;
  var Sequence = runtime.Sequence;
  var Choice = runtime.Choice;
  var Repeat = runtime.Repeat;
  var Optional = runtime.Optional;
  var NotPredicate = runtime.NotPredicate;
  var AndPredicate = runtime.AndPredicate;
  var StringValue = runtime.StringValue;
  var Extract = runtime.Extract;
  var Group = runtime.Group;
  var Increment = runtime.Increment;
  var Action = runtime.Action;
  var CustomPredicate = runtime.CustomPredicate;
  return function (options) {
    if (options == null) options = {};
    var parser;

    var location = function () {
      return parser.context.location();
    };

    var text = function () {
      let loc = location();
      return parser.context.source.substring(loc.start.offset, loc.end.offset);
    };

    const ast = require("./ast"); // const types = require("./types")


    const pathSeparator = "/";

    function getLocation() {
      let {
        start,
        end,
        filename
      } = location();
      return new ast.Location({
        start: new ast.Position(start.offset, start.line, start.column),
        end: new ast.Position(end.offset, end.line, end.column),
        filename
      });
    }

    function isUpperCase(name) {
      let first = name[0];
      return first === first.toUpperCase();
    }

    function isTypeName(name) {
      return isUpperCase(name);
    }

    function getRelativePrefixSteps(relative) {
      if (relative === 0) {
        return [];
      }

      if (relative == 1) {
        return ["."];
      }

      return new Array(relative - 1).fill("..");
    }

    function node(type, ...values) {
      // we assign again in case it was overridden by copy values
      let TypeConstructor = ast[type];

      if (TypeConstructor == null) {
        throw new Error(`Missing Type: ${type}`);
      }

      let result = new TypeConstructor(Object.assign({
        location: getLocation()
      }, ...values));
      return result;
    }

    function operation(left, operator, right) {
      if (right) {
        return node("BinaryExpression", {
          left,
          operator,
          right
        });
      } else {
        return node("UnaryExpression", {
          operator,
          left
        });
      }
    }

    function buildBinaryExpression(head, tail) {
      return tail.reduce((left, [, operator,, right]) => {
        if (operator === "isnt") {
          return operation(operation(left, "is", right), "not");
        } else {
          return operation(left, operator, right);
        }
      }, head);
    }

    function toMap(nodes, getKey = node => node.id.name) {
      return new Map(nodes.map(node => [getKey(node), node]));
    }

    parser = new Parser(new Grammar([new Action(new Sequence(new Optional(new Reference("EOL")), new Repeat(new Reference("ModuleDeclaration")).setName("body"), new Reference("EOL"), new Reference("EOF")), function (__context, __values) {
      let body = __values[1];
      let location = getLocation();
      let id = node("Declarator", {
        name: location.filename
      });
      return node("Program", {
        sourceType: "module",
        id,
        body: body.flat()
      });
    }).setName("Module"), new Choice(new Reference("ImportDeclaration"), new Reference("Statement"), new Reference("ExportDeclaration")).setName("ModuleDeclaration"), new Choice(new Reference("ExportNamedDeclaration"), new Reference("ExportDefaultDeclaration")).setName("ExportDeclaration"), new Action(new Sequence(new Reference("ExportToken")), function (__context, __values) {
      ;
      return getLocation();
    }).setName("Export"), new Action(new Sequence(new Reference("DefaultToken")), function (__context, __values) {
      ;
      return getLocation();
    }).setName("Default"), new Action(new Sequence(new Reference("ExportToken"), new Reference("_"), new Choice(new Reference("Declaration"), new Reference("ImportDeclaration")).setName("declaration")), function (__context, __values) {
      let declaration = __values[2];
      return node(declaration.constructor.name, { ...declaration,
        location: getLocation(),
        export: 1
      });
    }).setName("ExportNamedDeclaration"), new Action(new Sequence(new Reference("ExportToken"), new Reference("_"), new Optional(new Reference("DefaultToken")).setName("isDefault"), new Reference("_"), new Choice(new Reference("ClassDeclaration"), new Reference("OutlineExpression")).setName("value")), function (__context, __values) {
      let isDefault = __values[2];
      let value = __values[4];

      if (ast.ClassDeclaration.is(value)) {
        return node(value.constructor.name, { ...value,
          export: isDefault ? 2 : 1
        });
      } // we NEED to have some Declarator for this default export.


      return node("VariableDeclaration", {
        kind: "let",
        id: node("Declarator", {
          name: "default"
        }),
        value,
        export: isDefault ? 2 : 1
      });
    }).setName("ExportDefaultDeclaration"), new Action(new Sequence(new Reference("ImportToken"), new Reference("_"), new Choice(new Reference("StringLiteral"), new Reference("Path")).setName("source"), new Reference("_"), new Choice(new Reference("InlineSpecifiers"), new Reference("OutlineSpecifiers")).setName("specifiers")), function (__context, __values) {
      let source = __values[2];
      let specifiers = __values[4];

      if (Array.isArray(source)
      /* is Path */
      ) {
          if (specifiers.length === 0) {
            // smart import
            let local = source[source.length - 1];
            let type = isTypeName(local.name) ? "ImportDefaultSpecifier" : "ImportNamespaceSpecifier";
            specifiers.push(node(type, {
              local
            }));
          }

          let path = source.map(id => id.name || id).join(pathSeparator);
          source = node("Literal", {
            value: path
          });
        }

      return node("ImportDeclaration", {
        specifiers,
        source
      });
    }).setName("ImportDeclaration"), new Action(new Sequence(new Reference("Specifier").setName("head"), new Repeat(new Action(new Sequence(new Reference("_"), new Terminal(","), new Reference("_"), new Reference("Specifier").setName("value")), function (__context, __values) {
      let value = __values[3];
      return value;
    })).setName("tail"), new Reference("EOL")), function (__context, __values) {
      let head = __values[0];
      let tail = __values[1];
      return [head, ...tail];
    }).setName("InlineSpecifiers"), new Action(new Sequence(new Reference("EOL"), new Reference("Indent"), new Repeat(new Action(new Sequence(new Reference("Dent"), new Reference("Specifier").setName("value"), new Reference("EOL")), function (__context, __values) {
      let value = __values[1];
      return value;
    })).setName("value"), new Reference("Outdent")), function (__context, __values) {
      let value = __values[2];
      return value;
    }).setName("OutlineSpecifiers"), new Action(new Sequence(new Repeat(new Terminal(".")).setName("relative"), new Reference("Identifier").setName("head"), new Repeat(new Action(new Sequence(new Reference("_"), new Terminal("."), new Reference("_"), new Reference("Identifier").setName("value")), function (__context, __values) {
      let value = __values[3];
      return value;
    })).setName("tail")), function (__context, __values) {
      let relative = __values[0];
      let head = __values[1];
      let tail = __values[2];
      return [...getRelativePrefixSteps(relative.length), head, ...tail];
    }).setName("Path"), new Choice(new Reference("ImportDefaultSpecifier"), new Reference("ImportNamespaceSpecifier"), new Reference("ImportSpecifier")).setName("Specifier"), new Action(new Sequence(new Reference("Identifier").setName("imported"), new Optional(new Action(new Sequence(new Reference("_"), new Reference("AsToken"), new Reference("_"), new Reference("Declarator").setName("value")), function (__context, __values) {
      let value = __values[3];
      return value;
    })).setName("local")), function (__context, __values) {
      let imported = __values[0];
      let local = __values[1];
      return node("ImportSpecifier", {
        imported,
        local: local || node("Declarator", imported)
      });
    }).setName("ImportSpecifier"), new Choice(new Action(new Sequence(new Reference("DefaultToken"), new Reference("_"), new Reference("AsToken"), new Reference("_"), new Reference("Declarator").setName("local")), function (__context, __values) {
      let local = __values[4];
      return node("ImportDefaultSpecifier", {
        local
      });
    }), new Action(new Sequence(new Terminal("as"), new Reference("_"), new Reference("Declarator").setName("local")), function (__context, __values) {
      let local = __values[2];
      return node("ImportDefaultSpecifier", {
        local
      });
    })).setName("ImportDefaultSpecifier"), new Action(new Sequence(new Terminal("*"), new Reference("_"), new Terminal("as"), new Reference("_"), new Reference("Declarator").setName("local")), function (__context, __values) {
      let local = __values[4];
      return node("ImportNamespaceSpecifier", {
        local
      });
    }).setName("ImportNamespaceSpecifier"), new Choice(new Reference("Declaration"), new Reference("AssignmentStatement"), new Reference("IfStatement"), new Reference("ForOfStatement"), new Reference("ReturnStatement"), new Reference("WhileStatement"), new Reference("BreakStatement"), new Reference("ContinueStatement"), new Reference("ExpressionStatement"), new Reference("ThrowStatement"), new Reference("TryStatement"), new Reference("SwitchStatement"), new Reference("PropertyStatement")).setName("Statement"), new Action(new Sequence(new Reference("SwitchToken"), new Reference("_"), new Reference("InlineExpression").setName("discriminant"), new Reference("EOL"), new Reference("Indent"), new Repeat(new Action(new Sequence(new Reference("Dent"), new Reference("SwitchCase").setName("value")), function (__context, __values) {
      let value = __values[1];
      return value;
    }), 1).setName("cases"), new Reference("Outdent")), function (__context, __values) {
      let discriminant = __values[2];
      let cases = __values[5];
      return node("SwitchStatement", {
        discriminant,
        cases: cases.flat()
      });
    }).setName("SwitchStatement"), new Choice(new Action(new Sequence(new Reference("DefaultToken")), function (__context, __values) {
      ;
      return null;
    }), new Reference("InlineExpression")).setName("SwitchTest"), new Action(new Sequence(new Reference("SwitchTest").setName("head"), new Repeat(new Action(new Sequence(new Reference("_"), new Terminal(","), new Reference("_"), new Reference("SwitchTest").setName("value")), function (__context, __values) {
      let value = __values[3];
      return value;
    })).setName("tail"), new Terminal(":"), new Reference("_"), new Choice(new Action(new Sequence(new Reference("Statement").setName("value")), function (__context, __values) {
      let value = __values[0];
      return node("BlockStatement", {
        body: Array.isArray(value) ? value : [value]
      });
    }), new Reference("BlockStatement")).setName("consequent")), function (__context, __values) {
      let head = __values[0];
      let tail = __values[1];
      let consequent = __values[4];
      let tests = [head, ...tail];
      return tests.map((test, index) => node("SwitchCase", {
        test,
        consequent: index === tests.length - 1 ? consequent : null
      }));
    }).setName("SwitchCase"), new Action(new Sequence(new Reference("TryToken"), new Reference("BlockStatement").setName("block"), new Optional(new Action(new Sequence(new Reference("Dent"), new Reference("CatchClause").setName("value")), function (__context, __values) {
      let value = __values[1];
      return value;
    })).setName("handler"), new Optional(new Action(new Sequence(new Reference("Dent"), new Reference("FinallyToken"), new Reference("BlockStatement").setName("value")), function (__context, __values) {
      let value = __values[2];
      return value;
    })).setName("finalizer")), function (__context, __values) {
      let block = __values[1];
      let handler = __values[2];
      let finalizer = __values[3];
      return node("TryStatement", {
        block,
        handler,
        finalizer
      });
    }).setName("TryStatement"), new Action(new Sequence(new Reference("CatchToken"), new Reference("_"), new Reference("Pattern").setName("param"), new Reference("_"), new Reference("BlockStatement").setName("body")), function (__context, __values) {
      let param = __values[2];
      let body = __values[4];
      return node("CatchClause", {
        param,
        body
      });
    }).setName("CatchClause"), new Action(new Sequence(new Reference("ThrowToken"), new Reference("_"), new Reference("OutlineExpression").setName("arg")), function (__context, __values) {
      let arg = __values[2];
      return node("ThrowStatement", {
        argument: arg
      });
    }).setName("ThrowStatement"), new Action(new Sequence(new Reference("OutlineExpression").setName("expression")), function (__context, __values) {
      let expression = __values[0];
      return node("ExpressionStatement", {
        expression
      });
    }).setName("ExpressionStatement"), new Choice(new Reference("ClassDeclaration"), new Reference("VariableDeclaration")).setName("Declaration"), new Choice(new Action(new Sequence(new Reference("VarToken")), function (__context, __values) {
      ;
      return {
        kind: "var"
      };
    }), new Action(new Sequence(new Reference("LetToken")), function (__context, __values) {
      ;
      return {
        kind: "let"
      };
    }), new Action(new Sequence(new Reference("GetToken")), function (__context, __values) {
      ;
      return {
        kind: "get"
      };
    }), new Action(new Sequence(new Reference("SetToken")), function (__context, __values) {
      ;
      return {
        kind: "set"
      };
    })).setName("VariableDeclarationType"), new Choice(new Action(new Sequence(new NotPredicate(new NotPredicate(new Reference("StaticToken"))), new Reference("Identifier").setName("id"), new Reference("_")), function (__context, __values) {
      let id = __values[1];
      return {
        static: id
      };
    }), new Action(new Sequence(new NotPredicate(new NotPredicate(new Any()))), function (__context, __values) {
      ;
      return {};
    })).setName("VariableModifiers"), new Choice(new Action(new Sequence(new Reference("VariableModifiers").setName("modifiers"), new Reference("TypeToken"), new Reference("_"), new Reference("Declarator").setName("id"), new Reference("_"), new Terminal("="), new Reference("_"), new Reference("Type").setName("value"), new Reference("EOL")), function (__context, __values) {
      let modifiers = __values[0];
      let id = __values[3];
      let value = __values[7];
      return node("VariableDeclaration", {
        kind: "type",
        id,
        value,
        ...modifiers
      });
    }), new Action(new Sequence(new Reference("MetaProperties").setName("meta"), new Reference("VariableModifiers").setName("modifiers"), new Reference("VariableDeclarationType").setName("declarationType"), new Reference("_"), new Choice(new Reference("Pattern"), new Action(new Sequence(new Terminal("["), new Reference("_"), new Reference("InlineExpression").setName("value"), new Reference("_"), new Terminal("]")), function (__context, __values) {
      let value = __values[2];
      return value;
    })).setName("id"), new Reference("_"), new Optional(new Action(new Sequence(new Terminal(":"), new Reference("_"), new Reference("Type").setName("value")), function (__context, __values) {
      let value = __values[2];
      return value;
    })).setName("type"), new Reference("_"), new Optional(new Choice(new Action(new Sequence(new Terminal("="), new Reference("_"), new Reference("OutlineExpression").setName("value")), function (__context, __values) {
      let value = __values[2];
      return value;
    }), new Action(new Sequence(new Reference("EOL")), function (__context, __values) {
      ;
      return null;
    }))).setName("value")), function (__context, __values) {
      let meta = __values[0];
      let modifiers = __values[1];
      let declarationType = __values[2];
      let id = __values[4];
      let type = __values[6];
      let value = __values[8];
      return node("VariableDeclaration", { ...declarationType,
        id,
        type,
        value,
        meta,
        ...modifiers
      });
    })).setName("VariableDeclaration"), new Repeat(new Action(new Sequence(new Reference("DynamicOutlineProperty").setName("value"), new Reference("Dent")), function (__context, __values) {
      let value = __values[0];
      return value;
    })).setName("MetaProperties"), new Action(new Sequence(new Terminal("["), new Reference("_"), new Reference("InlineExpression").setName("key"), new Reference("_"), new Terminal("]"), new Choice(new Action(new Sequence(new Reference("_"), new Terminal(":"), new Reference("_"), new Reference("OutlineExpression").setName("value")), function (__context, __values) {
      let value = __values[3];
      return value;
    }), new Action(new Sequence(new Reference("EOL")), function (__context, __values) {
      ;
      return null;
    })).setName("value")), function (__context, __values) {
      let key = __values[2];
      let value = __values[5];
      return node("KeyValuePair", {
        key,
        value,
        computed: true
      });
    }).setName("DynamicOutlineProperty"), new Choice(new Terminal("="), new Terminal("+="), new Terminal("-="), new Terminal("*="), new Terminal("/=")).setName("AssignmentOperator"), new Action(new Sequence(new Reference("InlineExpression").setName("left"), new Reference("_"), new Reference("AssignmentOperator").setName("operator"), new Reference("_"), new Reference("OutlineExpression").setName("right")), function (__context, __values) {
      let left = __values[0];
      let operator = __values[2];
      let right = __values[4];

      if (operator.length > 1) {
        right = operation(left, node("Identifier", {
          name: operator.slice(0, -1)
        }), right);
      }

      return node("AssignmentStatement", {
        left,
        operator,
        right
      });
    }).setName("AssignmentStatement"), new Action(new Sequence(new Reference("EOL"), new Reference("Indent"), new Repeat(new Action(new Sequence(new Reference("Dent"), new Reference("Statement").setName("value")), function (__context, __values) {
      let value = __values[1];
      return value;
    }), 1).setName("body"), new Reference("Outdent")), function (__context, __values) {
      let body = __values[2];
      return node("BlockStatement", {
        body: body.flat()
      });
    }).setName("BlockStatement"), new Action(new Sequence(new Reference("ForToken"), new Reference("_"), new Reference("Pattern").setName("left"), new Reference("_"), new Reference("InToken"), new Reference("_"), new Reference("InlineExpression").setName("right"), new Reference("BlockStatement").setName("body")), function (__context, __values) {
      let left = __values[2];
      let right = __values[6];
      let body = __values[7];
      return node("ForOfStatement", {
        left: node("VariableDeclaration", {
          id: left,
          kind: "const"
        }),
        right,
        body
      });
    }).setName("ForOfStatement"), new Action(new Sequence(new Reference("WhileToken"), new Reference("_"), new Reference("InlineExpression").setName("test"), new Reference("BlockStatement").setName("body")), function (__context, __values) {
      let test = __values[2];
      let body = __values[3];
      return node("WhileStatement", {
        test,
        body
      });
    }).setName("WhileStatement"), new Action(new Sequence(new Reference("IfToken"), new Reference("_"), new Reference("InlineExpression").setName("test"), new Reference("BlockStatement").setName("consequent"), new Optional(new Action(new Sequence(new Reference("Dent"), new Reference("ElseToken"), new Reference("_"), new Choice(new Reference("BlockStatement"), new Reference("IfStatement")).setName("value")), function (__context, __values) {
      let value = __values[3];
      return value;
    })).setName("alternate")), function (__context, __values) {
      let test = __values[2];
      let consequent = __values[3];
      let alternate = __values[4];
      return node("IfStatement", {
        test,
        consequent,
        alternate
      });
    }).setName("IfStatement"), new Choice(new Action(new Sequence(new Reference("ReturnToken"), new Reference("EOL"), new Reference("Indent"), new Reference("Dent"), new Reference("OutlineExpression").setName("argument"), new Reference("Outdent")), function (__context, __values) {
      let argument = __values[4];
      return node("ReturnStatement", {
        argument
      });
    }), new Action(new Sequence(new Reference("ReturnToken"), new Reference("_"), new Reference("InlineExpression").setName("argument"), new Optional(new Reference("EOL"))), function (__context, __values) {
      let argument = __values[2];
      return node("ReturnStatement", {
        argument
      });
    })).setName("ReturnStatement"), new Action(new Sequence(new Reference("BreakToken"), new Reference("EOL")), function (__context, __values) {
      ;
      return node("BreakStatement", {});
    }).setName("BreakStatement"), new Action(new Sequence(new Reference("ContinueToken"), new Reference("EOL")), function (__context, __values) {
      ;
      return node("ContinueStatement", {});
    }).setName("ContinueStatement"), new Choice(new Reference("Declarator"), new Reference("ArrayPattern"), new Reference("ObjectPattern"), new Reference("RestElement")).setName("Pattern"), new Choice(new Action(new Sequence(new Terminal("["), new Reference("_"), new Reference("RestElement").setName("element"), new Reference("_"), new Terminal("]")), function (__context, __values) {
      let element = __values[2];
      return node("ArrayPattern", {
        elements: [element]
      });
    }), new Action(new Sequence(new Terminal("["), new Reference("_"), new Optional(new Reference("Pattern")).setName("head"), new Repeat(new Action(new Sequence(new Reference("_"), new Terminal(","), new Reference("_"), new NotPredicate(new Terminal(".")), new Optional(new Reference("Pattern")).setName("value")), function (__context, __values) {
      let value = __values[4];
      return value;
    })).setName("tail"), new Optional(new Action(new Sequence(new Reference("_"), new Terminal(","), new Reference("_"), new Reference("RestElement").setName("value")), function (__context, __values) {
      let value = __values[3];
      return value;
    })).setName("rest"), new Reference("_"), new Terminal("]")), function (__context, __values) {
      let head = __values[2];
      let tail = __values[3];
      let rest = __values[4];
      let elements = [head || null, ...tail.map(x => x || null)];

      if (rest) {
        elements.push(rest);
      }

      return node("ArrayPattern", {
        elements
      });
    })).setName("ArrayPattern"), new Action(new Sequence(new Terminal("..."), new Reference("Declarator").setName("argument")), function (__context, __values) {
      let argument = __values[1];
      return node("RestElement", {
        argument
      });
    }).setName("RestElement"), new Action(new Sequence(new Terminal("{"), new Reference("_"), new Reference("AssignmentProperty").setName("head"), new Repeat(new Action(new Sequence(new Reference("_"), new Terminal(","), new Reference("_"), new Reference("AssignmentProperty").setName("value")), function (__context, __values) {
      let value = __values[3];
      return value;
    })).setName("tail"), new Optional(new Action(new Sequence(new Reference("_"), new Terminal(","), new Reference("_"), new Reference("RestElement").setName("value")), function (__context, __values) {
      let value = __values[3];
      return value;
    })).setName("rest"), new Reference("_"), new Terminal("}")), function (__context, __values) {
      let head = __values[2];
      let tail = __values[3];
      let rest = __values[4];
      let properties = [head, ...tail];

      if (rest) {
        properties.push(rest);
      }

      return node("ObjectPattern", {
        properties
      });
    }).setName("ObjectPattern"), new Action(new Sequence(new Reference("Identifier").setName("key"), new Optional(new Action(new Sequence(new Reference("_"), new Terminal(":"), new Reference("_"), new Reference("Pattern").setName("value")), function (__context, __values) {
      let value = __values[3];
      return value;
    })).setName("value")), function (__context, __values) {
      let key = __values[0];
      let value = __values[1];
      return node("Property", {
        key,
        value: value || node("Reference", key),
        shorthand: value == null
      });
    }).setName("AssignmentProperty"), new Choice(new Action(new Sequence(new Reference("DataToken"), new Reference("_")), function (__context, __values) {
      ;
      return {
        isData: true
      };
    }), new Action(new Sequence(new NotPredicate(new NotPredicate(new Any()))), function (__context, __values) {
      ;
      return {};
    })).setName("ClassModifiers"), new Action(new Sequence(new Reference("MetaProperties").setName("meta"), new Reference("ClassModifiers").setName("modifiers"), new Choice(new Action(new Sequence(new Reference("ClassToken")), function (__context, __values) {
      ;
      return false;
    }), new Action(new Sequence(new Reference("StructToken")), function (__context, __values) {
      ;
      return true;
    })).setName("isStruct"), new Reference("_"), new Reference("Declarator").setName("id"), new Optional(new Reference("TemplateParameters")).setName("params"), new Reference("_"), new Optional(new Reference("Extends")).setName("baseClasses"), new Reference("EOL"), new Reference("Indent"), new Repeat(new Action(new Sequence(new Reference("Dent"), new Reference("VariableDeclaration").setName("value")), function (__context, __values) {
      let value = __values[1];
      return value;
    })).setName("declarations"), new Reference("Outdent")), function (__context, __values) {
      let meta = __values[0];
      let modifiers = __values[1];
      let isStruct = __values[2];
      let id = __values[4];
      let params = __values[5];
      let baseClasses = __values[7];
      let declarations = __values[10];
      return node("ClassDeclaration", {
        id,
        ...modifiers,
        isStruct,
        params: params || [],
        baseClasses: baseClasses || [],
        static: declarations.filter(d => d.static),
        instance: node("InstanceDeclarations", {
          declarations: declarations.filter(d => !d.static).map(d => d.patch({
            instance: true
          }))
        })
      });
    }).setName("ClassDeclaration"), new Action(new Sequence(new Terminal("<"), new Reference("_"), new Reference("Parameter").setName("head"), new Repeat(new Action(new Sequence(new Reference("_"), new Terminal(","), new Reference("_"), new Reference("Parameter").setName("value")), function (__context, __values) {
      let value = __values[3];
      return value;
    })).setName("tail"), new Reference("_"), new Terminal(">")), function (__context, __values) {
      let head = __values[2];
      let tail = __values[3];
      return [head, ...tail];
    }).setName("TemplateParameters"), new Action(new Sequence(new Reference("ExtendsToken"), new Reference("_"), new Reference("Reference").setName("head"), new Repeat(new Action(new Sequence(new Reference("_"), new Terminal(","), new Reference("_"), new Reference("Reference").setName("value")), function (__context, __values) {
      let value = __values[3];
      return value;
    })).setName("tail")), function (__context, __values) {
      let head = __values[2];
      let tail = __values[3];
      return [head, ...tail];
    }).setName("Extends"), new Choice(new Reference("TemplateReference"), new Action(new Sequence(new Reference("UnionType").setName("type")), function (__context, __values) {
      let type = __values[0];
      let isReference = ast.BinaryExpression.is(type) && type.operator === "is" && ast.Reference.is(type.right);
      return isReference ? type.right : node("TypeExpression", {
        value: type
      });
    })).setName("Type"), new Action(new Sequence(new Reference("ConstrainedType").setName("left"), new Optional(new Action(new Sequence(new Reference("_"), new Terminal("|"), new Reference("_"), new Reference("UnionType").setName("value")), function (__context, __values) {
      let value = __values[3];
      return value;
    })).setName("right")), function (__context, __values) {
      let left = __values[0];
      let right = __values[1];
      return right ? node('BinaryExpression', {
        left,
        operator: "||",
        right
      }) : left;
    }).setName("UnionType"), new Action(new Sequence(new Reference("Constraint").setName("left"), new Optional(new Action(new Sequence(new Reference("_"), new Terminal("&"), new Reference("_"), new Reference("ConstrainedType").setName("value")), function (__context, __values) {
      let value = __values[3];
      return value;
    })).setName("right")), function (__context, __values) {
      let left = __values[0];
      let right = __values[1];
      return right ? node('BinaryExpression', {
        left,
        operator: "&&",
        right
      }) : left;
    }).setName("ConstrainedType"), new Choice(new Action(new Sequence(new Reference("Literal").setName("right")), function (__context, __values) {
      let right = __values[0];
      return node('BinaryExpression', {
        left: node('DotExpression'),
        operator: ast.RegularExpression.is(right) ? 'is' : '==',
        right
      });
    }), new Action(new Sequence(new Optional(new Reference("MemberExpression")).setName("left"), new Reference("_"), new Choice(new Terminal(">="), new Terminal("<="), new Terminal(">"), new Terminal("<"), new Terminal("=="), new Terminal("!="), new Terminal("is")).setName("operator"), new Reference("_"), new Reference("MemberExpression").setName("right")), function (__context, __values) {
      let left = __values[0];
      let operator = __values[2];
      let right = __values[4];
      return node('BinaryExpression', {
        left: left || node('DotExpression'),
        operator,
        right
      });
    }), new Action(new Sequence(new Choice(new Reference("FunctionType"), new Reference("Reference")).setName("right")), function (__context, __values) {
      let right = __values[0];
      return node('BinaryExpression', {
        left: node('DotExpression'),
        operator: 'is',
        right
      });
    })).setName("Constraint"), new Choice(new Action(new Sequence(new Reference("FunctionParameters").setName("params"), new Reference("_"), new Terminal("=>"), new Reference("_"), new Reference("Type").setName("returnType")), function (__context, __values) {
      let params = __values[0];
      let returnType = __values[4];
      return node("FunctionType", {
        params,
        returnType
      });
    }), new Action(new Sequence(new Terminal("("), new Reference("_"), new Reference("FunctionType").setName("value"), new Reference("_"), new Terminal(")")), function (__context, __values) {
      let value = __values[2];
      return value;
    })).setName("FunctionType"), new Reference("Type").setName("TemplateArgument"), new Action(new Sequence(new Terminal("<"), new Reference("_"), new Reference("TemplateArgument").setName("head"), new Repeat(new Action(new Sequence(new Reference("_"), new Terminal(","), new Reference("_"), new Reference("TemplateArgument").setName("value")), function (__context, __values) {
      let value = __values[3];
      return value;
    })).setName("tail"), new Reference("_"), new Terminal(">")), function (__context, __values) {
      let head = __values[2];
      let tail = __values[3];
      return [head, ...tail];
    }).setName("TemplateArguments"), new Action(new Sequence(new Reference("Reference").setName("reference"), new Reference("TemplateArguments").setName("args")), function (__context, __values) {
      let reference = __values[0];
      let args = __values[1];
      return node("Reference", { ...reference,
        arguments: args
      });
    }).setName("TemplateReference"), new Choice(new Terminal("+"), new Terminal("-"), new Reference("NotToken"), new Terminal("!"), new Reference("TypeofToken")).setName("UnaryOperator"), new Choice(new Reference("MemberExpression"), new Action(new Sequence(new Reference("UnaryOperator").setName("operator"), new Reference("_"), new Reference("MemberExpression").setName("argument")), function (__context, __values) {
      let operator = __values[0];
      let argument = __values[2];
      return operation(argument, operator);
    })).setName("UnaryExpression"), new Choice(new Terminal("**"), new Terminal("<<"), new Terminal(">>")).setLabel("operator").setName("ExponentiationOperator"), new Action(new Sequence(new Reference("UnaryExpression").setName("left"), new Optional(new Action(new Sequence(new Reference("_"), new Reference("ExponentiationOperator").setName("operator"), new Reference("_"), new Reference("ExponentiationExpression").setName("right")), function (__context, __values) {
      let operator = __values[1];
      let right = __values[3];
      return {
        operator,
        right
      };
    })).setName("right")), function (__context, __values) {
      let left = __values[0];
      let right = __values[1];
      return right ? node("BinaryExpression", {
        left,
        operator: right.operator,
        right: right.right
      }) : left;
    }).setName("ExponentiationExpression"), new Choice(new Terminal("*"), new Terminal("/"), new Terminal("%")).setName("MultiplicativeOperator"), new Action(new Sequence(new Reference("ExponentiationExpression").setName("head"), new Repeat(new Group(new Sequence(new Reference("_"), new Reference("MultiplicativeOperator"), new Reference("_"), new Reference("ExponentiationExpression")))).setName("tail")), function (__context, __values) {
      let head = __values[0];
      let tail = __values[1];
      return buildBinaryExpression(head, tail);
    }).setName("MultiplicativeExpression"), new Choice(new Terminal("+"), new Terminal("-")).setName("AdditiveOperator"), new Action(new Sequence(new Reference("MultiplicativeExpression").setName("head"), new Repeat(new Group(new Sequence(new Reference("_"), new Reference("AdditiveOperator"), new Reference("_"), new Reference("MultiplicativeExpression")))).setName("tail")), function (__context, __values) {
      let head = __values[0];
      let tail = __values[1];
      return buildBinaryExpression(head, tail);
    }).setName("AdditiveExpression"), new Choice(new Terminal("<="), new Terminal(">="), new Terminal("<"), new Terminal(">"), new Reference("IsToken"), new Reference("IsntToken")).setName("RelationalOperator"), new Choice(new Action(new Sequence(new Reference("AdditiveExpression").setName("head"), new Repeat(new Group(new Sequence(new Reference("_"), new Reference("RelationalOperator"), new Reference("_"), new Reference("AdditiveExpression")))).setName("tail")), function (__context, __values) {
      let head = __values[0];
      let tail = __values[1];
      return buildBinaryExpression(head, tail);
    }), new Action(new Sequence(new Group(new Sequence(new Reference("_"), new Reference("RelationalOperator"), new Reference("_"), new Reference("AdditiveExpression"))).setName("tail")), function (__context, __values) {
      let tail = __values[0];
      return buildBinaryExpression(node('DotExpression'), [tail]);
    })).setName("RelationalExpression"), new Choice(new Terminal("=="), new Terminal("!=")).setName("EqualityOperator"), new Action(new Sequence(new Reference("RelationalExpression").setName("head"), new Repeat(new Group(new Sequence(new Reference("_"), new Reference("EqualityOperator"), new Reference("_"), new Reference("RelationalExpression")))).setName("tail")), function (__context, __values) {
      let head = __values[0];
      let tail = __values[1];
      return buildBinaryExpression(head, tail);
    }).setName("EqualityExpression"), new Terminal("&&").setName("LogicalAndOperator"), new Action(new Sequence(new Reference("EqualityExpression").setName("head"), new Repeat(new Group(new Sequence(new Reference("_"), new Reference("LogicalAndOperator"), new Reference("_"), new Reference("EqualityExpression")))).setName("tail")), function (__context, __values) {
      let head = __values[0];
      let tail = __values[1];
      return buildBinaryExpression(head, tail);
    }).setName("LogicalAndExpression"), new Choice(new Terminal("||"), new Reference("XorToken")).setName("LogicalOrOperator"), new Action(new Sequence(new Reference("LogicalAndExpression").setName("head"), new Repeat(new Group(new Sequence(new Reference("_"), new Reference("LogicalOrOperator"), new Reference("_"), new Reference("LogicalAndExpression")))).setName("tail")), function (__context, __values) {
      let head = __values[0];
      let tail = __values[1];
      return buildBinaryExpression(head, tail);
    }).setName("LogicalOrExpression"), new Terminal("?").setName("ConditionalOperator"), new Action(new Sequence(new Reference("LogicalOrExpression").setName("test"), new Optional(new Action(new Sequence(new Reference("_"), new Reference("ConditionalOperator"), new Reference("_"), new Reference("ConditionalExpression").setName("consequent"), new Reference("_"), new Terminal(":"), new Reference("_"), new Reference("ConditionalExpression").setName("alternate")), function (__context, __values) {
      let consequent = __values[3];
      let alternate = __values[7];
      return {
        consequent,
        alternate
      };
    })).setName("body")), function (__context, __values) {
      let test = __values[0];
      let body = __values[1];
      return body ? node('ConditionalExpression', {
        test,
        ...body
      }) : test;
    }).setName("ConditionalExpression"), new Action(new Sequence(new Reference("Pattern").setName("id"), new Reference("_"), new Optional(new Action(new Sequence(new Terminal(":"), new Reference("_"), new Reference("Type").setName("value")), function (__context, __values) {
      let value = __values[2];
      return value;
    })).setName("type"), new Reference("_"), new Optional(new Action(new Sequence(new Terminal("="), new NotPredicate(new Terminal(">")), new Reference("_"), new Reference("InlineExpression").setName("value")), function (__context, __values) {
      let value = __values[3];
      return value;
    })).setName("value")), function (__context, __values) {
      let id = __values[0];
      let type = __values[2];
      let value = __values[4];
      return node("Parameter", {
        id,
        type,
        value
      });
    }).setName("Parameter"), new Choice(new Action(new Sequence(new Terminal("("), new Reference("_"), new Terminal(")")), function (__context, __values) {
      ;
      return [];
    }), new Action(new Sequence(new Reference("Declarator").setName("id")), function (__context, __values) {
      let id = __values[0];
      return [node("Parameter", {
        id
      })];
    }), new Action(new Sequence(new Terminal("("), new Reference("_"), new Reference("Parameter").setName("head"), new Repeat(new Action(new Sequence(new Reference("_"), new Terminal(","), new Reference("_"), new Reference("Parameter").setName("value")), function (__context, __values) {
      let value = __values[3];
      return value;
    })).setName("tail"), new Reference("_"), new Terminal(")")), function (__context, __values) {
      let head = __values[2];
      let tail = __values[3];
      return [head, ...tail];
    })).setName("FunctionParameters"), new Action(new Sequence(new Optional(new Reference("AsyncToken")).setName("async"), new Reference("_"), new Optional(new Terminal("*")).setName("generator"), new Optional(new Action(new Sequence(new Reference("Identifier").setName("value"), new NotPredicate(new NotPredicate(new Terminal("(")))), function (__context, __values) {
      let value = __values[0];
      return value;
    })).setName("id"), new Optional(new Reference("FunctionParameters")).setName("params"), new Optional(new Action(new Sequence(new Reference("_"), new Terminal(":"), new Reference("_"), new Reference("Type").setName("value")), function (__context, __values) {
      let value = __values[3];
      return value;
    })).setName("type"), new Reference("_"), new Terminal("=>")), function (__context, __values) {
      let async = __values[0];
      let generator = __values[2];
      let id = __values[3];
      let params = __values[4];
      let type = __values[5];
      return {
        id,
        type,
        async: async != null,
        generator: generator != null,
        params: params || []
      };
    }).setName("FunctionHead"), new Action(new Sequence(new Reference("FunctionHead").setName("head"), new Reference("_"), new Optional(new Reference("InlineExpression")).setName("value")), function (__context, __values) {
      let head = __values[0];
      let value = __values[2];
      return node("FunctionExpression", { ...head,
        body: node("BlockStatement", {
          body: !value ? [] : [node("ReturnStatement", {
            argument: value
          })]
        })
      });
    }).setName("InlineFunction"), new Action(new Sequence(new NotPredicate(new NotPredicate(new Reference("Identifier"))), new Reference("InlineFunction").setName("value")), function (__context, __values) {
      let value = __values[1];
      return value;
    }).setName("NamedInlineFunction"), new Action(new Sequence(new Reference("FunctionHead").setName("head"), new Reference("_"), new Reference("BlockStatement").setName("body")), function (__context, __values) {
      let head = __values[0];
      let body = __values[2];
      return node("FunctionExpression", { ...head,
        body
      });
    }).setName("OutlineFunction"), new Action(new Sequence(new NotPredicate(new NotPredicate(new Reference("Identifier"))), new Reference("OutlineFunction").setName("value")), function (__context, __values) {
      let value = __values[1];
      return value;
    }).setName("NamedOutlineFunction"), new Choice(new Reference("OutlineExpressionStartsThisLine"), new Action(new Sequence(new Reference("EOL"), new Reference("Indent"), new Reference("Dent"), new Reference("OutlineExpressionStartsThisLine").setName("value"), new Reference("Outdent")), function (__context, __values) {
      let value = __values[3];
      return value;
    })).setName("OutlineExpression"), new Choice(new Reference("OutlineYieldExpression"), new Reference("OutlineAwaitExpression"), new Reference("OutlineDoExpression"), new Reference("OutlineFunction"), new Reference("OutlineArrayExpression"), new Reference("OutlineObjectExpression"), new Reference("OutlineJSXElementExpression"), new Reference("OutlineCallExpression"), new Reference("OutlineNewExpression"), new Reference("OutlineStringLiteral"), new Reference("OutlineSpreadElement"), new Reference("OutlineOperation"), new Action(new Sequence(new Reference("InlineExpression").setName("value"), new Reference("EOL")), function (__context, __values) {
      let value = __values[0];
      return value;
    })).setName("OutlineExpressionStartsThisLine"), new Action(new Sequence(new Reference("DoToken"), new Terminal(" "), new Reference("_"), new Reference("OutlineFunction").setName("callee")), function (__context, __values) {
      let callee = __values[3];
      return node("CallExpression", {
        callee,
        arguments: []
      });
    }).setName("OutlineDoExpression"), new Action(new Sequence(new Choice(new Terminal("+"), new Terminal("-"), new Terminal("||"), new Terminal("&&"), new Terminal("|"), new Terminal("&"), new Terminal("**"), new Terminal("*"), new Terminal("/")).setName("operator"), new Reference("OutlineArguments").setName("operands")), function (__context, __values) {
      let operator = __values[0];
      let operands = __values[1];

      if (operands.length === 2 && operands.every(ast.Expression.is)) {
        return node("BinaryExpression", {
          left: operands[0],
          operator,
          right: operands[1]
        });
      }

      return node("OutlineOperation", {
        operator,
        operands
      });
    }).setName("OutlineOperation"), new Action(new Sequence(new Reference("YieldToken"), new Optional(new Terminal("*")).setName("delegate"), new Reference("_"), new Reference("OutlineExpression").setName("argument")), function (__context, __values) {
      let delegate = __values[1];
      let argument = __values[3];
      return node("YieldExpression", {
        argument,
        delegate: delegate != null
      });
    }).setName("OutlineYieldExpression"), new Action(new Sequence(new Reference("AwaitToken"), new Reference("_"), new Reference("OutlineExpression").setName("argument")), function (__context, __values) {
      let argument = __values[2];
      return node("AwaitExpression", {
        argument
      });
    }).setName("OutlineAwaitExpression"), new Action(new Sequence(new Reference("EOL"), new Reference("Indent"), new Repeat(new Action(new Sequence(new Reference("Dent"), new Choice(new Reference("OutlineExpression"), new Reference("Statement")).setName("value")), function (__context, __values) {
      let value = __values[1];
      return value;
    }), 1).setName("args"), new Reference("Outdent")), function (__context, __values) {
      let args = __values[2];
      return args.flat();
    }).setName("OutlineArguments"), new Action(new Sequence(new Reference("InlineExpression").setName("call"), new Reference("OutlineArguments").setName("args"), new CustomPredicate('').setHandler(function (__context, __values) {
      let call = __values[0];
      let args = __values[1];
      return ast.CallExpression.is(call);
    })), function (__context, __values) {
      let call = __values[0];
      let args = __values[1];
      return node("CallExpression", { ...call,
        arguments: [...call.arguments, ...args]
      });
    }).setName("OutlineCallExpression"), new Action(new Sequence(new Reference("NewToken"), new Reference("_"), new Reference("MemberExpressionNoCall").setName("callee"), new Choice(new Action(new Sequence(new Reference("InlineArguments").setName("value"), new Reference("EOL")), function (__context, __values) {
      let value = __values[0];
      return value;
    }), new Reference("OutlineArguments")).setName("args")), function (__context, __values) {
      let callee = __values[2];
      let args = __values[3];
      return node("CallExpression", {
        new: true,
        callee,
        arguments: args
      });
    }).setName("OutlineNewExpression"), new Choice(new Reference("InlineSpreadElement"), new Reference("InlineYieldExpression"), new Reference("InlineAwaitExpression"), new Reference("InlineFunction"), new Reference("InlineNewExpression"), new Reference("ConditionalExpression")).setName("InlineExpression"), new Action(new Sequence(new Reference("AwaitToken"), new Reference("_"), new Reference("InlineExpression").setName("argument")), function (__context, __values) {
      let argument = __values[2];
      return node("AwaitExpression", {
        argument
      });
    }).setName("InlineAwaitExpression"), new Action(new Sequence(new Reference("YieldToken"), new Optional(new Terminal("*")).setName("delegate"), new Reference("_"), new Reference("InlineExpression").setName("argument")), function (__context, __values) {
      let delegate = __values[1];
      let argument = __values[3];
      return node("YieldExpression", {
        argument,
        delegate: delegate != null
      });
    }).setName("InlineYieldExpression"), new Action(new Sequence(new Reference("NewToken"), new Reference("_"), new Reference("MemberExpressionNoCall").setName("callee"), new Reference("InlineArguments").setName("args")), function (__context, __values) {
      let callee = __values[2];
      let args = __values[3];
      return node("CallExpression", {
        new: true,
        callee,
        arguments: args
      });
    }).setName("InlineNewExpression"), new Choice(new Reference("Reference"), new Reference("Literal"), new Reference("ThisExpression"), new Reference("DotExpression"), new Reference("GroupExpression"), new Reference("InlineArrayExpression"), new Reference("InlineObjectExpression"), new Reference("InlineJSXElementExpression")).setName("PrimaryExpression"), new Action(new Sequence(new Terminal("("), new Reference("_"), new Reference("InlineExpression").setName("value"), new Reference("_"), new Terminal(")")), function (__context, __values) {
      let value = __values[2];
      return value;
    }).setName("GroupExpression"), new Action(new Sequence(new Reference("ThisToken")), function (__context, __values) {
      ;
      return node('ThisExpression');
    }).setName("ThisExpression"), new Choice(new Action(new Sequence(new Terminal("."), new Reference("Identifier").setName("property")), function (__context, __values) {
      let property = __values[1];
      return node('MemberExpression', {
        object: node('DotExpression'),
        property,
        computed: false
      });
    }), new Action(new Sequence(new Terminal(".["), new Reference("_"), new Reference("InlineExpression").setName("property"), new Reference("_"), new Terminal("]")), function (__context, __values) {
      let property = __values[2];
      return node('MemberExpression', {
        object: node('DotExpression'),
        property,
        computed: true
      });
    }), new Action(new Sequence(new Terminal(".")), function (__context, __values) {
      ;
      return node('DotExpression');
    })).setName("DotExpression"), new Action(new Sequence(new Reference("InlineExpression").setName("head"), new Repeat(new Action(new Sequence(new Reference("_"), new Terminal(","), new Reference("_"), new Reference("InlineExpression").setName("value")), function (__context, __values) {
      let value = __values[3];
      return value;
    })).setName("tail")), function (__context, __values) {
      let head = __values[0];
      let tail = __values[1];
      return [head, ...tail];
    }).setName("InlineExpressionList"), new Choice(new Action(new Sequence(new Terminal("()")), function (__context, __values) {
      ;
      return [];
    }), new Action(new Sequence(new Terminal("("), new Reference("_"), new Reference("InlineExpressionList").setName("value"), new Reference("_"), new Terminal(")")), function (__context, __values) {
      let value = __values[2];
      return value;
    })).setName("InlineArguments"), new Action(new Sequence(new Optional(new Terminal("?")).setName("optional"), new Terminal("["), new Reference("_"), new Reference("InlineExpression").setName("property"), new Reference("_"), new Terminal("]")), function (__context, __values) {
      let optional = __values[0];
      let property = __values[3];
      return {
        property,
        computed: true,
        optional: optional != null
      };
    }).setName("ChainMemberComputed"), new Action(new Sequence(new Optional(new Terminal("?")).setName("optional"), new Reference("_"), new Terminal("."), new Reference("Identifier").setName("property")), function (__context, __values) {
      let optional = __values[0];
      let property = __values[3];
      return {
        property,
        computed: false,
        optional: optional != null
      };
    }).setName("ChainMember"), new Action(new Sequence(new Optional(new Terminal("?")).setName("optional"), new Reference("InlineArguments").setName("args")), function (__context, __values) {
      let optional = __values[0];
      let args = __values[1];
      return {
        arguments: args,
        optional: optional != null
      };
    }).setName("ChainMemberCall"), new Action(new Sequence(new Reference("PrimaryExpression").setName("head"), new Repeat(new Choice(new Reference("ChainMemberComputed"), new Reference("ChainMember"), new Reference("ChainMemberCall"))).setName("tail")), function (__context, __values) {
      let head = __values[0];
      let tail = __values[1];
      return tail.reduce((left, right) => {
        if (right.arguments) {
          return node("CallExpression", {
            callee: left,
            ...right
          });
        } else {
          return node("MemberExpression", {
            object: left,
            ...right
          });
        }
      }, head);
    }).setName("MemberExpression"), new Action(new Sequence(new Reference("PrimaryExpression").setName("head"), new Repeat(new Choice(new Reference("ChainMemberComputed"), new Reference("ChainMember"))).setName("tail")), function (__context, __values) {
      let head = __values[0];
      let tail = __values[1];
      return tail.reduce((left, right) => node("MemberExpression", {
        object: left,
        ...right
      }), head);
    }).setName("MemberExpressionNoCall"), new Action(new Sequence(new Terminal("..."), new Reference("InlineExpression").setName("argument")), function (__context, __values) {
      let argument = __values[1];
      return node("SpreadElement", {
        argument
      });
    }).setName("InlineSpreadElement"), new Action(new Sequence(new Terminal("..."), new Reference("OutlineExpression").setName("argument")), function (__context, __values) {
      let argument = __values[1];
      return node("SpreadElement", {
        argument
      });
    }).setName("OutlineSpreadElement"), new Choice(new Reference("InlineSpreadElement"), new Reference("InlineExpression")).setName("ArrayElement"), new Action(new Sequence(new Reference("ArrayElement").setName("head"), new Repeat(new Action(new Sequence(new Reference("_"), new Terminal(","), new Reference("_"), new Reference("ArrayElement").setName("value")), function (__context, __values) {
      let value = __values[3];
      return value;
    })).setName("tail")), function (__context, __values) {
      let head = __values[0];
      let tail = __values[1];
      return [head, ...tail];
    }).setName("ArrayElements"), new Choice(new Action(new Sequence(new Terminal("["), new Reference("_"), new Optional(new Reference("ArrayElements")).setName("elements"), new Reference("_"), new Terminal("]")), function (__context, __values) {
      let elements = __values[2];
      return node("ArrayExpression", {
        elements: elements || []
      });
    }), new Action(new Sequence(new Terminal("|"), new Reference("_"), new Optional(new Reference("ArrayElements")).setName("elements"), new Reference("_"), new Terminal("|")), function (__context, __values) {
      let elements = __values[2];
      return node("ArrayExpression", {
        elements: elements || [],
        isSet: true
      });
    })).setName("InlineArrayExpression"), new Action(new Sequence(new Reference("Reference").setName("object"), new Optional(new Action(new Sequence(new Terminal("."), new Reference("Identifier").setName("value")), function (__context, __values) {
      let value = __values[1];
      return value;
    })).setName("property")), function (__context, __values) {
      let object = __values[0];
      let property = __values[1];
      return property ? node("MemberExpression", {
        object,
        property
      }) : object;
    }).setName("JSXName"), new Reference("JSXName").setName("JSXAttributeName"), new Reference("JSXName").setName("JSXElementName"), new Action(new Sequence(new Reference("JSXAttributeName").setName("key"), new Optional(new Reference("JSXAttributeInitializer")).setName("value")), function (__context, __values) {
      let key = __values[0];
      let value = __values[1];
      return node("Property", {
        key,
        value: value || node("Literal", {
          value: true
        })
      });
    }).setName("JSXAttribute"), new Action(new Sequence(new Terminal("="), new Reference("_"), new Reference("JSXAttributeValue").setName("value")), function (__context, __values) {
      let value = __values[2];
      return value;
    }).setName("JSXAttributeInitializer"), new Choice(new Reference("StringLiteral"), new Action(new Sequence(new Terminal("{"), new Reference("_"), new Reference("InlineExpression").setName("value"), new Reference("_"), new Terminal("}")), function (__context, __values) {
      let value = __values[2];
      return value;
    })).setName("JSXAttributeValue"), new Action(new Sequence(new Terminal("{"), new Reference("_"), new Reference("InlineSpreadElement").setName("value"), new Reference("_"), new Terminal("}")), function (__context, __values) {
      let value = __values[2];
      return value;
    }).setName("JSXSpreadAttribute"), new Repeat(new Action(new Sequence(new Reference("_"), new Choice(new Reference("JSXAttribute"), new Reference("JSXSpreadAttribute")).setName("value")), function (__context, __values) {
      let value = __values[1];
      return value;
    }), 1).setName("JSXAttributes"), new Action(new Sequence(new Terminal("<"), new Reference("_"), new Reference("JSXElementName").setName("kind"), new Reference("_"), new Optional(new Reference("JSXAttributes")).setName("properties"), new Reference("_"), new Terminal("/>")), function (__context, __values) {
      let kind = __values[2];
      let properties = __values[4];
      return node("ElementExpression", {
        kind,
        properties: properties || [],
        children: []
      });
    }).setName("InlineJSXElementSelfClosing"), new Action(new Sequence(new Terminal("<"), new Reference("_"), new Reference("JSXElementName").setName("kind"), new Reference("_"), new Optional(new Reference("JSXAttributes")).setName("properties"), new Reference("_"), new Terminal(">")), function (__context, __values) {
      let kind = __values[2];
      let properties = __values[4];
      return node("ElementExpression", {
        kind,
        properties: properties || [],
        children: []
      });
    }).setName("InlineJSXElementOpen"), new Action(new Sequence(new Terminal("</"), new Reference("_"), new Reference("JSXElementName").setName("value"), new Reference("_"), new Terminal(">")), function (__context, __values) {
      let value = __values[2];
      return value;
    }).setName("InlineJSXElementClose"), new Action(new Sequence(new Repeat(new Group(new Sequence(new NotPredicate(new Terminal("<")), new NotPredicate(new Terminal(">")), new NotPredicate(new Terminal("{")), new NotPredicate(new Terminal("}")), new Any())), 1)), function (__context, __values) {
      ;
      return node("Literal", {
        value: text().replace(/&lt;/g, "<").replace(/&gt;/g, ">")
      });
    }).setName("InlineJSXText"), new Choice(new Action(new Sequence(new Terminal("{"), new Reference("_"), new Choice(new Reference("InlineExpression"), new Reference("InlineSpreadElement")).setName("value"), new Reference("_"), new Terminal("}")), function (__context, __values) {
      let value = __values[2];
      return value;
    }), new Reference("InlineJSXElementExpression"), new Reference("InlineJSXText")).setName("InlineJSXChild"), new Choice(new Reference("InlineJSXElementSelfClosing"), new Action(new Sequence(new Reference("InlineJSXElementOpen").setName("open"), new Repeat(new Reference("InlineJSXChild")).setName("children"), new Reference("InlineJSXElementClose").setName("close")), function (__context, __values) {
      let open = __values[0];
      let children = __values[1];
      let close = __values[2];
      return node("ElementExpression", { ...open,
        children,
        close: close || null
      });
    })).setName("InlineJSXElementExpression"), new Action(new Sequence(new Reference("InlineJSXElementSelfClosing").setName("element"), new Reference("OutlineArrayArguments").setName("children")), function (__context, __values) {
      let element = __values[0];
      let children = __values[1];
      return node("ElementExpression", { ...element,
        children
      });
    }).setName("OutlineJSXElementExpression"), new Action(new Sequence(new Reference("EOL"), new Reference("Indent"), new Repeat(new Action(new Sequence(new Reference("Dent"), new Choice(new Action(new Sequence(new Choice(new Reference("OutlineExpression"), new Action(new Sequence(new Reference("InlineExpressionList").setName("value"), new Reference("EOL")), function (__context, __values) {
      let value = __values[0];
      return value;
    })).setName("value")), function (__context, __values) {
      let value = __values[0];
      return value;
    }), new Action(new Sequence(new Reference("Statement").setName("value")), function (__context, __values) {
      let value = __values[0];
      return value;
    })).setName("value")), function (__context, __values) {
      let value = __values[1];
      return value;
    }), 1).setName("args"), new Reference("Outdent")), function (__context, __values) {
      let args = __values[2];
      return args.flat();
    }).setName("OutlineArrayArguments"), new Choice(new Action(new Sequence(new Terminal("[]"), new Reference("OutlineArrayArguments").setName("elements")), function (__context, __values) {
      let elements = __values[1];
      return node("ArrayExpression", {
        elements: elements.flat()
      });
    }), new Action(new Sequence(new Terminal("||"), new Reference("OutlineArrayArguments").setName("elements")), function (__context, __values) {
      let elements = __values[1];
      return node("ArrayExpression", {
        elements: elements.flat(),
        isSet: true
      });
    })).setName("OutlineArrayExpression"), new Action(new Sequence(new Reference("InlineObjectExpression").setName("e"), new Reference("OutlinePropertyList").setName("properties")), function (__context, __values) {
      let e = __values[0];
      let properties = __values[1];
      return node("ObjectExpression", {
        isMap: e.isMap,
        properties: [...e.properties, ...properties]
      });
    }).setName("OutlineObjectExpression"), new Action(new Sequence(new Reference("EOL"), new Reference("Indent"), new Repeat(new Action(new Sequence(new Reference("Dent"), new Choice(new Reference("OutlineMapProperty"), new Reference("Statement")).setName("value")), function (__context, __values) {
      let value = __values[1];
      return value;
    }), 1).setName("value"), new Reference("Outdent")), function (__context, __values) {
      let value = __values[2];
      return value;
    }).setName("OutlineMapPropertyList"), new Action(new Sequence(new Reference("InlineExpression").setName("key"), new Reference("_"), new Terminal(":"), new Reference("_"), new Reference("OutlineExpression").setName("value")), function (__context, __values) {
      let key = __values[0];
      let value = __values[4];
      return node("Property", {
        key,
        value,
        computed: true
      });
    }).setName("OutlineMapProperty"), new Action(new Sequence(new Reference("EOL"), new Reference("Indent"), new Repeat(new Action(new Sequence(new Reference("Dent"), new Choice(new Reference("OutlineProperty"), new Reference("Statement")).setName("value")), function (__context, __values) {
      let value = __values[1];
      return value;
    }), 1).setName("value"), new Reference("Outdent")), function (__context, __values) {
      let value = __values[2];
      return value;
    }).setName("OutlinePropertyList"), new Action(new Sequence(new Choice(new Reference("OutlineProperty"), new Reference("OutlineMapProperty")).setName("property")), function (__context, __values) {
      let property = __values[0];
      return node("PropertyStatement", {
        property
      });
    }).setName("PropertyStatement"), new Choice(new Action(new Sequence(new Reference("InlineSpreadElement").setName("value"), new Reference("EOL")), function (__context, __values) {
      let value = __values[0];
      return value;
    }), new Action(new Sequence(new Terminal("["), new Reference("_"), new Reference("InlineExpression").setName("key"), new Reference("_"), new Terminal("]"), new Reference("_"), new Terminal(":"), new Reference("_"), new Reference("OutlineExpression").setName("value")), function (__context, __values) {
      let key = __values[2];
      let value = __values[8];
      return node("Property", {
        key,
        value,
        computed: true
      });
    }), new Action(new Sequence(new Action(new Sequence(new Reference("Identifier").setName("value"), new Reference("_"), new Terminal(":")), function (__context, __values) {
      let value = __values[0];
      return value;
    }).setName("key"), new Reference("_"), new Reference("OutlineExpression").setName("value")), function (__context, __values) {
      let key = __values[0];
      let value = __values[2];
      return node("Property", {
        key,
        value
      });
    }), new Action(new Sequence(new Reference("GetToken"), new Reference("_"), new Reference("NamedOutlineFunction").setName("value")), function (__context, __values) {
      let value = __values[2];
      return node("Property", {
        key: value.id,
        value,
        kind: "get",
        method: true
      });
    }), new Action(new Sequence(new Reference("SetToken"), new Reference("_"), new Reference("NamedOutlineFunction").setName("value")), function (__context, __values) {
      let value = __values[2];
      return node("Property", {
        key: value.id,
        value,
        kind: "set",
        method: true
      });
    }), new Action(new Sequence(new Reference("NamedOutlineFunction").setName("value")), function (__context, __values) {
      let value = __values[0];
      return node("Property", {
        key: value.id,
        value,
        method: true
      });
    }), new Action(new Sequence(new Reference("Identifier").setName("key"), new Reference("EOL")), function (__context, __values) {
      let key = __values[0];
      return node("Property", {
        key,
        value: node("Reference", key),
        shorthand: true
      });
    })).setName("OutlineProperty"), new Action(new Sequence(new Reference("InlineExpression").setName("key"), new Reference("_"), new Terminal(":"), new Reference("_"), new Reference("InlineExpression").setName("value")), function (__context, __values) {
      let key = __values[0];
      let value = __values[4];
      return node("Property", {
        key,
        value,
        computed: true
      });
    }).setName("InlineMapProperty"), new Action(new Sequence(new Reference("InlineMapProperty").setName("head"), new Repeat(new Action(new Sequence(new Reference("_"), new Terminal(","), new Reference("_"), new Reference("InlineMapProperty").setName("value")), function (__context, __values) {
      let value = __values[3];
      return value;
    })).setName("tail")), function (__context, __values) {
      let head = __values[0];
      let tail = __values[1];
      return [head, ...tail];
    }).setName("InlineMapPropertyList"), new Choice(new Action(new Sequence(new Terminal("{"), new Reference("_"), new Optional(new Reference("InlinePropertyList")).setName("properties"), new Reference("_"), new Terminal("}")), function (__context, __values) {
      let properties = __values[2];
      return node("ObjectExpression", {
        properties: properties || []
      });
    }), new Action(new Sequence(new Terminal("("), new Reference("_"), new Optional(new Reference("InlineMapPropertyList")).setName("properties"), new Reference("_"), new Terminal(")")), function (__context, __values) {
      let properties = __values[2];
      return node("ObjectExpression", {
        properties: properties || [],
        isMap: true
      });
    })).setName("InlineObjectExpression"), new Choice(new Reference("InlineSpreadElement"), new Action(new Sequence(new Terminal("["), new Reference("_"), new Reference("InlineExpression").setName("key"), new Reference("_"), new Terminal("]"), new Reference("_"), new Terminal(":"), new Reference("_"), new Reference("InlineExpression").setName("value")), function (__context, __values) {
      let key = __values[2];
      let value = __values[8];
      return node("Property", {
        key,
        value,
        computed: true
      });
    }), new Action(new Sequence(new Action(new Sequence(new Reference("Identifier").setName("value"), new Reference("_"), new Terminal(":")), function (__context, __values) {
      let value = __values[0];
      return value;
    }).setName("key"), new Reference("_"), new Reference("InlineExpression").setName("value")), function (__context, __values) {
      let key = __values[0];
      let value = __values[2];
      return node("Property", {
        key,
        value
      });
    }), new Action(new Sequence(new Reference("GetToken"), new Reference("_"), new Reference("NamedInlineFunction").setName("value")), function (__context, __values) {
      let value = __values[2];
      return node("Property", {
        key: value.id,
        value,
        kind: "get",
        method: true
      });
    }), new Action(new Sequence(new Reference("SetToken"), new Reference("_"), new Reference("NamedInlineFunction").setName("value")), function (__context, __values) {
      let value = __values[2];
      return node("Property", {
        key: value.id,
        value,
        kind: "set",
        method: true
      });
    }), new Action(new Sequence(new Reference("NamedInlineFunction").setName("value")), function (__context, __values) {
      let value = __values[0];
      return node("Property", {
        key: value.id,
        value,
        method: true
      });
    }), new Action(new Sequence(new Reference("Identifier").setName("key")), function (__context, __values) {
      let key = __values[0];
      return node("Property", {
        key,
        value: node("Reference", key),
        shorthand: true
      });
    })).setName("InlineProperty"), new Action(new Sequence(new Reference("InlineProperty").setName("head"), new Repeat(new Action(new Sequence(new Reference("_"), new Terminal(","), new Reference("_"), new Reference("InlineProperty").setName("value")), function (__context, __values) {
      let value = __values[3];
      return value;
    })).setName("tail")), function (__context, __values) {
      let head = __values[0];
      let tail = __values[1];
      return [head, ...tail];
    }).setName("InlinePropertyList"), new Choice(new Reference("NumericLiteral"), new Reference("BooleanLiteral"), new Reference("StringLiteral"), new Reference("NullLiteral"), new Reference("RegularExpression")).setName("Literal"), new Choice(new Reference("HexIntegerLiteral"), new Reference("DecimalLiteral"), new Reference("DecimalIntegerLiteral")).setName("NumericLiteral"), new Action(new Sequence(new Reference("NullToken")), function (__context, __values) {
      ;
      return node('Literal', {
        value: null
      });
    }).setName("NullLiteral"), new Action(new Sequence(new Choice(new Reference("TrueToken"), new Reference("FalseToken")).setName("value")), function (__context, __values) {
      let value = __values[0];
      return node('Literal', {
        value: JSON.parse(value) ? true : false
      });
    }).setName("BooleanLiteral"), new Sequence(new Terminal("e"), new Optional(new Regex(/[\+\-]/y)), new Repeat(new Regex(/[0-9]/y), 1), new NotPredicate(new Reference("IdPart"))).setName("ExponentPart"), new Action(new Sequence(new Choice(new Sequence(new Optional(new Reference("DecimalInteger")), new Terminal("."), new Repeat(new Regex(/[0-9]/y), 1), new Optional(new Reference("ExponentPart"))), new Sequence(new Reference("DecimalInteger"), new Reference("ExponentPart"))), new NotPredicate(new Reference("IdPart"))), function (__context, __values) {
      ;
      return node('Literal', {
        value: parseFloat(text())
      });
    }).setName("DecimalLiteral"), new Regex(/[0-9A-F]/y).setName("HexDigit"), new Action(new Sequence(new Terminal("0x"), new Repeat(new Reference("HexDigit"), 1), new NotPredicate(new Reference("IdPart"))), function (__context, __values) {
      ;
      return node('Literal', {
        value: parseInt(text(), 16)
      });
    }).setName("HexIntegerLiteral"), new Action(new Sequence(new Reference("DecimalInteger")), function (__context, __values) {
      ;
      return node('Literal', {
        value: parseInt(text())
      });
    }).setName("DecimalIntegerLiteral"), new Choice(new Terminal("0"), new Action(new Sequence(new Optional(new Regex(/[\+\-]/y)), new Regex(/[1-9]/y), new Repeat(new Regex(/[0-9]/y)), new NotPredicate(new Reference("IdPart"))), function (__context, __values) {
      ;
      return parseInt(text());
    })).setName("DecimalInteger"), new Action(new Sequence(new Terminal("\""), new Repeat(new Reference("DoubleStringChar")), new Terminal("\"")), function (__context, __values) {
      ;
      return node('Literal', {
        value: eval(text())
      });
    }).setName("StringLiteral"), new Choice(new Regex(/[^\r\n\t\b\f\"]/y), new Sequence(new Terminal("\\"), new Choice(new Regex(/[rn\"]/y), new Sequence(new Terminal("u"), new Repeat(new Reference("HexDigit"), 4, 4))))).setName("DoubleStringChar"), new Choice(new Action(new Sequence(new Reference("_"), new Reference("LineTerminatorSequence")), function (__context, __values) {
      ;
      return '';
    }), new Action(new Sequence(new Reference("Dent"), new Repeat(new Regex(/[^\r\n]/y)).setName("line"), new Reference("LineTerminatorSequence")), function (__context, __values) {
      let line = __values[1];
      return line.join('');
    })).setName("OutlineStringLiteralLine"), new Action(new Sequence(new Terminal("\"\""), new Reference("EOL"), new Reference("Indent"), new Repeat(new Reference("OutlineStringLiteralLine")).setName("lines"), new Reference("Outdent")), function (__context, __values) {
      let lines = __values[3];
      return node('Literal', {
        value: lines.join('\n')
      });
    }).setName("OutlineStringLiteral"), new Action(new Sequence(new Terminal("/"), new StringValue(new Repeat(new Choice(new Group(new Sequence(new Terminal("\\"), new Any())), new Regex(/[^\/]/y)), 1)).setName("pattern"), new Terminal("/"), new StringValue(new Repeat(new Regex(/[a-z]/y))).setName("flags")), function (__context, __values) {
      let pattern = __values[1];
      let flags = __values[3];
      return node("RegularExpression", {
        pattern,
        flags
      });
    }).setName("RegularExpression"), new Regex(/[a-zA-Z\$_]/y).setName("IdStart"), new Choice(new Reference("IdStart"), new Regex(/[0-9]/y)).setName("IdPart"), new Choice(new StringValue(new Group(new Sequence(new NotPredicate(new Reference("ReservedWord")), new Reference("IdStart"), new Repeat(new Reference("IdPart"))))), new Action(new Sequence(new Terminal("`"), new StringValue(new Repeat(new Group(new Sequence(new NotPredicate(new Terminal("`")), new Any())))).setName("value"), new Terminal("`")), function (__context, __values) {
      let value = __values[1];
      return value;
    })).setName("IdName"), new Action(new Sequence(new Reference("IdName").setName("name")), function (__context, __values) {
      let name = __values[0];
      return node('Identifier', {
        name
      });
    }).setName("Identifier"), new Action(new Sequence(new Reference("IdName").setName("name")), function (__context, __values) {
      let name = __values[0];
      return node("Reference", {
        name
      });
    }).setName("Reference"), new Action(new Sequence(new Reference("IdName").setName("name")), function (__context, __values) {
      let name = __values[0];
      return node("Declarator", {
        name
      });
    }).setName("Declarator"), new Action(new Sequence(new Terminal("this").setName("value"), new NotPredicate(new Reference("IdPart"))), function (__context, __values) {
      let value = __values[0];
      return value;
    }).setName("ThisToken"), new Action(new Sequence(new Terminal("null").setName("value"), new NotPredicate(new Reference("IdPart"))), function (__context, __values) {
      let value = __values[0];
      return value;
    }).setName("NullToken"), new Action(new Sequence(new Terminal("false").setName("value"), new NotPredicate(new Reference("IdPart"))), function (__context, __values) {
      let value = __values[0];
      return value;
    }).setName("TrueToken"), new Action(new Sequence(new Terminal("true").setName("value"), new NotPredicate(new Reference("IdPart"))), function (__context, __values) {
      let value = __values[0];
      return value;
    }).setName("FalseToken"), new Action(new Sequence(new Terminal("type").setName("value"), new NotPredicate(new Reference("IdPart"))), function (__context, __values) {
      let value = __values[0];
      return value;
    }).setName("TypeToken"), new Action(new Sequence(new Terminal("is").setName("value"), new NotPredicate(new Reference("IdPart"))), function (__context, __values) {
      let value = __values[0];
      return value;
    }).setName("IsToken"), new Action(new Sequence(new Terminal("isnt").setName("value"), new NotPredicate(new Reference("IdPart"))), function (__context, __values) {
      let value = __values[0];
      return value;
    }).setName("IsntToken"), new Action(new Sequence(new Terminal("as").setName("value"), new NotPredicate(new Reference("IdPart"))), function (__context, __values) {
      let value = __values[0];
      return value;
    }).setName("AsToken"), new Action(new Sequence(new Terminal("and").setName("value"), new NotPredicate(new Reference("IdPart"))), function (__context, __values) {
      let value = __values[0];
      return value;
    }).setName("AndToken"), new Action(new Sequence(new Terminal("or").setName("value"), new NotPredicate(new Reference("IdPart"))), function (__context, __values) {
      let value = __values[0];
      return value;
    }).setName("OrToken"), new Action(new Sequence(new Terminal("xor").setName("value"), new NotPredicate(new Reference("IdPart"))), function (__context, __values) {
      let value = __values[0];
      return value;
    }).setName("XorToken"), new Action(new Sequence(new Terminal("not").setName("value"), new NotPredicate(new Reference("IdPart"))), function (__context, __values) {
      let value = __values[0];
      return value;
    }).setName("NotToken"), new Action(new Sequence(new Terminal("typeof").setName("value"), new NotPredicate(new Reference("IdPart"))), function (__context, __values) {
      let value = __values[0];
      return value;
    }).setName("TypeofToken"), new Action(new Sequence(new Terminal("new").setName("value"), new NotPredicate(new Reference("IdPart"))), function (__context, __values) {
      let value = __values[0];
      return value;
    }).setName("NewToken"), new Action(new Sequence(new Terminal("where").setName("value"), new NotPredicate(new Reference("IdPart"))), function (__context, __values) {
      let value = __values[0];
      return value;
    }).setName("WhereToken"), new Action(new Sequence(new Terminal("import").setName("value"), new NotPredicate(new Reference("IdPart"))), function (__context, __values) {
      let value = __values[0];
      return value;
    }).setName("ImportToken"), new Action(new Sequence(new Terminal("export").setName("value"), new NotPredicate(new Reference("IdPart"))), function (__context, __values) {
      let value = __values[0];
      return value;
    }).setName("ExportToken"), new Action(new Sequence(new Terminal("default").setName("value"), new NotPredicate(new Reference("IdPart"))), function (__context, __values) {
      let value = __values[0];
      return value;
    }).setName("DefaultToken"), new Action(new Sequence(new Terminal("class").setName("value"), new NotPredicate(new Reference("IdPart"))), function (__context, __values) {
      let value = __values[0];
      return value;
    }).setName("ClassToken"), new Action(new Sequence(new Terminal("struct").setName("value"), new NotPredicate(new Reference("IdPart"))), function (__context, __values) {
      let value = __values[0];
      return value;
    }).setName("StructToken"), new Action(new Sequence(new Terminal("var").setName("value"), new NotPredicate(new Reference("IdPart"))), function (__context, __values) {
      let value = __values[0];
      return value;
    }).setName("VarToken"), new Action(new Sequence(new Terminal("let").setName("value"), new NotPredicate(new Reference("IdPart"))), function (__context, __values) {
      let value = __values[0];
      return value;
    }).setName("LetToken"), new Action(new Sequence(new Terminal("property").setName("value"), new NotPredicate(new Reference("IdPart"))), function (__context, __values) {
      let value = __values[0];
      return value;
    }).setName("PropertyToken"), new Action(new Sequence(new Terminal("meta").setName("value"), new NotPredicate(new Reference("IdPart"))), function (__context, __values) {
      let value = __values[0];
      return value;
    }).setName("MetaToken"), new Action(new Sequence(new Terminal("static").setName("value"), new NotPredicate(new Reference("IdPart"))), function (__context, __values) {
      let value = __values[0];
      return value;
    }).setName("StaticToken"), new Action(new Sequence(new Terminal("data").setName("value"), new NotPredicate(new Reference("IdPart"))), function (__context, __values) {
      let value = __values[0];
      return value;
    }).setName("DataToken"), new Action(new Sequence(new Terminal("extends").setName("value"), new NotPredicate(new Reference("IdPart"))), function (__context, __values) {
      let value = __values[0];
      return value;
    }).setName("ExtendsToken"), new Action(new Sequence(new Terminal("for").setName("value"), new NotPredicate(new Reference("IdPart"))), function (__context, __values) {
      let value = __values[0];
      return value;
    }).setName("ForToken"), new Action(new Sequence(new Terminal("while").setName("value"), new NotPredicate(new Reference("IdPart"))), function (__context, __values) {
      let value = __values[0];
      return value;
    }).setName("WhileToken"), new Action(new Sequence(new Terminal("in").setName("value"), new NotPredicate(new Reference("IdPart"))), function (__context, __values) {
      let value = __values[0];
      return value;
    }).setName("InToken"), new Action(new Sequence(new Terminal("of").setName("value"), new NotPredicate(new Reference("IdPart"))), function (__context, __values) {
      let value = __values[0];
      return value;
    }).setName("OfToken"), new Action(new Sequence(new Terminal("if").setName("value"), new NotPredicate(new Reference("IdPart"))), function (__context, __values) {
      let value = __values[0];
      return value;
    }).setName("IfToken"), new Action(new Sequence(new Terminal("else").setName("value"), new NotPredicate(new Reference("IdPart"))), function (__context, __values) {
      let value = __values[0];
      return value;
    }).setName("ElseToken"), new Action(new Sequence(new Terminal("return").setName("value"), new NotPredicate(new Reference("IdPart"))), function (__context, __values) {
      let value = __values[0];
      return value;
    }).setName("ReturnToken"), new Action(new Sequence(new Terminal("break").setName("value"), new NotPredicate(new Reference("IdPart"))), function (__context, __values) {
      let value = __values[0];
      return value;
    }).setName("BreakToken"), new Action(new Sequence(new Terminal("continue").setName("value"), new NotPredicate(new Reference("IdPart"))), function (__context, __values) {
      let value = __values[0];
      return value;
    }).setName("ContinueToken"), new Action(new Sequence(new Terminal("asm").setName("value"), new NotPredicate(new Reference("IdPart"))), function (__context, __values) {
      let value = __values[0];
      return value;
    }).setName("AsmToken"), new Action(new Sequence(new Terminal("throw").setName("value"), new NotPredicate(new Reference("IdPart"))), function (__context, __values) {
      let value = __values[0];
      return value;
    }).setName("ThrowToken"), new Action(new Sequence(new Terminal("try").setName("value"), new NotPredicate(new Reference("IdPart"))), function (__context, __values) {
      let value = __values[0];
      return value;
    }).setName("TryToken"), new Action(new Sequence(new Terminal("catch").setName("value"), new NotPredicate(new Reference("IdPart"))), function (__context, __values) {
      let value = __values[0];
      return value;
    }).setName("CatchToken"), new Action(new Sequence(new Terminal("finally").setName("value"), new NotPredicate(new Reference("IdPart"))), function (__context, __values) {
      let value = __values[0];
      return value;
    }).setName("FinallyToken"), new Action(new Sequence(new Terminal("get").setName("value"), new NotPredicate(new Reference("IdPart"))), function (__context, __values) {
      let value = __values[0];
      return value;
    }).setName("GetToken"), new Action(new Sequence(new Terminal("set").setName("value"), new NotPredicate(new Reference("IdPart"))), function (__context, __values) {
      let value = __values[0];
      return value;
    }).setName("SetToken"), new Action(new Sequence(new Terminal("switch").setName("value"), new NotPredicate(new Reference("IdPart"))), function (__context, __values) {
      let value = __values[0];
      return value;
    }).setName("SwitchToken"), new Action(new Sequence(new Terminal("async").setName("value"), new NotPredicate(new Reference("IdPart"))), function (__context, __values) {
      let value = __values[0];
      return value;
    }).setName("AsyncToken"), new Action(new Sequence(new Terminal("await").setName("value"), new NotPredicate(new Reference("IdPart"))), function (__context, __values) {
      let value = __values[0];
      return value;
    }).setName("AwaitToken"), new Action(new Sequence(new Terminal("yield").setName("value"), new NotPredicate(new Reference("IdPart"))), function (__context, __values) {
      let value = __values[0];
      return value;
    }).setName("YieldToken"), new Action(new Sequence(new Terminal("do").setName("value"), new NotPredicate(new Reference("IdPart"))), function (__context, __values) {
      let value = __values[0];
      return value;
    }).setName("DoToken"), new Choice(new Reference("ThisToken"), new Reference("NullToken"), new Reference("TrueToken"), new Reference("FalseToken"), new Reference("AndToken"), new Reference("IsToken"), new Reference("IsntToken"), new Reference("AsToken"), new Reference("OrToken"), new Reference("XorToken"), new Reference("NotToken"), new Reference("TypeofToken"), new Reference("NewToken"), new Reference("WhereToken"), new Reference("ClassToken"), new Reference("StructToken"), new Reference("VarToken"), new Reference("LetToken"), new Reference("ForToken"), new Reference("WhileToken"), new Reference("IfToken"), new Reference("ElseToken"), new Reference("ReturnToken"), new Reference("BreakToken"), new Reference("ContinueToken"), new Reference("ExportToken"), new Reference("ImportToken"), new Reference("AsmToken"), new Reference("ThrowToken"), new Reference("TryToken"), new Reference("CatchToken"), new Reference("FinallyToken"), new Reference("SwitchToken")).setName("Keyword"), new Reference("Keyword").setName("ReservedWord"), new Increment("indentation", 1).setName("Indent"), new Increment("indentation", -1).setName("Outdent"), new Repeat(new Terminal("    "), "indentation", "indentation").setName("Dent"), new Choice(new Terminal("\n"), new Terminal("\r\n"), new Terminal("\r")).setName("LineTerminatorSequence"), new Sequence(new Terminal("//"), new Repeat(new Group(new Sequence(new NotPredicate(new Regex(/[\r\n]/y)), new Any())))).setLabel("").setName("Comment"), new Repeat(new Terminal(" ")).setLabel("").setName("_"), new Repeat(new Choice(new Terminal(" "), new Reference("LineTerminatorSequence"), new Reference("Comment"))).setLabel("").setName("__"), new Choice(new Repeat(new Group(new Sequence(new Reference("_"), new Optional(new Reference("Comment")), new Repeat(new Reference("LineTerminatorSequence"), 1))), 1), new Reference("EOF")).setLabel("end of line").setName("EOL"), new NotPredicate(new Any()).setLabel("").setName("EOF")]));
    return parser;
  };
}();

exports.default = exports;
},{"pegs":"rnKD","./ast":"rCtP"}],"M31S":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const fs = __importStar(require("fs"));

const np = __importStar(require("path"));

function watchDirectory(dirname, options, listener) {
  let {
    persistent = true,
    interval = 50,
    recursive = true,
    include,
    exclude = {
      node_modules: true
    }
  } = options;
  let initial = options.initial ? "initial" : null;

  function matches(name, filter, defaultValue) {
    if (filter == null) {
      return defaultValue;
    }

    if (Array.isArray(filter)) {
      return filter.indexOf(name) >= 0;
    }

    if (typeof filter === "string") {
      let ext = filter;
      return name.indexOf(ext, name.length - ext.length) >= 0;
    }

    if (typeof filter.test === "function") {
      return filter.test(name);
    }

    if (typeof filter === "function") {
      return filter(name);
    }

    return filter[name] === true;
  }

  function filter(name) {
    if (matches(name, exclude, false)) {
      return false;
    }

    return matches(name, include, true);
  }

  let watchedFiles = {};

  function notifyListener(filename, current, previous, change) {
    if (filter(filename)) {
      listener(filename, current, previous, change);
    }
  }

  function unwatchFile(filename) {
    fs.unwatchFile(filename, watchedFiles[filename]);
    delete watchedFiles[filename];
  }

  function watchFile(filename, depth = 0, stats = fs.statSync(filename)) {
    if (stats.nlink > 0) {
      if (stats.isDirectory()) {
        if (!matches(filename, exclude, false)) {
          if (depth === 0 || recursive) {
            for (let child of fs.readdirSync(filename)) {
              watchFile(np.join(filename, child), depth + 1);
            }
          }
        }
      }

      if (watchedFiles[filename] == null) {
        let boundListener = fsListener.bind(null, filename, depth);
        watchedFiles[filename] = boundListener;

        if (persistent) {
          fs.watchFile(filename, {
            persistent,
            interval
          }, boundListener);
        }

        if (initial != null) {
          notifyListener(filename, stats, stats, initial);
        }
      }
    }
  }

  let fsListener = (filename, depth, current, previous) => {
    let change = "modified";

    if (current.nlink === 0) {
      change = "deleted";
    }

    if (previous.nlink === 0) {
      change = "created";
    }

    notifyListener(filename, current, previous, change);

    if (change !== "deleted") {
      watchFile(filename, depth, current);
    } else {
      unwatchFile(filename);
    }
  };

  watchFile(dirname);
  initial = "created"; // returns a function which unwatches everything

  return () => {
    for (let filename in watchedFiles) {
      unwatchFile(filename);
    }
  };
}

exports.default = watchDirectory;
},{"fs":"Zcgp","path":"FHml"}],"TnbZ":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.compileSample = exports.Options = void 0;

const HtmlLogger = __importStar(require("./HtmlLogger"));

const common = __importStar(require("./common"));

const phases_1 = __importStar(require("./phases")); // we need the path to lib so the code works in normal compile and in parcel


const Parser = require("../../lib/compiler/parser");

const watchDirectory_1 = __importDefault(require("./watchDirectory"));

const toModuleFiles_1 = __importStar(require("./phases/toModuleFiles"));

const NullLogger = () => {};

class Options {
  constructor(inputs, output, namespace, debug, emit) {
    var _a, _b;

    if (namespace === void 0) {
      namespace = (_b = (_a = common.findPackage()) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : "_compiling_";
    }

    if (debug === void 0) {
      debug = true;
    }

    if (emit === void 0) {
      emit = true;
    }

    this.namespace = namespace;
    this.inputs = inputs;
    this.output = output;
    this.debug = debug;
    this.emit = emit;
  }

}

exports.Options = Options;

function compileSample(text, name = "sample", debug = true) {
  let emit = false;
  let compiler = new Compiler(() => {});
  let options = new Options([], "null", "none", debug, emit);
  let results = compiler.compile(options, {
    [name]: text
  });

  if (results.errors.length > 0) {
    return results.errors[0];
  }

  let output = results.phases.get(toModuleFiles_1.default).modules.get(name + toModuleFiles_1.moduleExtension);
  return output;
}

exports.compileSample = compileSample;

class Compiler {
  constructor(logger = HtmlLogger.create("./output.html")) {
    this.logger = logger;
  }

  watch(options) {
    //  first compile normal
    this.compile(options); //  then watch files for changes

    for (let input of options.inputs) {
      watchDirectory_1.default(input, {}, (filename, previous, current, change) => {
        //  incrementally recompile just this file
        let start = Date.now();
        let content = common.read(filename);
        let path = common.getPathFromFilename(options.namespace, filename.slice(input.length + 1)); // console.log({ filename, change, path, content })
        //  we *really* should also kickoff a full recompile in a separate thread
        //  or maybe the fast compile should be in the other thread

        this.compile(options, {
          [path]: content
        }, phases_1.default, NullLogger);
        let stop = Date.now();
        let time = stop - start;
        console.log(`${filename} => ${time}ms`);
      });
    }
  }

  compile(options, files, phases = options.emit ? phases_1.default : phases_1.noEmit, logger = this.logger) {
    options.parser = Parser();

    if (files == null) {
      files = common.getInputFilesRecursive(options.inputs, options.namespace);
    }

    let errors = new Array();
    let phaseResults = new Map();
    let root = files;
    logger("Input", root);
    let lastPhase;

    try {
      for (let phase of phases) {
        lastPhase = phase;
        root = phase(root, options) || root;
        phaseResults.set(phase, root);
        logger(phase.name, root);
      }

      logger("Output", root);
      logger();
    } catch (e) {
      errors.push(e);
      console.log(lastPhase === null || lastPhase === void 0 ? void 0 : lastPhase.name);
      logger();
      let location = e.location;

      if (location == null || location.start == null) {
        console.log(e.message);
      } else {
        let {
          filename
        } = location;
        let source = files[filename];
        let error = options.parser.getError(e.message, location, source, filename);
        console.log(error.message);
      }
    }

    return {
      phases: phaseResults,
      errors
    };
  }

}

exports.default = Compiler;
},{"./HtmlLogger":"Lc6w","./common":"gPgA","./phases":"CTXP","../../lib/compiler/parser":"IQyZ","./watchDirectory":"M31S","./phases/toModuleFiles":"p7cS"}],"dVQi":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const react_1 = __importStar(require("react"));

require("./TopLabel.css");

exports.default = react_1.memo(function TopLabel(props) {
  let {
    children,
    ...other
  } = props;
  return react_1.default.createElement("div", Object.assign({}, other, {
    className: "TopLabel"
  }), children);
});
},{"react":"ccIB","./TopLabel.css":"Zcgp"}],"Q3sE":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const react_1 = __importStar(require("react"));

const TopLabel_1 = __importDefault(require("./TopLabel"));

require("./Code.css");

function insertTextAtCursor(text) {
  let selection = window.getSelection();
  let range = selection.getRangeAt(0);
  range.deleteContents();
  let node = document.createTextNode(text);
  range.insertNode(node);

  for (let position = 0; position != text.length; position++) {
    selection.modify("move", "right", "character");
  }

  ;
}

exports.default = react_1.memo(function CodeEditor(props) {
  let {
    children,
    ...other
  } = props;
  return react_1.default.createElement("div", Object.assign({}, other, {
    className: "Code ionscript"
  }), react_1.default.createElement("div", {
    contentEditable: true,
    suppressContentEditableWarning: true,
    style: {
      border: "none",
      outline: "none"
    },
    onKeyDown: e => {
      if (e.key === "Tab") {
        console.log("insert 4 spaces");
        insertTextAtCursor("    ");
        e.stopPropagation();
        e.preventDefault();
      }
    }
  }, children), react_1.default.createElement(TopLabel_1.default, null, "IonScript"));
});
},{"react":"ccIB","./TopLabel":"dVQi","./Code.css":"Zcgp"}],"zW7i":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const react_1 = __importStar(require("react"));

const Compiler_1 = require("../compiler/Compiler");

const TopLabel_1 = __importDefault(require("./TopLabel"));

require("./Code.css");

function insertTextAtCursor(text) {
  let selection = window.getSelection();
  let range = selection.getRangeAt(0);
  range.deleteContents();
  let node = document.createTextNode(text);
  range.insertNode(node);

  for (let position = 0; position != text.length; position++) {
    selection.modify("move", "right", "character");
  }

  ;
}

exports.default = react_1.memo(function CodeEditor(props) {
  let {
    source,
    debug,
    ...other
  } = props;
  let javascript = Compiler_1.compileSample(source, "sample", debug);
  let isError = typeof javascript !== "string";
  return react_1.default.createElement("div", Object.assign({}, other, {
    className: "Code javascript"
  }), javascript.toString(), react_1.default.createElement(TopLabel_1.default, null, debug ? "JavaScript Debug" : "JavaScript Release"));
});
},{"react":"ccIB","../compiler/Compiler":"TnbZ","./TopLabel":"dVQi","./Code.css":"Zcgp"}],"aDHU":[function(require,module,exports) {
"use strict";

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function () {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);

  __setModuleDefault(result, mod);

  return result;
};

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const react_1 = __importStar(require("react"));

const Compiler_1 = require("../compiler/Compiler");

const CodeEditor_1 = __importDefault(require("./CodeEditor"));

require("./CodeSample.css");

const CodeViewer_1 = __importDefault(require("./CodeViewer"));

function CodeSample(props) {
  let [content, setContent] = react_1.useState(props.children);
  let onInput = react_1.useMemo(() => {
    return e => {
      setContent(e.target.innerText);
    };
  }, []);
  let javascript = Compiler_1.compileSample(content, "sample", true);
  let isError = typeof javascript !== "string";
  return react_1.default.createElement("div", {
    className: "CodeSample"
  }, react_1.default.createElement("div", {
    className: "description"
  }, props.description), react_1.default.createElement("div", {
    className: "samples"
  }, react_1.default.createElement(CodeEditor_1.default, {
    onInput: onInput
  }, props.children), react_1.default.createElement(CodeViewer_1.default, {
    source: content,
    debug: true
  }), react_1.default.createElement(CodeViewer_1.default, {
    source: content,
    debug: false
  })));
}

exports.default = CodeSample;
},{"react":"ccIB","../compiler/Compiler":"TnbZ","./CodeEditor":"Q3sE","./CodeSample.css":"Zcgp","./CodeViewer":"zW7i"}],"MLmL":[function(require,module,exports) {
"use strict";

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const react_1 = __importDefault(require("react"));

const CodeSample_1 = __importDefault(require("./CodeSample"));

require("./Application.css");

function Application() {
  return react_1.default.createElement("div", {
    className: "Application"
  }, react_1.default.createElement(CodeSample_1.default, {
    description: "Constant Definitions"
  }, `let x = 12
let name = "Kris"
`), react_1.default.createElement(CodeSample_1.default, {
    description: "Typed Variable Declarations"
  }, `var x: Number
var name: String
`), react_1.default.createElement(CodeSample_1.default, {
    description: "Inline and Outline Arrays"
  }, `let inlineArray = [1, 2, 3]
var outlineArray = []
    1
    2
    3
`), react_1.default.createElement(CodeSample_1.default, {
    description: "Outline Arrays with control flow structures"
  }, `var array = []
    1
    2
    3
    if addFour
        4
`));
}

exports.default = Application;
},{"react":"ccIB","./CodeSample":"aDHU","./Application.css":"Zcgp"}],"zo2T":[function(require,module,exports) {
"use strict";

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", {
  value: true
});

const react_1 = __importDefault(require("react"));

const react_dom_1 = require("react-dom");

const Application_1 = __importDefault(require("./Application"));

react_dom_1.render(react_1.default.createElement(Application_1.default, null), document.getElementById("root"));
},{"react":"ccIB","react-dom":"x9tB","./Application":"MLmL"}]},{},["zo2T"], null)
//# sourceMappingURL=https://glassorg.github.io/ionscript/website.1b898997.js.map