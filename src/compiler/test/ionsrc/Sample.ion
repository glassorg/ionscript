# import "foo/bar/baz"
#     as d
#     * as all
#     a

# data class Horizontal
#     var x: Number = 1

# data class Vertical
#     var y: Number & . < 10 & . >= 0 = 2

# data class Vector extends Horizontal, Vertical
#     var z: Number = 0
#     static var w = 1

# let { a: { b, c: [d, ...e]}, ...f } = { a: { b: 12, c: [true, false], other: 20 } }

# let logNumber = (a: Number & > 20, ...rest: Array<String>) =>
# var foo = "foo"
# foo = 12
class Vector
    var x: Number
    var y: Number

let v = new Vector()
v.x = 12
# v.x = "foo"

# TODO: infer type for MemberExpression
# TODO: check assignments to variables/properties
# TODO: add conditional declarations to implied consequent from return statements

# true ? logNumber(foo, "fuck", "shit") : 12

# let a: String | Number = 10
# a is Number && a < 10 ? logNumber(a) : a

# type UInt8 = Integer & >= 0 & <= 255

# export data struct Vector
#     var x: UInt8 = 0
#     var y: UInt8 = 0

# export data struct Vertex
#     var color: Integer = 0
#     var position: Vector

# let vector = new Vector()

# TODO: Convenient Type structure for representing a child with an optional type
# for instance { x?: Number, y?: Number }
# (.x is Number || .x is Undefined) && (.y is Number || .y is Undefined)

# let foo = (a: Number) =>
#     if a > 0
#         return "foo"
#     else if a < 0
#         return false
#     else
#         foo

# let bar = foo(12)

# import "for/side/effects"
# import "ion/Library"
#     foo
#     bar
#     as importDefault
#     * as importStar

# export let double = a =>
#     if a is Number
#         return foo
#     else if a is String
#         return bar

# double(2)

# export default class Vector

# console.log(Vector)

# data struct Vector3
#     var x: Number = 0
#     var y: Number = 0
#     var z: Number = 0

# type Integer = Number & Math.floor(.) == .
# type AlsoInteger = Integer
# type Literal = "a" | 12 | false

# let double = (a: Number) =>
#     if a is Integer
#         console.log(a)
#     else
#         console.log(a)

#   data class Foo
#   data struct Foo
#   what about a not data struct, what about a struct with writeable fields?
#   there is nothing wrong with that... but it would NOT have .equals, .hashcode etc.
#   data class
#   data struct
# ion.DataMap
# ion.DataSet
# ion.DataArray

#     let sum = x + y + staticSum
#     let constructor = () =>
#         super()
#     let translate = async (dx = 0, dy = 0) => new Vector(x + dx, y + dy)
#     get foo = () => 12
#     set foo = () => 12
#     let [Symbol.iterator] = *() => yield* Object.keys(this)
#     static var staticSum = x + y
#     static let staticX = () => 10
#     static let staticY = () => 20
#     static get foo = () => 12

# import "module" as d
#     a
#     b

# struct Vector
#     var x: Number = 0
#     var y: Number = 0

# let sum =
#     +
#         12
#         if true
#             100
#         20
#         45
#         *
#             10
#             20

# let outlineString = ""
#     what is up
#     my friends?
#     this is pretty cool.

# ion
# console.log()
#     if foo
#         bar
#         baz
#     else
#         4
#     6

# let array = []
#     1, 2, 3, 4
#     for x in ["a", "b", "c"]
#         x + x
#     6, 7, 8

# for [key, value] in (1: 2, 3: 4, 5: 6)
#     console.log({ key, value })

# for y in | "a", 1, true, { x: 1 } |
#     console.log(y)

# # ion
# console.log()
#     1, 2
#     if false
#         3, 4
#     5, 6

# let foo = ()
#     1: 4
#     if foo
#         false: true
#     true: "huh"

# let baz = |1, 2, 3|
# let bar = ||
#     1, 2
#     if foo
#         3
#         4
#     5, 6

# let array = []
#     1, 2, 3
#     if foo
#         4, 5, 6
#         ...fuz
#     7, 8, 9
#     ...bar

# import "foo/bar/baz" a, b
# import ...Foo
#     x
#     y

# let x = foo?.bar[12 + 5]?.baz?("foo", true, x)

# let value = (x = 0, y = 0) => new Vector(1, 2)

# await foo(await bar())

# let identity = async (a, b) =>
#     switch a
#         # inline cases and single statement
#         1, 2, 3: return 10
#         2:
#             # outline statements fine as well
#             return 20
#         3:
#             return 30
#         default:
#             return 55

# Object.defineProperties()
#     Vector.prototype
#     {}
#         bar: {}
#             get: () => 12
#             set: (value) =>

# let generator = *() =>
#     yield* 1
#     yield 2
#     yield 3

# let foo = [a, b, ...bar, c, d]
# let bar = { a, x: y, ...fuz, ...huh }
# let outline = {}
#     x
#     y
#     z
#     ...foo
#     x: 10
#     y: 20
# let matrix = []
#     1, 0, 0, 0
#     0, 1, 0, 0
#     0, 0, 1, 0
#     0, 0, 0, 1
