{

    const ast = require("./ast")
    // const types = require("./types")
    const pathSeparator = "/"

    function getLocation() {
        let { start, end, filename } = location()
        return new ast.Location({
            start: new ast.Position(start.line, start.column),
            end: new ast.Position(end.line, end.column),
            filename
        })
    }

    function isUpperCase(name) {
        let first = name[0]
        return first === first.toUpperCase()
    }

    function isTypeName(name) {
        return isUpperCase(name)
    }

    function getRelativePrefixSteps(relative) {
        if (relative === 0) {
            return []
        }
        if (relative == 1) {
            return ["."]
        }
        return new Array(relative - 1).fill("..")
    }

    function node(type, ...values) {
        // we assign again in case it was overridden by copy values
        let TypeConstructor = ast[type]
        if (TypeConstructor == null) {
            throw new Error(`Missing Type: ${type}`)
        }
        let result = new TypeConstructor(Object.assign({ location: getLocation() }, ...values))
        return result
    }

    function operation(left, operator, right) {
        if (right) {
            return node("BinaryExpression", { left, operator, right })
        }
        else {
            return node("UnaryExpression", { operator, left })
        }
    }

    function buildBinaryExpression(head, tail) {
        return tail.reduce(
            (left, [,operator,,right]) => {
                if (operator === "isnt") {
                    return operation(operation(left, "is", right), "not")
                }
                else {
                    return operation(left, operator, right)
                }
            }
            ,head
        )
    }

    function toMap(nodes, getKey = node => node.id.name) {
        return new Map(nodes.map(node => [getKey(node), node]))
    }

}

////////////////////////////////////////////////////////////////////////////////
//  Module
////////////////////////////////////////////////////////////////////////////////

Module
    = EOL? body:ModuleDeclaration* EOL EOF
    { return node("Program", { sourceType: "module", body }) }

ModuleDeclaration
    = ImportDeclaration
    / Declaration
    / ExportDeclaration

////////////////////////////////////////////////////////////////////////////////
//  ExportDeclaration
////////////////////////////////////////////////////////////////////////////////

ExportDeclaration
    = ExportNamedDeclaration
    / ExportDefaultDeclaration

ExportNamedDeclaration
    = ExportToken _ declaration:(Declaration / ImportDeclaration)
    { return node(declaration.constructor.name, { ...declaration, export: 1 }) }

ExportDefaultDeclaration
    = ExportToken _ isDefault:DefaultToken? _ declaration:(ClassDeclaration / OutlineExpression)
    { return node(declaration.constructor.name, { ...declaration, export: isDefault ? 2 : 1 }) }

////////////////////////////////////////////////////////////////////////////////
//  ImportDeclaration
////////////////////////////////////////////////////////////////////////////////

ImportDeclaration
    = ImportToken _ source:(StringLiteral / Path) _ specifiers:(InlineSpecifiers / OutlineSpecifiers)
    {
        if (Array.isArray(source) /* is Path */) {
            if (specifiers.length === 0) {
                // smart import
                let local = source[source.length - 1]
                let type = isTypeName(local.name) ? "ImportDefaultSpecifier" : "ImportNamespaceSpecifier"
                specifiers.push(node(type, { local }))
            }
            let path = source.map(id => id.name ?? id).join(pathSeparator)
            source = node("Literal", { value: path })
        }
        return node("ImportDeclaration", { specifiers, source })
    }

InlineSpecifiers
    = head: Specifier tail:(_ "," _ @Specifier)* EOL
    { return [head, ...tail] }

OutlineSpecifiers
    = EOL Indent @(Dent @Specifier EOL)* Outdent

Path
    = relative:(".")* head:Identifier tail:(_ "." _ @Identifier)*
    { return [...getRelativePrefixSteps(relative.length), head, ...tail] }

Specifier
    = ImportDefaultSpecifier
    / ImportNamespaceSpecifier
    / ImportSpecifier

ImportSpecifier
    = imported: Identifier local:(_ AsToken _ @Identifier)?
    { return node("ImportSpecifier", { imported, local: local ?? imported }) }

ImportDefaultSpecifier
    = "as" _ local: Identifier
    { return node("ImportDefaultSpecifier", { local }) }

ImportNamespaceSpecifier
    = "*" _ "as" _ local: Identifier
    { return node("ImportNamespaceSpecifier", { local }) }

////////////////////////////////////////////////////////////////////////////////
//  Statements
////////////////////////////////////////////////////////////////////////////////

Statement
    = Declaration
    / AssignmentStatement
    // / OutlineExpression
    / IfStatement
    / ForInStatement
    / ReturnStatement
    / WhileStatement
    / ExpressionStatement
    / ThrowStatement

ThrowStatement
    = ThrowToken _ arg:OutlineExpression
    { return node("ThrowStatement", { argument: arg }) }

ExpressionStatement
    = value:OutlineExpression
    { return node("ExpressionStatement", { value }) }

Declaration
    = ClassDeclaration
    / VariableDeclaration

VariableDeclarationType
    = VarToken { return { assignable: true } }
    / LetToken { return { assignable: false } }
    // / PropertyToken { return "Property" } // I think this was used for meta?

VariableDeclaration
    = TypeToken _ id:Identifier _ "=" _ value:Type EOL
    { return node("TypeDeclaration", { id, value }) }
    / meta:MetaProperties declarationType:VariableDeclarationType
        _ id:Pattern _ type:(":" _ @Type)? _ value:('=' _ @OutlineExpression / EOL {return null})?
    {
        return node("VariableDeclaration", { ...declarationType, id, type, value, meta })
    }

MetaProperties
 = (@DynamicOutlineProperty Dent)*

DynamicOutlineProperty
    = '[' _ key:InlineExpression _ ']' value:(_ ":" _ @OutlineExpression / EOL { return null })
    { return node("KeyValuePair", {key, value, computed:true} ) }

// VariableMetaProperties
//     = EOL Indent @OutlineProperty+ Outdent

AssignmentOperator
    = "="
    / "+="
    / "-="
    / "*="
    / "/="

AssignmentStatement
    = left:Reference _ op:AssignmentOperator _ right:OutlineExpression
    {
        if (op.length > 1) {
            right = operation(left, node("Identifier",{name:op.slice(0,-1)}), right)
        }
        return node("AssignmentStatement", {left, right})
    }

BlockStatement
    = EOL Indent body:(Dent @Statement)+ Outdent
    { return node("BlockStatement", { body }) }

ForInStatement
    = ForToken _ left:Pattern _ InToken _ right:InlineExpression body:BlockStatement
    { return node("ForInStatement", { left, right, body } ) }

WhileStatement
    = WhileToken _ test:InlineExpression body:BlockStatement
    { return node("WhileStatement", { test, body }) }

IfStatement
    = IfToken _ test:InlineExpression consequent:BlockStatement
        alternate:(Dent ElseToken _ @(BlockStatement / IfStatement))?
    { return node("IfStatement", { test, consequent, alternate }) }

ReturnStatement
    = ReturnToken _ argument:OutlineExpression?
    { return node("ReturnStatement", { argument }) }

////////////////////////////////////////////////////////////////////////////////
//  Patterns
////////////////////////////////////////////////////////////////////////////////

Pattern
    = Identifier
    / ArrayPattern
    / ObjectPattern

ArrayPattern
    = "[" _ element:RestElement _ "]"
    { return node("ArrayPattern", { elements: [element] }) }
    / "[" _ head:Pattern? tail:(_ "," _ !"." @Pattern?)* _ rest:("," _ @RestElement)? _ "]"
    {
        let elements = [head || null, ...tail.map((x) => x || null)]
        if (rest)
            elements.push(rest)
        return node("ArrayPattern", { elements })
    }

RestElement
    = "..." argument:Pattern
    { return node("RestElement", { argument }) }

ObjectPattern
    = "{" _ head:AssignmentProperty tail:(_ "," @AssignmentProperty)* _ "}"
    { return node("ObjectPattern", { elements: [head, ...tail] }) }

AssignmentProperty
    = key:Identifier value:(_ ":" _ @Pattern)?
    { return node("KeyValuePair", { key, value: value || node("Identifier", { name: key }) } ) }

////////////////////////////////////////////////////////////////////////////////
//  Class
////////////////////////////////////////////////////////////////////////////////

ClassDeclaration
    = meta:MetaProperties isStructure:(ClassToken { return false } / StructToken { return true })
        _ id:Identifier params:TemplateParameters? _ baseClasses:Extends? EOL
        Indent declarations:(Dent @Declaration)* Outdent
        { return node("ClassDeclaration", { id, isStructure, params: params || [], meta, baseClasses: baseClasses || [], declarations: toMap(declarations), static: new Map() }) }

TemplateParameters
    = "<" _ head:Parameter tail:(_ ',' _ @Parameter)* _ ">" { return [head, ...tail] }

Extends
    = ExtendsToken _ head:TemplateReference tail:(_ "," _ @TemplateReference)*
    { return [head, ...tail] }

////////////////////////////////////////////////////////////////////////////////
//  TypeExpression
////////////////////////////////////////////////////////////////////////////////

Type
    = type:UnionType
    {
        // let isReference = ast.BinaryExpression.is(type) && type.operator === "is" && ast.Reference.is(type.right)
        // return isReference ? type.right : node("TypeExpression", { value: type })
    }

UnionType
    = left:ConstrainedType right:(_ "|" _ @UnionType)?
    { return right ? node('BinaryExpression', { left, operator: "|", right }) : left }

ConstrainedType
    = left:Constraint right:(_ "&" _ @ConstrainedType)?
    { return right ? node('BinaryExpression', { left, operator: "&", right }) : left }

Constraint
    = right:Literal
    { return node('BinaryExpression', { left: node('DotExpression'), operator: '==', right }) }
    / left:MemberExpression? _ operator:(">=" / "<=" / ">" / "<" / "==" / "!=" / "is") _ right:MemberExpression
    { return node('BinaryExpression', { left: left || node('DotExpression'), operator, right }) }
    / right:(FunctionType / Reference /* Regex */)
    { return node('BinaryExpression', { left:node('DotExpression'), operator: 'is', right }) }
    // / TypeofToken _ argument:Reference
    // { return node('UnaryExpression', { operator: "typeof", argument })}

FunctionType
    = params:FunctionParameters _ "=>" _ returnType:Type
    { return node("FunctionType", {params, returnType}) }
    / "(" _ @FunctionType _ ")"

TemplateArgument
    = Type
    // / InlineExpression

TemplateArguments
    = "<" _ head:TemplateArgument tail:(_ "," _ @TemplateArgument)*  _ ">"
    { return [head, ...tail] }

TemplateReference
    = reference:Reference args:(_ @TemplateArguments)?
    { return args ? node("TemplateReference", { reference, arguments: args }) : reference }

// Quantifier
//     = "?" { return [0,1] }
//     / "*" { return [0, null] }
//     / "+" { return [1, null] }
//     / Range

// Range
//     = from:DecimalInteger _ ".." _ to:DecimalInteger? { return [from, to || null] }
//     / ".." _ to:DecimalInteger { return [null, to] }
//     / value:DecimalInteger { return [value, value] }

// KeyValue
//     = key:Type value:(_ ':' _ @Type)? _ quantifier:Quantifier?
//         { return node('KeyValue', {key, value, quantifier} ) }

// CollectionType
//     = '[' _ ']'
//         { return node('CollectionType', {elements:[]}) }
//     / '[' _ head:KeyValue tail:(_ ',' _ @KeyValue)* _ ']'
//         { return node('CollectionType', {elements:[head, ...tail]}) }

////////////////////////////////////////////////////////////////////////////////
//  Operations
////////////////////////////////////////////////////////////////////////////////

UnaryOperator
    = "+" / "-" / NotToken / "!" / TypeofToken

UnaryExpression
    = MemberExpression
    / operator:UnaryOperator _ argument:MemberExpression { return operation(argument, operator) }

ExponentiationOperator "operator"
    = "**" / "<<" / ">>"

ExponentiationExpression
    = left:UnaryExpression right:(_ operator:ExponentiationOperator _ right:ExponentiationExpression {return {operator,right}})?
    { return right ? node("BinaryExpression", {left, operator:right.operator, right:right.right}) : left }

MultiplicativeOperator
    = "*" / "/" / "%"

MultiplicativeExpression
    = head:ExponentiationExpression tail:(_ MultiplicativeOperator _ ExponentiationExpression)*
    { return buildBinaryExpression(head, tail) }

AdditiveOperator
    = "+" / "-"

AdditiveExpression
    = head:MultiplicativeExpression tail:(_ AdditiveOperator _ MultiplicativeExpression)*
    { return buildBinaryExpression(head, tail) }

RelationalOperator
    = "<=" / ">=" / "<" / ">" / IsToken / IsntToken

RelationalExpression
    = head:AdditiveExpression tail:(_ RelationalOperator _ AdditiveExpression)*
        { return buildBinaryExpression(head, tail) }
    / tail:(_ RelationalOperator _ AdditiveExpression)
        { return buildBinaryExpression(node('DotExpression') , [tail]) }

EqualityOperator
    = "==" / "!="

EqualityExpression
    = head:RelationalExpression tail:(_ EqualityOperator _ RelationalExpression)*
    { return buildBinaryExpression(head, tail) }

LogicalAndOperator
    = "&"

LogicalAndExpression
    = head:EqualityExpression tail:(_ LogicalAndOperator _ EqualityExpression)*
    { return buildBinaryExpression(head, tail) }

LogicalOrOperator
    = "|" / XorToken

LogicalOrExpression
    = head:LogicalAndExpression tail:(_ LogicalOrOperator _ LogicalAndExpression)*
    { return buildBinaryExpression(head, tail) }

ConditionalOperator
    = "?"

ConditionalExpression
    = test:LogicalOrExpression
        body:(
            _ ConditionalOperator _ consequent:ConditionalExpression
            _ ':' _ alternate:ConditionalExpression
            { return [consequent,alternate] }
        )?
    { return body ? node('ConditionalExpression', { test, body }) : test }

////////////////////////////////////////////////////////////////////////////////
//  Functions
////////////////////////////////////////////////////////////////////////////////

Parameter
    = id:Pattern _ type:(":" _ @Type)? _ value:("=" !">" _ @InlineExpression)?
    { return node("Parameter", { id, type, value })}

FunctionParameters
    = "(" _ ")" { return [] }
    / id:Identifier { return [node("Parameter", { id } )] }
    / "(" _ head:Parameter tail:(_ ',' _ @Parameter)* _ ")" { return [head, ...tail] }

FunctionHead
    = id:(@Identifier _ &"(")? params:FunctionParameters? type:(_ ":" _ @Type)? _ "=>"
    { return { id, type, params: params || [] } }

InlineFunction
    = head:FunctionHead _ value:InlineExpression
    { return node("FunctionExpression", { ...head, body: node("BlockStatement", { body: [node("ReturnStatement", { argument: value } )] } ) } ) }

OutlineFunction
    = head:FunctionHead _ body:BlockStatement
    { return node("FunctionExpression", { ...head, body }) }

////////////////////////////////////////////////////////////////////////////////
//  Expressions
////////////////////////////////////////////////////////////////////////////////

OutlineExpression
    = OutlineFunction
    / OutlineCallExpression
    / OutlineNewExpression
    / OutlineStringLiteral
    / @InlineExpression EOL
    //  TODO: Allow Optional BlockStatement After to imply function call.

OutlineArguments
    = EOL Indent @(Dent @OutlineExpression)+ Outdent

OutlineCallExpression
    = callee:InlineExpression args:OutlineArguments
    { return node("CallExpression", { callee, arguments: args }) }

OutlineNewExpression
    = NewToken _ callee:MemberExpressionNoCall args:(InlineArguments / OutlineArguments)
    { return node("CallExpression", { new: true, callee, arguments: args }) }

InlineExpression
    = InlineFunction
    / ConditionalExpression

PrimaryExpression
    = Reference
    / Literal
    / ThisExpression
    / DotExpression
    / GroupExpression
    / ArrayExpression
    / ObjectExpression

GroupExpression
    = "(" _ @InlineExpression _ ")"

ThisExpression
    = ThisToken { return node('ThisExpression') }

DotExpression
    = "." property:Identifier
    { return node('MemberExpression',{object:node('DotExpression'),property,computed:false}) }
    / ".[" _ property:InlineExpression _ "]"
    { return node('MemberExpression',{object:node('DotExpression'),property,computed:true}) }
    / "."
    { return node('DotExpression') }

Property
    = "[" _ key:InlineExpression _ "]" _ ":" _ value: InlineExpression
    / key:(@Identifier _ ":")? _ value:InlineExpression
    { return node("Property", {key,value}) }

PropertyList
    = head:Property tail:(_ "," _ @Property)*
    { return [head, ...tail] }

InlineExpressionList
    = head:InlineExpression tail:(_ "," _ @InlineExpression)*
    { return [head, ...tail] }

InlineArguments
    = "()" { return [] }
    / "(" _ @InlineExpressionList _ ")"
    / _ @InlineExpressionList

ChainMemberComputed
    = optional:"?"? "[" _ property:InlineExpression _ "]"
    { return { property, computed:true, optional: optional != null } }

ChainMember
    = optional:"?"? _ "." property:Identifier
    { return { property, computed:false, optional: optional != null } }

ChainMemberCall
    = optional:"?"? args:InlineArguments
    { return { arguments:args, optional: optional != null } }

MemberExpression =
    head: PrimaryExpression
    tail: (ChainMemberComputed / ChainMember / ChainMemberCall)*
    {
        return tail.reduce(
            (left, right) => {
                if (right.arguments) {
                    return node("CallExpression", {callee:left, ...right})
                }
                else {
                    return node("MemberExpression", { object:left, ...right })
                }
            }
            ,head
        )
    }

MemberExpressionNoCall =
    head: PrimaryExpression
    tail: (ChainMemberComputed / ChainMember)*
    {
        return tail.reduce(
            (left, right) => node("MemberExpression", { object:left, ...right })
            ,head
        )
    }

////////////////////////////////////////////////////////////////////////////////
//  Literals
////////////////////////////////////////////////////////////////////////////////

ArrayExpression
    = InlineArrayExpression

ArrayElements
    = head:InlineExpression tail:(_ "," _ @InlineExpression)*
    { return [head, ...tail] }

InlineArrayExpression
    = "[" _ elements:ArrayElements? _ "]"
    {
        return node("ArrayExpression", {elements:elements || []})
    }

ObjectExpression
    = InlineObjectExpression

InlineObjectExpression
    = "{" _ properties:PropertyList? _ "}"
    {
        return node("ObjectExpression", {properties: properties || []})
    }


Literal
    = NumericLiteral
    / BooleanLiteral
    / StringLiteral
    // / CharLiteral
    / NullLiteral

NumericLiteral
    = HexIntegerLiteral
    / DecimalLiteral
    / DecimalIntegerLiteral

NullLiteral
    = NullToken { return node('Literal', { value: null }) }

BooleanLiteral
    = value: (TrueToken / FalseToken) { return node('Literal', { value: JSON.parse(value) ? true : false } ) }

ExponentPart
    = 'e' [+-]? [0-9]+ !IdPart

DecimalLiteral
    = (DecimalInteger? '.' [0-9]+ ExponentPart? / DecimalInteger ExponentPart) !IdPart
    { return node('Literal', { value: parseFloat(text()) })}

HexDigit
    = [0-9A-F]

HexIntegerLiteral
    = '0x' HexDigit+ !IdPart { return node('Literal', {value: parseInt(text(), 16) }) }

DecimalIntegerLiteral
    = DecimalInteger { return node('Literal', { value: parseInt(text()) }) }

DecimalInteger
    = '0' / [+-]? [1-9] [0-9]* !IdPart { return parseInt(text()) }

StringLiteral
    = '"' DoubleStringChar* '"' { return node('Literal', { value: eval(text()) }); }

DoubleStringChar
    = [^\r\n\t\b\f"] / "\\" ([rn"] / "u" HexDigit<4>)

// CharLiteral
//     = "'" DoubleStringChar* "'" { return node('CharLiteral', eval(text())); }

OutlineStringLiteralLine
    = _ LineTerminatorSequence { return '' }
    / Dent line:[^\r\n]* LineTerminatorSequence { return line.join('') }

OutlineStringLiteral
    = '""' EOL Indent lines:OutlineStringLiteralLine* Outdent
    { return node('Literal', { value: lines.join('\n') }) }

////////////////////////////////////////////////////////////////////////////////
//  Identifiers
////////////////////////////////////////////////////////////////////////////////

IdStart
    = [a-zA-Z$_]

IdPart
    = IdStart / [0-9]

IdName
    = $(!ReservedWord IdStart IdPart*)
    / "`" @($((!"`" .)*)) "`"

Identifier
    = name:IdName { return node('Identifier', { name }) }

Reference
    = name:IdName {
        return node("Reference", { name })
    }

////////////////////////////////////////////////////////////////////////////////
//  Tokens and Keywords
////////////////////////////////////////////////////////////////////////////////

ThisToken       = @"this"       !IdPart
NullToken       = @"null"       !IdPart
TrueToken       = @"false"      !IdPart
FalseToken      = @"true"       !IdPart
TypeToken       = @"type"       !IdPart
IsToken         = @"is"         !IdPart
IsntToken       = @"isnt"       !IdPart
AsToken         = @"as"         !IdPart
AndToken        = @"and"        !IdPart
OrToken         = @"or"         !IdPart
XorToken        = @"xor"        !IdPart
NotToken        = @"not"        !IdPart
TypeofToken     = @"typeof"     !IdPart
NewToken        = @"new"        !IdPart
WhereToken      = @"where"      !IdPart
ImportToken     = @"import"     !IdPart
ExportToken     = @"export"     !IdPart
DefaultToken    = @"default"    !IdPart
ClassToken      = @"class"      !IdPart
StructToken     = @"struct"     !IdPart
VarToken        = @"var"        !IdPart
LetToken        = @"let"        !IdPart
PropertyToken   = @"property"   !IdPart
ExtendsToken    = @"extends"    !IdPart
ForToken        = @"for"        !IdPart
WhileToken      = @"while"      !IdPart
InToken         = @"in"         !IdPart
OfToken         = @"of"         !IdPart
IfToken         = @"if"         !IdPart
ElseToken       = @"else"       !IdPart
ReturnToken     = @"return"     !IdPart
BreakToken      = @"break"      !IdPart
ContinueToken   = @"continue"   !IdPart
AsmToken        = @"asm"        !IdPart
ThrowToken      = @"throw"      !IdPart

Keyword
    = ThisToken
    / NullToken
    / TrueToken
    / FalseToken
    / AndToken
    / IsToken
    / IsntToken
    / AsToken
    / OrToken
    / XorToken
    / NotToken
    / TypeofToken
    / NewToken
    / WhereToken
    / ClassToken
    / StructToken
    / VarToken
    / LetToken
    / ForToken
    / WhileToken
    / IfToken
    / ElseToken
    / ReturnToken
    / BreakToken
    / ContinueToken
    / ExportToken
    / ImportToken
    / AsmToken
    / ThrowToken

ReservedWord
    = Keyword

////////////////////////////////////////////////////////////////////////////////
//  Indentation
////////////////////////////////////////////////////////////////////////////////

Indent = indentation++
Outdent = indentation--
Dent = "    "<indentation>

////////////////////////////////////////////////////////////////////////////////
//  Whitespace
////////////////////////////////////////////////////////////////////////////////

LineTerminatorSequence
    = "\n"
    / "\r\n"
    / "\r"

Comment ""
    = "#" (![\r\n] .)*

_ ""
    = ' '*

__ ""
    = (' ' / LineTerminatorSequence / Comment)*

EOL "end of line"
    = (_ Comment? LineTerminatorSequence+)+ / EOF

EOF "" = !.
